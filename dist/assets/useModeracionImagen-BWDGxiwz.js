const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/mobilenet_v2-DcXBpXMN.js","assets/index-SFMBmmo4.js","assets/animations-muhxMtO2.js","assets/vendor-CSbuTdnm.js","assets/charts-x2pUV8ZK.js","assets/ui-4Jv8TcDS.js","assets/utils-BJeS7sC5.js","assets/index-BhArO18i.css","assets/mobilenet_v2_mid-C3dlDOIT.js","assets/inception_v3-DgsGdnYZ.js"])))=>i.map(i=>d[i]);
import{r as Lr}from"./animations-muhxMtO2.js";import{_ as Po}from"./index-SFMBmmo4.js";import{g as HN,b as jN}from"./vendor-CSbuTdnm.js";function qN(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(n,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}const KN=1e-7,XN=1e-4;class Lf{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Jc{refCount(e){return xn("refCount")}incRef(e){return xn("incRef")}timerAvailable(){return!0}time(e){return xn("time")}read(e){return xn("read")}readSync(e){return xn("readSync")}readToGPU(e,t){return xn("readToGPU")}numDataIds(){return xn("numDataIds")}disposeData(e,t){return xn("disposeData")}write(e,t,s){return xn("write")}move(e,t,s,r,o){return xn("move")}createTensorFromGPUData(e,t,s){return xn("createTensorFromGPUData")}memory(){return xn("memory")}floatPrecision(){return xn("floatPrecision")}epsilon(){return this.floatPrecision()===32?KN:XN}dispose(){return xn("dispose")}}function xn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Pf(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,zs(n,e,t)}function YN(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,zs(n,t,s),zs(e,t,s)}function mr(n,e,t){return Math.max(n,Math.min(e,t))}function Zc(n){return n%2===0?n:n+1}function zs(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function P0(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function JN(n,e){const t=Math.random();return e*t+(1-t)*n}function ZN(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function C(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function qt(n,e,t=""){C(_e(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function bo(n){C(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function X(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function QN(n){return n.length===0}function z0(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function _e(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Qr(n){return n%1===0}function eC(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function vc(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function tC(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return Pf(e),e}function Kr(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Bp(n,e=r=>0,t,s){return new Promise((r,o)=>{let i=0;const a=()=>{if(n()){r();return}i++;const l=e(i);if(t!=null&&i>=t){o();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function zf(n,e){let t=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Re(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),C(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),C(n.every(s=>Qr(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Ys(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:Re(e,n).sort();let i=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[i]==null||o[i]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),o[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Ot(n,e){return pt(n,e)}function pt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function B0(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function M0(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Bf(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Oa(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function V0(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function vs(n){return typeof n=="string"||n instanceof String}function W0(n){return typeof n=="boolean"}function Ic(n){return typeof n=="number"}function xo(n){return Array.isArray(n)?xo(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Ic(n)?"float32":vs(n)?"string":W0(n)?"bool":"float32"}function gr(n){return!!(n&&n.constructor&&n.call&&n.apply)}function $c(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function we(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function U0(n,e,t,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let i=0;i<o;i++)r[i]=t[n+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<o;l++)r[l]=U0(n+l*a,i,t,s)}return r}function Bn(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,o)=>r*o)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return U0(0,n,e,t)}function G0(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Qc(n,e){const t=jt(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function jt(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Mf(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Bn(n,new Float32Array(t));if(e==="int32")return Bn(n,new Int32Array(t));if(e==="bool")return Bn(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function En(n){n.forEach(e=>{C(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function os(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function wo(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Vs(n){return n&&n.then&&typeof n.then=="function"}const Hb="tfjsflags";class H0{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=nC,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Vs(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Hb in e&&e[Hb].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=rC(r,o)})}}function nC(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(sC(e,s[0],s[1]),s.join("="))),e}function sC(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function rC(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function H(){return Vf}let Vf=null;function oC(n){Vf=n}let vp;function j0(){if(vp==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");vp=n}return vp}function iC(){const n=j0();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Wf(n,e){const t=iC();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const tl="Abs",ti="Acos",ni="Acosh",vo="Add",nl="AddN",eh="All",th="Any",sl="ArgMax",rl="ArgMin",si="Asin",ri="Asinh",oi="Atan",ii="Atanh",ai="Atan2",ol="AvgPool",nh="AvgPoolGrad",il="AvgPool3D",sh="AvgPool3DGrad",al="BatchMatMul",ll="BatchToSpaceND",rh="Bincount",ul="BitwiseAnd",q0="BroadcastTo",oh="BroadcastArgs",li="Cast",ui="Ceil",ci="ClipByValue",ih="Complex",cl="ComplexAbs",hl="Concat",dl="Conv2D",ah="Conv2DBackpropFilter",pl="Conv2DBackpropInput",fl="Conv3D",lh="Conv3DBackpropFilterV2",uh="Conv3DBackpropInputV2",hi="Cos",di="Cosh",ch="Cumprod",ml="Cumsum",hh="CropAndResize",dh="DenseBincount",ph="DepthToSpace",gl="DepthwiseConv2dNative",fh="DepthwiseConv2dNativeBackpropFilter",mh="DepthwiseConv2dNativeBackpropInput",gh="Diag",yl="Dilation2D",Sc="Dilation2DBackpropInput",Nc="Dilation2DBackpropFilter",yh="Draw",pi="RealDiv",bh="Einsum",fi="Elu",xh="EluGrad",mi="Erf",bl="Equal",gi="Exp",xl="ExpandDims",yi="Expm1",wh="FFT",vh="Fill",Ih="FlipLeftRight",bi="Floor",xi="FloorDiv",wl="FusedBatchNorm",vl="GatherV2",$h="GatherNd",Il="Greater",wi="GreaterEqual",vi="Identity",Sh="IFFT",Nh="Imag",Ii="IsFinite",$i="IsInf",Si="IsNan",$l="LeakyRelu",Sl="Less",Nl="LessEqual",Ch="LinSpace",Ni="Log",Ci="Log1p",Cl="LogicalAnd",kl="LogicalNot",Tl="LogicalOr",aC="LogicalXor",K0="LogSoftmax",lC="LowerBound",El="LRN",kh="LRNGrad",uC="MatrixBandPart",Al="Max",ki="Maximum",Rl="MaxPool",Th="MaxPoolGrad",Dl="MaxPool3D",Eh="MaxPool3DGrad",Ah="MaxPoolWithArgmax",Fl="Mean",_l="Min",Ti="Minimum",Ol="MirrorPad",Ei="Mod",Rh="Multinomial",Ai="Multiply",Ll="Neg",Pl="NotEqual",Dh="NonMaxSuppressionV3",Fh="NonMaxSuppressionV4",_h="NonMaxSuppressionV5",zl="OnesLike",Bl="OneHot",Ml="Pack",Vl="PadV2",cC="Pool",Ri="Pow",Wl="Prelu",Ul="Prod",Oh="RaggedGather",Lh="RaggedRange",Ph="RaggedTensorToTensor",zh="Range",Bh="Real",Di="Reciprocal",Fi="Relu",Gl="Reshape",Hl="ResizeNearestNeighbor",Mh="ResizeNearestNeighborGrad",jl="ResizeBilinear",Vh="ResizeBilinearGrad",_i="Relu6",ql="Reverse",Oi="Round",Li="Rsqrt",Wh="ScatterNd",Uh="TensorScatterUpdate",Gh="SearchSorted",Kl="Select",Pi="Selu",Xl="Slice",zi="Sin",Bi="Sinh",Mi="Sign",Vi="Sigmoid",Wi="Softplus",Ui="Sqrt",Yl="Sum",Jl="SpaceToBatchND",Zl="SplitV",Ql="Softmax",Hh="SparseFillEmptyRows",jh="SparseReshape",qh="SparseSegmentMean",Kh="SparseSegmentSum",Xh="SparseToDense",Gi="SquaredDifference",Yh="Square",eu="StaticRegexReplace",Jh="StridedSlice",Zh="StringNGrams",Qh="StringSplit",ed="StringToHashBucketFast",Hi="Sub",ji="Tan",qi="Tanh",Ki="Tile",td="TopK",nd="Transform",Xr="Transpose",sd="Unique",tu="Unpack",nu="UnsortedSegmentSum",hC="UpperBound",su="ZerosLike",Xi="Step",Cc="FromPixels",rd="RotateWithOffset",La="_FusedMatMul",Pa="FusedConv2D",za="FusedDepthwiseConv2D";function Fn(...n){H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(...n)}function dC(...n){H().getBool("IS_TEST")||H().getBool("PROD")||console.log(...n)}const Vo=Wf("kernelRegistry",()=>new Map),Ba=Wf("gradRegistry",()=>new Map);function Ma(n,e){const t=Uf(n,e);return Vo.get(t)}function Mp(n){return Ba.get(n)}function kc(n){const e=Vo.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,i]=r,[a]=o.split("_");a===n&&t.push(i)}return t}function od(n){const{kernelName:e,backendName:t}=n,s=Uf(e,t);Vo.has(s)&&Fn(`The kernel '${e}' for backend '${t}' is already registered`),Vo.set(s,n)}function X0(n){const{kernelName:e}=n;Ba.has(e)&&H().getBool("DEBUG")&&Fn(`Overriding the gradient for '${e}'`),Ba.set(e,n)}function pC(n,e){const t=Uf(n,e);if(!Vo.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Vo.delete(t)}function fC(n){if(!Ba.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Ba.delete(n)}function mC(n,e){kc(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});od(r)})}function Uf(n,e){return`${e}_${n}`}function Y0(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Ip,jb;function gC(){if(jb)return Ip;jb=1,Ip=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(R,N,z){this.low=R|0,this.high=N|0,this.unsigned=!!z}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(R){return(R&&R.__isLong__)===!0}e.isLong=t;var s={},r={};function o(R,N){var z,V,j;return N?(R>>>=0,(j=0<=R&&R<256)&&(V=r[R],V)?V:(z=a(R,(R|0)<0?-1:0,!0),j&&(r[R]=z),z)):(R|=0,(j=-128<=R&&R<128)&&(V=s[R],V)?V:(z=a(R,R<0?-1:0,!1),j&&(s[R]=z),z))}e.fromInt=o;function i(R,N){if(isNaN(R))return N?b:y;if(N){if(R<0)return b;if(R>=f)return D}else{if(R<=-m)return F;if(R+1>=m)return k}return R<0?i(-R,N).neg():a(R%p|0,R/p|0,N)}e.fromNumber=i;function a(R,N,z){return new e(R,N,z)}e.fromBits=a;var l=Math.pow;function u(R,N,z){if(R.length===0)throw Error("empty string");if(R==="NaN"||R==="Infinity"||R==="+Infinity"||R==="-Infinity")return y;if(typeof N=="number"?(z=N,N=!1):N=!!N,z=z||10,z<2||36<z)throw RangeError("radix");var V;if((V=R.indexOf("-"))>0)throw Error("interior hyphen");if(V===0)return u(R.substring(1),N,z).neg();for(var j=i(l(z,8)),G=y,q=0;q<R.length;q+=8){var J=Math.min(8,R.length-q),K=parseInt(R.substring(q,q+J),z);if(J<8){var Q=i(l(z,J));G=G.mul(Q).add(i(K))}else G=G.mul(j),G=G.add(i(K))}return G.unsigned=N,G}e.fromString=u;function c(R,N){return typeof R=="number"?i(R,N):typeof R=="string"?u(R,N):a(R.low,R.high,typeof N=="boolean"?N:R.unsigned)}e.fromValue=c;var h=65536,d=1<<24,p=h*h,f=p*p,m=f/2,g=o(d),y=o(0);e.ZERO=y;var b=o(0,!0);e.UZERO=b;var v=o(1);e.ONE=v;var x=o(1,!0);e.UONE=x;var S=o(-1);e.NEG_ONE=S;var k=a(-1,2147483647,!1);e.MAX_VALUE=k;var D=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=D;var F=a(0,-2147483648,!1);e.MIN_VALUE=F;var A=e.prototype;return A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},A.toString=function(N){if(N=N||10,N<2||36<N)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(F)){var z=i(N),V=this.div(z),j=V.mul(z).sub(this);return V.toString(N)+j.toInt().toString(N)}else return"-"+this.neg().toString(N);for(var G=i(l(N,6),this.unsigned),q=this,J="";;){var K=q.div(G),Q=q.sub(K.mul(G)).toInt()>>>0,te=Q.toString(N);if(q=K,q.isZero())return te+J;for(;te.length<6;)te="0"+te;J=""+te+J}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(F)?64:this.neg().getNumBitsAbs();for(var N=this.high!=0?this.high:this.low,z=31;z>0&&(N&1<<z)==0;z--);return this.high!=0?z+33:z+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(this.low&1)===1},A.isEven=function(){return(this.low&1)===0},A.equals=function(N){return t(N)||(N=c(N)),this.unsigned!==N.unsigned&&this.high>>>31===1&&N.high>>>31===1?!1:this.high===N.high&&this.low===N.low},A.eq=A.equals,A.notEquals=function(N){return!this.eq(N)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(N){return this.comp(N)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(N){return this.comp(N)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(N){return this.comp(N)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(N){return this.comp(N)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(N){if(t(N)||(N=c(N)),this.eq(N))return 0;var z=this.isNegative(),V=N.isNegative();return z&&!V?-1:!z&&V?1:this.unsigned?N.high>>>0>this.high>>>0||N.high===this.high&&N.low>>>0>this.low>>>0?-1:1:this.sub(N).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(F)?F:this.not().add(v)},A.neg=A.negate,A.add=function(N){t(N)||(N=c(N));var z=this.high>>>16,V=this.high&65535,j=this.low>>>16,G=this.low&65535,q=N.high>>>16,J=N.high&65535,K=N.low>>>16,Q=N.low&65535,te=0,ee=0,ne=0,oe=0;return oe+=G+Q,ne+=oe>>>16,oe&=65535,ne+=j+K,ee+=ne>>>16,ne&=65535,ee+=V+J,te+=ee>>>16,ee&=65535,te+=z+q,te&=65535,a(ne<<16|oe,te<<16|ee,this.unsigned)},A.subtract=function(N){return t(N)||(N=c(N)),this.add(N.neg())},A.sub=A.subtract,A.multiply=function(N){if(this.isZero())return y;if(t(N)||(N=c(N)),n){var z=n.mul(this.low,this.high,N.low,N.high);return a(z,n.get_high(),this.unsigned)}if(N.isZero())return y;if(this.eq(F))return N.isOdd()?F:y;if(N.eq(F))return this.isOdd()?F:y;if(this.isNegative())return N.isNegative()?this.neg().mul(N.neg()):this.neg().mul(N).neg();if(N.isNegative())return this.mul(N.neg()).neg();if(this.lt(g)&&N.lt(g))return i(this.toNumber()*N.toNumber(),this.unsigned);var V=this.high>>>16,j=this.high&65535,G=this.low>>>16,q=this.low&65535,J=N.high>>>16,K=N.high&65535,Q=N.low>>>16,te=N.low&65535,ee=0,ne=0,oe=0,ue=0;return ue+=q*te,oe+=ue>>>16,ue&=65535,oe+=G*te,ne+=oe>>>16,oe&=65535,oe+=q*Q,ne+=oe>>>16,oe&=65535,ne+=j*te,ee+=ne>>>16,ne&=65535,ne+=G*Q,ee+=ne>>>16,ne&=65535,ne+=q*K,ee+=ne>>>16,ne&=65535,ee+=V*te+j*Q+G*K+q*J,ee&=65535,a(oe<<16|ue,ee<<16|ne,this.unsigned)},A.mul=A.multiply,A.divide=function(N){if(t(N)||(N=c(N)),N.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&N.low===-1&&N.high===-1)return this;var z=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,N.low,N.high);return a(z,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?b:y;var V,j,G;if(this.unsigned){if(N.unsigned||(N=N.toUnsigned()),N.gt(this))return b;if(N.gt(this.shru(1)))return x;G=b}else{if(this.eq(F)){if(N.eq(v)||N.eq(S))return F;if(N.eq(F))return v;var q=this.shr(1);return V=q.div(N).shl(1),V.eq(y)?N.isNegative()?v:S:(j=this.sub(N.mul(V)),G=V.add(j.div(N)),G)}else if(N.eq(F))return this.unsigned?b:y;if(this.isNegative())return N.isNegative()?this.neg().div(N.neg()):this.neg().div(N).neg();if(N.isNegative())return this.div(N.neg()).neg();G=y}for(j=this;j.gte(N);){V=Math.max(1,Math.floor(j.toNumber()/N.toNumber()));for(var J=Math.ceil(Math.log(V)/Math.LN2),K=J<=48?1:l(2,J-48),Q=i(V),te=Q.mul(N);te.isNegative()||te.gt(j);)V-=K,Q=i(V,this.unsigned),te=Q.mul(N);Q.isZero()&&(Q=v),G=G.add(Q),j=j.sub(te)}return G},A.div=A.divide,A.modulo=function(N){if(t(N)||(N=c(N)),n){var z=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,N.low,N.high);return a(z,n.get_high(),this.unsigned)}return this.sub(this.div(N).mul(N))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return a(~this.low,~this.high,this.unsigned)},A.and=function(N){return t(N)||(N=c(N)),a(this.low&N.low,this.high&N.high,this.unsigned)},A.or=function(N){return t(N)||(N=c(N)),a(this.low|N.low,this.high|N.high,this.unsigned)},A.xor=function(N){return t(N)||(N=c(N)),a(this.low^N.low,this.high^N.high,this.unsigned)},A.shiftLeft=function(N){return t(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?a(this.low<<N,this.high<<N|this.low>>>32-N,this.unsigned):a(0,this.low<<N-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(N){return t(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?a(this.low>>>N|this.high<<32-N,this.high>>N,this.unsigned):a(this.high>>N-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(N){if(t(N)&&(N=N.toInt()),N&=63,N===0)return this;var z=this.high;if(N<32){var V=this.low;return a(V>>>N|z<<32-N,z>>>N,this.unsigned)}else return N===32?a(z,0,this.unsigned):a(z>>>N-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},A.toBytes=function(N){return N?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var N=this.high,z=this.low;return[z&255,z>>>8&255,z>>>16&255,z>>>24,N&255,N>>>8&255,N>>>16&255,N>>>24]},A.toBytesBE=function(){var N=this.high,z=this.low;return[N>>>24,N>>>16&255,N>>>8&255,N&255,z>>>24,z>>>16&255,z>>>8&255,z&255]},e.fromBytes=function(N,z,V){return V?e.fromBytesLE(N,z):e.fromBytesBE(N,z)},e.fromBytesLE=function(N,z){return new e(N[0]|N[1]<<8|N[2]<<16|N[3]<<24,N[4]|N[5]<<8|N[6]<<16|N[7]<<24,z)},e.fromBytesBE=function(N,z){return new e(N[4]<<24|N[5]<<16|N[6]<<8|N[7],N[0]<<24|N[1]<<16|N[2]<<8|N[3],z)},Ip}var J0=gC();const Z0=HN(J0),yC=qN({__proto__:null,default:Z0},[J0]);const Vr=Z0||yC;function ru(n){return Vr.fromString(n,!0,16)}const Q0=ru("c3a5c85c97cb3127"),Br=ru("b492b66fbe98f273"),tn=ru("9ae16a3b2f90404f");function Vp(n){return n.xor(n.shru(47))}function ew(n,e,t){const s=n.slice(e,e+t);return Vr.fromBytes(Array.from(s),!0,!0)}function et(n,e){return ew(n,e,8)}function qb(n,e){return ew(n,e,4)}function Dt(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function hr(n,e,t=ru("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function bC(n,e,t,s,r,o){r=r.add(n),o=Dt(o.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(t),o=o.add(Dt(r,44)),[r.add(s),o.add(i)]}function Uu(n,e,t,s){return bC(et(n,e),et(n,e+8),et(n,e+16),et(n,e+24),t,s)}function xC(n,e=n.length){if(e>=8){const t=tn.add(e*2),s=et(n,0).add(tn),r=et(n,e-8),o=Dt(r,37).mul(t).add(s),i=Dt(s,25).add(r).mul(t);return hr(o,i,t)}if(e>=4){const t=tn.add(e*2),s=qb(n,0);return hr(s.shl(3).add(e),qb(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],o=t+(s<<8),i=e+(r<<2);return Vp(tn.mul(o).xor(Q0.mul(i))).mul(tn)}return tn}function wC(n,e=n.length){const t=tn.add(e*2),s=et(n,0).mul(Br),r=et(n,8),o=et(n,e-8).mul(t),i=et(n,e-16).mul(tn);return hr(Dt(s.add(r),43).add(Dt(o,30)).add(i),s.add(Dt(r.add(tn),18)).add(o),t)}function vC(n,e=n.length){const t=tn.add(e*2),s=et(n,0).mul(tn),r=et(n,8),o=et(n,e-8).mul(t),i=et(n,e-16).mul(tn),a=Dt(s.add(r),43).add(Dt(o,30)).add(i),l=hr(a,s.add(Dt(r.add(tn),18)).add(o),t),u=et(n,16).mul(t),c=et(n,24),h=a.add(et(n,e-32)).mul(t),d=l.add(et(n,e-24)).mul(t);return hr(Dt(u.add(c),43).add(Dt(h,30)).add(d),u.add(Dt(c.add(s),18)).add(h),t)}function tw(n,e=n.length){const t=Vr.fromNumber(81,!0);if(e<=32)return e<=16?xC(n,e):wC(n,e);if(e<=64)return vC(n,e);let s=t,r=t.mul(Br).add(113),o=Vp(r.mul(tn).add(113)).mul(tn),i=[Vr.UZERO,Vr.UZERO],a=[Vr.UZERO,Vr.UZERO];s=s.mul(tn).add(et(n,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=Dt(s.add(r).add(i[0]).add(et(n,l+8)),37).mul(Br),r=Dt(r.add(i[1]).add(et(n,l+48)),42).mul(Br),s=s.xor(a[1]),r=r.add(i[0]).add(et(n,l+40)),o=Dt(o.add(a[0]),33).mul(Br),i=Uu(n,l,i[1].mul(Br),s.add(a[0])),a=Uu(n,l+32,o.add(a[1]),r.add(et(n,l+16))),[o,s]=[s,o],l+=64;while(l!==u);const h=Br.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),s=Dt(s.add(r).add(i[0]).add(et(n,l+8)),37).mul(h),r=Dt(r.add(i[1]).add(et(n,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(i[0].mul(9).add(et(n,l+40))),o=Dt(o.add(a[0]),33).mul(h),i=Uu(n,l,i[1].mul(h),s.add(a[0])),a=Uu(n,l+32,o.add(a[1]),r.add(et(n,l+16))),[o,s]=[s,o],hr(hr(i[0],a[0],h).add(Vp(r).mul(Q0)).add(o),hr(i[1],a[1],h).add(s),h)}function Js(n,e){return e==="string"?$s(n):Cr([n],e)}function IC(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Cr(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ts(n)),H().getBool("DEBUG")&&B0(n,e),IC(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Vt(){return H().platform.now()}function nw(n,e){return H().platform.fetch(n,e)}function $s(n,e="utf-8"){return e=e||"utf-8",H().platform.encode(n,e)}function Ws(n,e="utf-8"){return e=e||"utf-8",H().platform.decode(n,e)}function Ct(n){return H().platform.isTypedArray!=null?H().platform.isTypedArray(n):Y0(n)}function Ts(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Vs(n)||n==null||Ct(n)&&t)e.push(n);else if(Array.isArray(n)||Ct(n))for(let s=0;s<n.length;++s)Ts(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ts(n[r],e,t)}return e}const $C=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:_e,arraysEqualWithNull:z0,assert:C,assertNonNegativeIntegerDimensions:En,assertNonNull:bo,assertShapesMatch:qt,bytesFromStringArray:V0,bytesPerElement:Oa,checkConversionForErrors:B0,clamp:mr,computeStrides:we,convertBackendValuesAndArrayBuffer:G0,createScalarValue:Js,createShuffledIndices:tC,decodeString:Ws,distSquared:ZN,encodeString:$s,fetch:nw,fingerPrint64:tw,flatten:Ts,getArrayFromDType:pt,getTypedArrayFromDType:Ot,hasEncodingLoss:Bf,hexToLong:ru,indexToLoc:wo,inferDtype:xo,inferFromImplicitShape:zf,isBoolean:W0,isFunction:gr,isInt:Qr,isNumber:Ic,isPromise:Vs,isScalarShape:QN,isString:vs,isTypedArray:Ct,isValidDtype:M0,locToIndex:os,makeOnesTypedArray:Qc,makeZerosNestedTypedArray:Mf,makeZerosTypedArray:jt,nearestDivisor:$c,nearestLargerEven:Zc,now:Vt,parseAxisParam:Re,randUniform:JN,repeatedTry:Bp,rightPad:Kr,shuffle:Pf,shuffleCombo:YN,sizeFromShape:X,sizeToSquarishShape:vc,squeezeShape:Ys,sum:P0,swap:zs,tanh:eC,toNestedArray:Bn,toTypedArray:Cr},Symbol.toStringTag,{value:"Module"}));class SC{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new CC)}profileKernel(e,t,s){let r;const o=()=>{r=s()};let i;const a=Vt();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of r)u.dataSync();i=Promise.resolve({kernelMs:Vt()-a})}if(H().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(h=>{NC(h,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:o,extraInfo:i}=e;s.forEach(a=>{Promise.all([a.data(),r,i]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],o,l[2])})})}}function NC(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class CC{logKernelProfile(e,t,s,r,o,i){const a=typeof r=="number"?Kr(`${r}ms`,9):r.error,l=Kr(e,25),u=t.rank,c=t.size,h=Kr(t.shape.toString(),14);let d="";for(const p in o){const f=o[p];if(f!=null){const m=f.shape||t.shape,g=m.length;d+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function kC(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){u.outputs.forEach(m=>s[m.id]=!0),p=!0,r[u.id]=!0;break}if(p)break}}const o={};o[t.id]=!0;const i={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(o[u.outputs[h].id]){for(const d in c)o[c[d].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&i[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];s[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function TC(n,e,t,s){for(let r=e.length-1;r>=0;r--){const o=e[r],i=[];if(o.outputs.forEach(l=>{const u=n[l.id];u!=null?i.push(u):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!_e(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=s(h,u),h.dispose()}}}}const Kb=20,xa=3,$p=7;function EC(n,e,t,s){const r=we(e),o=AC(n,e,t,r),i=e.length,a=oc(n,e,t,r,o),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function AC(n,e,t,s){const r=X(e),o=s[s.length-1],i=new Array(o).fill(0),a=e.length,l=t==="complex64"?Ca(n):n;if(a>1)for(let u=0;u<r/o;u++){const c=u*o;for(let h=0;h<o;h++)i[h]=Math.max(i[h],Na(l[c+h],0,t).length)}return i}function Na(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed($p))} + ${parseFloat(n[1].toFixed($p))}j`:vs(n)?s=`'${n}'`:t==="bool"?s=sw(n):s=parseFloat(n.toFixed($p)).toString(),Kr(s,e)}function sw(n){return n===0?"false":"true"}function oc(n,e,t,s,r,o=!0){const i=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=Ca(n);return[Na(m[0],0,t)]}return t==="bool"?[sw(n[0])]:[n[0].toString()]}if(l===1){if(a>Kb){const g=xa*i;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-xa)*i,a*i));return t==="complex64"&&(y=Ca(y),b=Ca(b)),["["+y.map((v,x)=>Na(v,r[x],t)).join(", ")+", ..., "+b.map((v,x)=>Na(v,r[a-xa+x],t)).join(", ")+"]"]}return["["+(t==="complex64"?Ca(n):Array.from(n)).map((g,y)=>Na(g,r[y],t)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*i,d=[];if(a>Kb){for(let m=0;m<xa;m++){const g=m*h,y=g+h;d.push(...oc(n.slice(g,y),u,t,c,r,!1))}d.push("...");for(let m=a-xa;m<a;m++){const g=m*h,y=g+h;d.push(...oc(n.slice(g,y),u,t,c,r,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;d.push(...oc(n.slice(g,y),u,t,c,r,m===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function Ca(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class St{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=X(e),s!=null){const r=s.length;C(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||pt(t,this.size),this.strides=we(e)}set(e,...t){t.length===0&&(t=[0]),C(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ss().makeTensor(this.values,this.shape,this.dtype)}}let ss=null,Oo=null;function RC(n){ss=n}function DC(n){Oo=n}class ze{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=X(e),this.strides=we(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Oo.buffer(this.shape,this.dtype,e)}bufferSync(){return Oo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Bn(this.shape,e,this.dtype==="complex64")}arraySync(){return Bn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ss().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Ws(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ss().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ss().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ws(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ss().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ss().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Oo.print(this,e)}clone(){return this.throwIfDisposed(),Oo.clone(this)}toString(e=!1){const t=this.dataSync();return EC(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Oo.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),ss().makeVariable(this,e,t,s)}}Object.defineProperty(ze,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Z(){return Wf("Tensor",()=>ze)}Z();class Va extends ze{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!_e(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ss().disposeTensor(this),this.dataId=e.dataId,ss().incRef(this,null)}dispose(){ss().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Va,Symbol.hasInstance,{value:n=>n instanceof ze&&n.assign!=null&&n.assign instanceof Function});var Wp;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Wp||(Wp={}));var Up;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Up||(Up={}));var Gp;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Gp||(Gp={}));var Hp;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Hp||(Hp={}));var jp;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(jp||(jp={}));const FC={float32:Hp,int32:Up,bool:Gp,complex64:jp};function pn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return FC[n][e]}function id(n){return pn(n,"int32")}function rw(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function ow(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function ht(n,e){if(n.dtype===e.dtype)return[n,e];const t=pn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function iw(n,e){C(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function ad(n,e){return e.some(t=>t.id===n.id)}function Us(n){const e=[];return aw(n,e,new Set),e}function aw(n,e,t){if(n==null)return;if(n instanceof ze){e.push(n);return}if(!_C(n))return;const s=n;for(const r in s){const o=s[r];t.has(o)||(t.add(o),aw(o,e,t))}}function _C(n){return Array.isArray(n)||typeof n=="object"}const OC=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:iw,getTensorsInContainer:Us,isTensorInList:ad,makeTypesMatch:ht},Symbol.toStringTag,{value:"Module"}));function Sp(n){return n.kernelName!=null}class Xb{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Wo{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Xb}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Fn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new SC(this.backendInstance),!0}setupRegisteredKernels(){kc(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){kc(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Jc)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Fn(`Initialization of backend ${e} failed`),Fn(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Fn(`Initialization of backend ${e} failed`),Fn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,o=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,o,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Wo.nextTensorId++}nextVariableId(){return Wo.nextVariableId++}clone(e){const t=O.runKernel(vi,{x:e}),s={x:e},r=i=>({x:()=>{const a="float32",l={x:i},u={dtype:a};return O.runKernel(li,l,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,o,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Ma(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=Sp(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Sp(e)){const{kernelName:f,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=Ma(f,this.backendName);C(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const v=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,v);const x=v.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(r){const S=this.getTensorsForGradient(f,m,x);s=this.saveTensorsForBackwardMode(S)}return x}}else{const{forwardFunc:f}=e,m=g=>{r&&(s=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}const{inputs:c,attrs:h}=e,d=Sp(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(u,c,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Mp(e);if(r!=null){const o=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(C(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=o.map(u=>t[u]);const l=s.filter((u,c)=>i[c]);return a.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&vs(e[0])&&(o=e.map(l=>$s(l)));const i=r.write(o,t,s),a=new ze(t,s,i,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(i),u=V0(o);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const o={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:o}=e,i=new ze(r,o,s,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new Va(e,t,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Oa(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Va||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Oa(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:o},l=Mp(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=s[h],p=jt(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),r(u.length>1?u:u[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Us(e),s=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,t,s,r=!1){if(C(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));C(o instanceof ze,()=>"The result y returned by f() must be a tensor.");const i=kC(this.state.activeTape,t,o);if(!r&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=s??LC(o.shape),TC(a,i,u=>this.tidy(u),PC);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return C(gr(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{C(t.every(a=>a instanceof ze),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,l)=>{r[l]=a});const o=(a,l)=>(s=e(...t,l),C(s.value instanceof ze,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),C(gr(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(a,l)=>{const u=s.gradFunc(a,l),c=Array.isArray(u)?u:[u];C(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),C(c.every(d=>d instanceof ze),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Vt(),s=await this.backend.time(e);return s.wallMs=Vt()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Xb;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Wo.nextTensorId=0;Wo.nextVariableId=0;function LC(n){const e=Qc(X(n),"float32");return O.makeTensor(e,n,"float32")}function lw(){const n=j0();if(n._tfengine==null){const e=new H0(n);n._tfengine=new Wo(e)}return oC(n._tfengine.ENV),RC(()=>n._tfengine),n._tfengine}const O=lw();function PC(n,e){const t={a:n,b:e};return O.runKernel(vo,t)}function zC(){return typeof navigator<"u"&&navigator!=null}let qp;function BC(n){qp=n}function Gf(n){if(qp!==void 0)return qp;if(n||zC()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Hf(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const MC=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:Hf,isMobile:Gf,mockIsMobile:BC},Symbol.toStringTag,{value:"Module"}));const fn=H();fn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});fn.registerFlag("IS_BROWSER",()=>Hf());fn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");fn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));fn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));fn.registerFlag("PROD",()=>!1);fn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>fn.getBool("DEBUG"));fn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);fn.registerFlag("IS_TEST",()=>!1);fn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>fn.getBool("DEBUG"));fn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);fn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);fn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Es(n,e){let t=n;if(Ct(n))return e==="string"?[]:[n.length];if(rw(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(ow(n))return[n.buffer.size/(e==null?4:Oa(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Ct(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&H().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&uw(n,s,[]),s}function uw(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ct(n)){C(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}C(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),C(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)uw(n[r],s,t.concat(r))}function Yb(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function T(n,e,t,s="numeric"){if(n instanceof Z())return Yb(s,n.dtype,e,t),n;let r=xo(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),Yb(s,r,e,t),n==null||!Ct(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const o=Es(n,r);!Ct(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?Cr(n,r):Ts(n,[],!0);return O.makeTensor(a,o,r)}function Wa(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>T(o,`${e}[${i}]`,t,s))}const jf="__op";function L(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+jf;const r=(...o)=>{O.startScope(t);try{const i=s(...o);return Vs(i)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(i),i}catch(i){throw O.endScope(null),i}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function VC(n,e){const t=T(n,"real","complex"),s=T(e,"imag","complex");qt(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return O.runKernel(ih,r)}const Gs=L({complex_:VC});function kr(n,e,t,s){if(s==null)s=xo(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ow(n)||rw(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return O.backend.createTensorFromGPUData(n,e||t,s)}if(!Ct(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){En(e);const r=X(e),o=X(t);C(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let i=0;i<t.length;++i){const a=t[i],l=i===t.length-1?a!==X(e.slice(i)):!0;C(t[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ct(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Cr(n,s):Ts(n,[],!0),O.makeTensor(n,e,s)}function Sn(n,e,t){const s=Es(n,t);return kr(n,e,s,t)}const eo={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ps{static join(e){return new ps(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Ct(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+r.byteLength;this.shards.push({buffer:r,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,o=new ArrayBuffer(r),i=new Uint8Array(o);let a=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],h=e+a-u.start,d=a,f=Math.min(t,u.end)-u.start,m=new Uint8Array(u.buffer,h,f-h);if(i.set(m,d),a+=m.length,t<u.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=WC(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function WC(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,o=e(n[r]);if(o===0)return r;o<0?s=r:t=r+1}return-1}function UC(){H().set("PROD",!0)}function GC(){H().set("DEBUG",!0)}function HC(){H().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function jC(n){H().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function qC(){O.disposeVariables()}function ns(){return O}function Kp(){return O.memory()}function KC(n){return O.profile(n)}function U(n,e){return O.tidy(n,e)}function Se(n){Us(n).forEach(t=>t.dispose())}function kt(n){return O.keep(n)}function XC(n){return O.time(n)}function YC(n){return O.setBackend(n)}function JC(){return O.ready()}function cw(){return O.backendName}function ZC(n){O.removeBackend(n)}function QC(n){return O.findBackend(n)}function ek(n){return O.findBackendFactory(n)}function qf(n,e,t=1){return O.registerBackend(n,e,t)}function Kf(){return O.backend}function tk(n,e){H().setPlatform(n,e)}const yr=4;async function Xp(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<r.length;++i){const a=r[i],l=Array.isArray(n)?n[i].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((g,y)=>g+y.length,0)+yr*d.length,f=new Uint8Array(p);let m=0;for(let g=0;g<d.length;g++){const y=d[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=yr,f.set(y,m),m+=y.length}h(f)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),t.push(u)}const o=await Promise.all(s);return{data:rk(o),specs:t}}function Xf(n,e){const t=new ps(n),s={};let r=0;for(const o of e){const i=nk(o,(a,l)=>t.slice(r+a,r+l));s[o.name]=hw(o,t.slice(r,r+i)),r+=i}return s}function nk(n,e){const t=X(n.shape);let s;if("quantization"in n){const r=n.quantization;s=eo[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=yr+new Uint32Array(e(r,r+yr))[0];return r}else s=eo[n.dtype];return t*s}async function sk(n,e){const t=X(n.shape);let s;if("quantization"in n){const r=n.quantization;s=eo[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=yr+new Uint32Array(await e(r,r+yr))[0];return r}else s=eo[n.dtype];return t*s}function hw(n,e){const t=n.name,s=n.dtype,r=n.shape,o=X(r);let i,a=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=eo[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=d*l.scale+l.min}}else if(l.dtype==="float16")i=ck()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=o*u}else if(s==="string"){const l=X(n.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(a,a+yr))[0];a+=yr;const h=new Uint8Array(e.slice(a,a+c));i.push(h),a+=c}}else{const l=eo[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<u.length;f++)u[f]=i[f*2],c[f]=i[f*2+1];const h=Sn(u,r,"float32"),d=Sn(c,r,"float32"),p=Gs(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=o*l}return Sn(i,r,s)}async function Jb(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:o}=await n.read();if(r&&o==null){const a=t-s.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(s.length+o.byteLength);i.set(s,0),i.set(new Uint8Array(o),s.length),s=i}return s.buffer}async function dw(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const o of e){const i=await sk(o,async(u,c)=>(r=await Jb(s,r,c),r.slice(u,c)));r=await Jb(s,r,i);const a=r.slice(0,i);r=r.slice(i);const l=hw(o,a);if(t[o.name]=l,cw()==="webgpu"){const u=Kf();"uploadToGPU"in u&&X(l.shape)>=H().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}function rk(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Yf=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Zb(n){return Yf?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function ok(n){if(Yf)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function ik(n){if(Yf){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function pw(n){return ps.join(n)}function Qb(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function fw(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Jf(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function Zf(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),Jf(n,t,s)}function ou(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Zb(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Zb(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new ps(n.weightData).byteLength}}function Tc(n){const e=[];for(const t of n)e.push(...t.weights);return e}function ak(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function lk(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function uk(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function ck(){const n=ak(),e=lk(),t=uk();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let i=0;i<s.length;i++){const a=s[i],l=n[t[a>>10]+(a&1023)]+e[a>>10];o[i]=l}return new Float32Array(r)}}class lt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return lt.instance==null&&(lt.instance=new lt),lt.instance}static registerSaveRouter(e){lt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){lt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return lt.getHandlers(e,"save")}static getLoadHandlers(e,t){return lt.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?lt.getInstance().loadRouters:lt.getInstance().saveRouters).forEach(i=>{const a=i(e,s);a!==null&&r.push(a)}),r}}const hk=n=>lt.registerSaveRouter(n),dk=n=>lt.registerLoadRouter(n),mw=n=>lt.getSaveHandlers(n),gw=(n,e)=>lt.getLoadHandlers(n,e);const Yp="tensorflowjs",Jp=1,jr="models_store",ar="model_info_store";function yw(){if(!H().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Zp(n){const e=n.result;e.createObjectStore(jr,{keyPath:"modelPath"}),e.createObjectStore(ar,{keyPath:"modelPath"})}class to{constructor(e){if(this.indexedDB=yw(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const o=this.indexedDB.open(Yp,Jp);o.onupgradeneeded=()=>Zp(o),o.onsuccess=()=>{const i=o.result;if(t==null){const a=i.transaction(jr,"readonly"),u=a.objectStore(jr).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(i.close(),r(u.error)),a.oncomplete=()=>i.close()}else{t.weightData=ps.join(t.weightData);const a=ou(t),l=i.transaction(ar,"readwrite");let u=l.objectStore(ar),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let h;c.onsuccess=()=>{h=i.transaction(jr,"readwrite");const d=h.objectStore(jr);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(f){return r(f)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{u=l.objectStore(ar);const m=u.delete(this.modelPath);m.onsuccess=()=>(i.close(),r(p.error)),m.onerror=g=>(i.close(),r(p.error))}},c.onerror=d=>(i.close(),r(c.error)),l.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>r(o.error)})}}to.URL_SCHEME="indexeddb://";const bw=n=>H().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(to.URL_SCHEME)?pk(n.slice(to.URL_SCHEME.length)):null;lt.registerSaveRouter(bw);lt.registerLoadRouter(bw);function pk(n){return new to(n)}function fk(n){return n.startsWith(to.URL_SCHEME)?n.slice(to.URL_SCHEME.length):n}class mk{constructor(){this.indexedDB=yw()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Yp,Jp);s.onupgradeneeded=()=>Zp(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(ar,"readonly"),a=o.objectStore(ar).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),t(a.error)),o.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=fk(e),new Promise((t,s)=>{const r=this.indexedDB.open(Yp,Jp);r.onupgradeneeded=()=>Zp(r),r.onsuccess=()=>{const o=r.result,i=o.transaction(ar,"readwrite"),a=i.objectStore(ar),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=o.transaction(jr,"readwrite");const p=u.objectStore(jr).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};c.onsuccess=h,c.onerror=d=>(h(),o.close(),s(l.error))}},l.onerror=c=>(o.close(),s(l.error)),i.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}const Bs="/",Lo="tensorflowjs_models",xw="info",gk="model_topology",yk="weight_specs",bk="weight_data",xk="model_metadata";function ww(n){return{info:[Lo,n,xw].join(Bs),topology:[Lo,n,gk].join(Bs),weightSpecs:[Lo,n,yk].join(Bs),weightData:[Lo,n,bk].join(Bs),modelMetadata:[Lo,n,xk].join(Bs)}}function vw(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function wk(n){const e=n.split(Bs);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Bs)}function vk(n){return n.startsWith(no.URL_SCHEME)?n.slice(no.URL_SCHEME.length):n}class no{constructor(e){if(!H().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ww(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=ou(e),o=ps.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,ok(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw vw(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=ik(i),t}}no.URL_SCHEME="localstorage://";const Iw=n=>H().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(no.URL_SCHEME)?Ik(n.slice(no.URL_SCHEME.length)):null;lt.registerSaveRouter(Iw);lt.registerLoadRouter(Iw);function Ik(n){return new no(n)}class $k{constructor(){C(H().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),C(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Lo+Bs,s=Bs+xw;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(t)&&o.endsWith(s)){const i=wk(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=vk(e);const t=ww(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return vw(t),s}}const zo="://";class en{constructor(){this.managers={}}static getInstance(){return en.instance==null&&(en.instance=new en),en.instance}static registerManager(e,t){C(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(zo)&&(e=e.slice(0,e.indexOf(zo))),C(e.length>0,()=>"scheme must not be an empty string.");const s=en.getInstance();C(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=en.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(en.getInstance().managers)}}function ic(n){if(n.indexOf(zo)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${en.getSchemes().join(",")}`);return{scheme:n.split(zo)[0],path:n.split(zo)[1]}}async function $w(n,e,t=!1){C(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=lt.getLoadHandlers(n);C(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),C(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],o=lt.getSaveHandlers(e);C(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),C(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=o[0],a=ic(n).scheme,l=ic(n).path,u=a===ic(n).scheme,c=await r.load();t&&u&&await en.getManager(a).removeModel(l);const h=await i.save(c);return t&&!u&&await en.getManager(a).removeModel(l),h.modelArtifactsInfo}async function Sk(){const n=en.getSchemes(),e={};for(const t of n){const s=await en.getManager(t).listModels();for(const r in s){const o=t+zo+r;e[o]=s[r]}}return e}async function Nk(n){const e=ic(n);return en.getManager(e.scheme).removeModel(e.path)}async function Ck(n,e){return $w(n,e,!1)}async function kk(n,e){return $w(n,e,!0)}class Tk{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!H().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Y0(e)}}if(H().get("IS_BROWSER")){H().setPlatform("browser",new Tk);try{en.registerManager(no.URL_SCHEME,new $k)}catch{}try{en.registerManager(to.URL_SCHEME,new mk)}catch{}}const Ek={importFetch:()=>require("node-fetch")};let Np;class Ak{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return H().global.fetch!=null?H().global.fetch(e,t):(Np==null&&(Np=Ek.importFetch()),Np(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}H().get("IS_NODE")&&!H().get("IS_BROWSER")&&H().setPlatform("node",new Ak);function Ee(n,e="float32",t){return e=e||"float32",En(n),new St(n,e,t)}function Rk(n,e){const t=T(n,"x","cast");if(!M0(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return O.runKernel(li,s,r)}const le=L({cast_:Rk});function Dk(n){const t={x:T(n,"x","clone","string_or_numeric")};return O.runKernel(vi,t)}const Ss=L({clone_:Dk});function Qf(n,e=!1){console.log(n.toString(e))}lw();const Fk={buffer:Ee,cast:le,clone:Ss,print:Qf};DC(Fk);function _k(n,e){let t=T(n,"a","add"),s=T(e,"b","add");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(vo,r)}const re=L({add_:_k});function Ok(n,e){let t=T(n,"a","floorDiv"),s=T(e,"b","floorDiv");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(xi,r)}const ld=L({floorDiv_:Ok});function Lk(n,e){let t=T(n,"a","div"),s=T(e,"b","div");if([t,s]=ht(t,s),t.dtype==="int32"&&s.dtype==="int32")return ld(t,s);const r={a:t,b:s},o={};return O.runKernel(pi,r,o)}const ge=L({div_:Lk});function Pk(n,e){let t=T(n,"a","mul"),s=T(e,"b","mul");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(Ai,r)}const P=L({mul_:Pk});function zk(n){const e=T(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return O.runKernel(cl,t)}else{const t={x:e};return O.runKernel(tl,t)}}const It=L({abs_:zk});function Bk(n){const t={x:T(n,"x","acos")};return O.runKernel(ti,t)}const em=L({acos_:Bk});function Mk(n){const t={x:T(n,"x","acosh")};return O.runKernel(ni,t)}const tm=L({acosh_:Mk});function Vk(n){C(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),C(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,o)=>T(r,`tensors${o}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!_e(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return O.runKernel(nl,s)}const Sw=L({addN_:Vk});function Wk(n,e=null,t=!1){const r={x:T(n,"x","all","bool")},o={axis:e,keepDims:t};return O.runKernel(eh,r,o)}const ud=L({all_:Wk});function Uk(n,e=null,t=!1){const r={x:T(n,"x","any","bool")},o={axis:e,keepDims:t};return O.runKernel(th,r,o)}const Ua=L({any_:Uk});function Gk(n,e=0){const s={x:T(n,"x","argMax")},r={axis:e};return O.runKernel(sl,s,r)}const so=L({argMax_:Gk});function Hk(n,e=0){const s={x:T(n,"x","argMin")},r={axis:e};return O.runKernel(rl,s,r)}const nm=L({argMin_:Hk});function jk(n){const t={x:T(n,"x","asin")};return O.runKernel(si,t)}const sm=L({asin_:jk});function qk(n){const t={x:T(n,"x","asinh")};return O.runKernel(ri,t)}const rm=L({asinh_:qk});function Kk(n){const t={x:T(n,"x","atan")};return O.runKernel(oi,t)}const om=L({atan_:Kk});function Xk(n,e){let t=T(n,"a","atan2"),s=T(e,"b","atan2");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(ai,r)}const im=L({atan2_:Xk});function Yk(n){const t={x:T(n,"x","atanh")};return O.runKernel(ii,t)}const am=L({atanh_:Yk});function iu(n,e,t,s,r="NHWC",o){const i=n[3],a=[...e,i],l=Qs(r);return zt(n,a,t,o,s,null,null,l)}function Xn(n,e,t,s,r,o,i="channelsLast"){const[a,l]=Ga(e);let u;if(i==="channelsLast")u=[a,l,n[3],n[3]];else if(i==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return zt(n,u,t,s,r,o,!1,i)}function Zs(n,e,t,s,r,o,i="NDHWC"){const[a,l,u]=Qp(e);let c,h;if(i==="NDHWC")h="channelsLast",c=[a,l,u,n[4],n[4]];else if(i==="NCDHW")h="channelsFirst",c=[a,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Tr(n,c,t,s,r,!1,h,o)}function zt(n,e,t,s,r,o,i=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=n;else if(a==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=e,[m,g]=Ga(t),[y,b]=Ga(s),v=Bo(d,y),x=Bo(p,b),{padInfo:S,outHeight:k,outWidth:D}=Qk(r,u,c,m,g,v,x,o,a),F=i?f*h:f;let A;return a==="channelsFirst"?A=[l,F,k,D]:a==="channelsLast"&&(A=[l,k,D,F]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:k,outWidth:D,outChannels:F,padInfo:S,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:n,outShape:A,filterShape:e}}function Tr(n,e,t,s,r,o=!1,i="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,h,d]=n;else if(i==="channelsFirst")[l,d,u,c,h]=n;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,m,,g]=e,[y,b,v]=Qp(t),[x,S,k]=Qp(s),D=Bo(p,x),F=Bo(f,S),A=Bo(m,k),{padInfo:R,outDepth:N,outHeight:z,outWidth:V}=eT(r,u,c,h,y,b,v,D,F,A,a),j=o?g*d:g;let G;return i==="channelsFirst"?G=[l,j,N,z,V]:i==="channelsLast"&&(G=[l,N,z,V,j]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:N,outHeight:z,outWidth:V,outChannels:j,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:D,effectiveFilterHeight:F,effectiveFilterWidth:A,dilationDepth:x,dilationHeight:S,dilationWidth:k,inShape:n,outShape:G,filterShape:e}}function Jk(n,e,t,s,r){s==null&&(s=lm(n,e,t));const o=n[0],i=n[1],a=Ha((o-e+2*s)/t+1,r),l=Ha((i-e+2*s)/t+1,r);return[a,l]}function Zk(n,e,t,s,r,o){r==null&&(r=lm(n,e[0],s[0]));const i=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(i[a]=Ha((n[a]-e[a]+2*r)/s[a]+1,o));return i}function lm(n,e,t,s=1){const r=Bo(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function Ga(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Qp(n){return typeof n=="number"?[n,n,n]:n}function Bo(n,e){return e<=1?n:n+(n-1)*(e-1)}function Qk(n,e,t,s,r,o,i,a,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=Jk([e,t],o,s,n,a);c=p[0],h=p[1]}else if(n==="same"){c=Math.ceil(e/s),h=Math.ceil(t/r);const d=Math.max(0,(c-1)*s+o-e),p=Math.max(0,(h-1)*r+i-t),f=Math.floor(d/2),m=d-f,g=Math.floor(p/2),y=p-g;u={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),h=Math.ceil((t-i+1)/r);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=Ha((e-o+d+p)/s+1,a),h=Ha((t-i+f+m)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function eT(n,e,t,s,r,o,i,a,l,u,c){let h,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=Zk([e,t,s,1],[a,l,u],1,[r,o,i],n,c);d=g[0],p=g[1],f=g[2]}else if(n==="same"){d=Math.ceil(e/r),p=Math.ceil(t/o),f=Math.ceil(s/i);const m=(d-1)*r+a-e,g=(p-1)*o+l-t,y=(f-1)*i+u-s,b=Math.floor(m/2),v=m-b,x=Math.floor(g/2),S=g-x,k=Math.floor(y/2),D=y-k;h={top:x,bottom:S,left:k,right:D,front:b,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Ha(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function br(n){const[e,t,s]=Ga(n);return e===1&&t===1&&s===1}function Kt(n,e){return br(n)||br(e)}function ro(n){return Ga(n).every(e=>e>0)}function Qs(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function an(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")C(Qr(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{C(Qr(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function tT(n,e){const s={x:T(n,"x","reshape","string_or_numeric")},r={shape:e};return O.runKernel(Gl,s,r)}const B=L({reshape_:tT});function nT(n,e,t,s,r){const o=T(n,"x","avgPool","float32"),i=1;C(Kt(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=o,l=!1;o.rank===3&&(l=!0,a=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),an("avgPool",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let h=O.runKernel(ol,u,c);return h=le(h,o.dtype),l?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const au=L({avgPool_:nT});function sT(n,e,t,s,r,o="NDHWC"){const i=T(n,"x","avgPool3d","float32");let a=i,l=!1;i.rank===4&&(l=!0,a=B(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),C(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),C(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),C(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),an("avgPool3d",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o};let h=O.runKernel(il,u,c);return h=le(h,a.dtype),l?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const um=L({avgPool3d_:sT});function rT(n,e=0){C(n.length>=1,()=>"Pass at least one tensor to concat");const t=Wa(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return Ss(t[0]);const s=t,r={axis:e};return O.runKernel(hl,s,r)}const gt=L({concat_:rT});function oT(n,e,t=!1,s=!1){let r=T(n,"a","matMul"),o=T(e,"b","matMul");[r,o]=ht(r,o);const i={a:r,b:o},a={transposeA:t,transposeB:s};return O.runKernel(al,i,a)}const Ae=L({matMul_:oT});function iT(n){const t={x:T(n,"x","sigmoid","float32")};return O.runKernel(Vi,t)}const is=L({sigmoid_:iT});function aT(n,e,t){const s=T(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:t};return O.runKernel(Xl,r,o)}const Le=L({slice_:aT});function lT(n){const t={x:T(n,"x","tanh","float32")};return O.runKernel(qi,t)}const xr=L({tanh_:lT});function uT(n,e,t,s,r,o){const i=T(n,"forgetBias","basicLSTMCell"),a=T(e,"lstmKernel","basicLSTMCell"),l=T(t,"lstmBias","basicLSTMCell"),u=T(s,"data","basicLSTMCell"),c=T(r,"c","basicLSTMCell"),h=T(o,"h","basicLSTMCell"),d=gt([u,h],1),p=Ae(d,a),f=re(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Le(f,[0,0],y),v=Le(f,[0,g],y),x=Le(f,[0,g*2],y),S=Le(f,[0,g*3],y),k=re(P(is(b),xr(v)),P(c,is(re(i,x)))),D=P(xr(k),is(S));return[k,D]}const Nw=L({basicLSTMCell_:uT});function cT(n,e,t){const s=T(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);C(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),C(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),C(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},i={blockShape:e,crops:t};return O.runKernel(ll,o,i)}const lu=L({batchToSpaceND_:cT});function hT(n){let e;return n.rank===0||n.rank===1?e=B(n,[1,1,1,n.size]):n.rank===2?e=B(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=B(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function dT(n,e,t,s,r,o){o==null&&(o=.001);const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),l=T(t,"variance","batchNorm");let u;r!=null&&(u=T(r,"scale","batchNorm"));let c;s!=null&&(c=T(s,"offset","batchNorm")),C(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:hT(i),scale:u,offset:c,mean:a,variance:l},p={varianceEpsilon:o},f=O.runKernel(wl,d,p);return B(f,i.shape)}const Yi=L({batchNorm_:dT});function pT(n,e,t,s,r,o){const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),l=T(t,"variance","batchNorm");let u;r!=null&&(u=T(r,"scale","batchNorm"));let c;return s!=null&&(c=T(s,"offset","batchNorm")),C(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),C(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),C(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&C(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&C(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Yi(i,a,l,c,u,o)}const cm=L({batchNorm2d_:pT});function fT(n,e,t,s,r,o){const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),l=T(t,"variance","batchNorm");let u;r!=null&&(u=T(r,"scale","batchNorm"));let c;return s!=null&&(c=T(s,"offset","batchNorm")),C(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),C(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),C(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&C(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&C(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Yi(i,a,l,c,u,o)}const hm=L({batchNorm3d_:fT});function mT(n,e,t,s,r,o){const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),l=T(t,"variance","batchNorm");let u;r!=null&&(u=T(r,"scale","batchNorm"));let c;return s!=null&&(c=T(s,"offset","batchNorm")),C(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),C(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),C(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&C(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&C(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Yi(i,a,l,c,u,o)}const dm=L({batchNorm4d_:mT});function gT(n,e,t){const s=T(n,"x","bincount"),r=T(e,"weights","bincount");C(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),C(t>=0,()=>`size must be non-negative, but got ${t}.`),C(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},i={size:t};return O.runKernel(rh,o,i)}const pm=L({bincount_:gT});function yT(n,e){const t=T(n,"x","bitwiseAnd"),s=T(e,"y","bitwiseAnd");if(!_e(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return O.runKernel(ul,r)}const Cw=L({bitwiseAnd_:yT});function bT(n,e){const t=T(n,"s0","broadcastArgs","int32"),s=T(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return O.runKernel(oh,r)}const kw=L({broadcastArgs_:bT});function xT(n,e){let t=T(n,"broadcastTo","x");const s=t.shape;if(En(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=B(t,u)}const r=t.shape,o=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])o[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Ss(t);const a={x:t},l={reps:o};return O.runKernel(Ki,a,l)}const Yr=L({broadcastTo_:xT});function wT(n){const t={x:T(n,"x","ceil","float32")};return O.runKernel(ui,t)}const fm=L({ceil_:wT});function Io(n,e,t){En(n),t=t||xo(e);const s={shape:n,value:e,dtype:t};return O.runKernel(vh,{},s)}function vT(n,e,t){const s=T(n,"x","clipByValue");if(C(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Io(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:t};return O.runKernel(ci,r,o)}const mn=L({clipByValue_:vT});function IT(n){return gt(n,0)}const mm=L({concat1d_:IT});function $T(n,e){return gt(n,e)}const gm=L({concat2d_:$T});function ST(n,e){return gt(n,e)}const ym=L({concat3d_:ST});function NT(n,e){return gt(n,e)}const bm=L({concat4d_:NT});function CT(n,e,t,s,r="NHWC",o=[1,1],i){const a=T(n,"x","conv2d","float32"),l=T(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),C(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),an("conv2d",s,i);const h=r==="NHWC"?u.shape[3]:u.shape[1];C(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),C(Kt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),C(ro(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),C(ro(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},f=O.runKernel(dl,d,p);return c?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Hs=L({conv2d_:CT});function kT(n,e,t,s,r="NWC",o=1,i){const a=T(n,"x","conv1d"),l=T(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=B(a,[1,a.shape[0],a.shape[1]])),C(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),C(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),an("conv1d",s,i),C(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),C(Kt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),C(ro(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),C(ro(t),()=>"Error in conv1D: Stride should be larger than 0."),C(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=B(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=B(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Hs(d,h,[1,t],s,"NHWC",[1,o],i);return c?B(g,[g.shape[2],g.shape[3]]):B(g,[g.shape[0],g.shape[2],g.shape[3]])}const cd=L({conv1d_:kT});function TT(n,e,t,s,r,o="NHWC",i){C(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,u=!1;e.rank===3&&(u=!0,l=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),C(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),C(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),C(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?a[3]:a[1],h=o==="NHWC"?l.shape[3]:l.shape[1];C(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),C(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),an("conv2dDerInput",r,i);const d={dy:l,filter:t},p={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,inputShape:a},f=O.runKernel(pl,d,p);return u?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const xm=L({conv2DBackpropInput_:TT});function ET(n,e,t,s,r,o){const i=T(n,"x","conv2dTranspose"),a=T(e,"filter","conv2dTranspose");return xm(t,i,a,s,r,"NHWC",o)}const hd=L({conv2dTranspose_:ET});function AT(n,e,t,s,r="NDHWC",o=[1,1,1]){const i=T(n,"x","conv3d"),a=T(e,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=B(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),C(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),C(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),C(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),C(Kt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),C(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),C(ro(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),C(ro(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:s,dataFormat:r,dilations:o},d=O.runKernel(fl,c,h);return u?B(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const wm=L({conv3d_:AT});function RT(n,e,t,s,r){C(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,i=e,a=!1;e.rank===4&&(a=!0,i=B(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const l=o[4],u=i.shape[4];C(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),C(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),C(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),C(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),C(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:i,filter:t},h={pad:r,strides:s,inputShape:o},d=O.runKernel(uh,c,h);return a?B(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Tw=L({conv3DBackpropInput_:RT});function DT(n,e,t,s,r){const o=T(n,"x","conv3dTranspose"),i=T(e,"filter","conv3dTranspose");return Tw(t,o,i,s,r)}const vm=L({conv3dTranspose_:DT});function FT(n){const t={x:T(n,"x","cos","float32")};return O.runKernel(hi,t)}const uu=L({cos_:FT});function _T(n){const t={x:T(n,"x","cosh","float32")};return O.runKernel(di,t)}const dd=L({cosh_:_T});function OT(n,e=0,t=!1,s=!1){const o={x:T(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:s};return O.runKernel(ch,o,i)}const ja=L({cumprod_:OT});function LT(n,e=0,t=!1,s=!1){const o={x:T(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:s};return O.runKernel(ml,o,i)}const pd=L({cumsum_:LT});function PT(n,e,t,s=!1){const r=T(n,"x","denseBincount"),o=T(e,"weights","denseBincount");C(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),C(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),C(t>=0,()=>`size must be non-negative, but got ${t}.`),C(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const i={x:r,weights:o},a={size:t,binaryOutput:s};return O.runKernel(dh,i,a)}const Ec=L({denseBincount_:PT});function zT(n,e,t="NHWC"){const s=T(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],o=t==="NHWC"?s.shape[2]:s.shape[3],i=t==="NHWC"?s.shape[3]:s.shape[1];C(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),C(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),C(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),C(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return O.runKernel(ph,a,l)}const Im=L({depthToSpace_:zT});function BT(n,e,t,s,r="NHWC",o=[1,1],i){const a=T(n,"x","depthwiseConv2d","float32"),l=T(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),C(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];C(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),an("depthwiseConv2d",s,i);const d={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},f=O.runKernel(gl,d,p);return c?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ji=L({depthwiseConv2d_:BT});function MT(n){const t={x:T(n,"x","diag")};return O.runKernel(gh,t)}const Ew=L({diag_:MT});function VT(n,e,t,s,r=[1,1],o="NHWC"){const i=T(n,"x","dilation2d"),a=T(e,"filter","dilation2d");C(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),C(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),C(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;i.rank===3&&(l=B(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),C(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:s,dilations:r},d=O.runKernel(yl,c,h);return u?B(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const $m=L({dilation2d_:VT});function oo(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const o=t-1-r,i=n[o]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(o)}return s}function Nt(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],o=e.length-s-1,i=e[o];(r==null||r===1&&i>1)&&t.unshift(o)}return t}function Ne(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let o=n[n.length-r-1];o==null&&(o=1);let i=e[e.length-r-1];if(i==null&&(i=1),o===1)s[t-r-1]=i;else if(i===1)s[t-r-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-r-1]=o}return s}const WT=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Ne,getBroadcastDims:oo,getReductionAxes:Nt},Symbol.toStringTag,{value:"Module"}));function UT(n,e){let t=T(n,"a","equal","string_or_numeric"),s=T(e,"b","equal","string_or_numeric");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(bl,r)}const Nn=L({equal_:UT});function GT(n,e,t){const s=T(e,"a","where"),r=T(t,"b","where"),o=T(n,"condition","where","bool"),i=Ne(Ne(o.shape,s.shape),r.shape),a=Yr(o,i),l=Yr(s,i),u=Yr(r,i),c={condition:a,t:l,e:u};return O.runKernel(Kl,c)}const _t=L({where_:GT});function HT(n){const t={x:T(n,"x","zerosLike")};return O.runKernel(su,t)}const Pe=L({zerosLike_:HT});function jT(n,e){let t=T(n,"a","div"),s=T(e,"b","div");[t,s]=ht(t,s);const r=ge(t,s),o=Pe(r),i=Nn(s,o);return _t(i,o,r)}const Sm=L({divNoNan_:jT});function qT(n,e){const t=T(n,"t1","dot"),s=T(e,"t2","dot");C((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],o=s.rank===1?s.size:s.shape[0];if(C(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),t.rank===1&&s.rank===1){const i=B(t,[1,-1]),a=B(s,[-1,1]),l=Ae(i,a);return B(l,[])}else if(t.rank===1&&s.rank===2){const i=B(t,[1,-1]),a=B(s,[s.shape[0],s.shape[1]]),l=Ae(i,a);return B(l,[l.size])}else if(t.rank===2&&s.rank===1){const i=B(s,[-1,1]),a=Ae(t,i);return B(a,[a.size])}else{const i=B(s,[s.shape[0],s.shape[1]]);return Ae(t,i)}}const Nm=L({dot_:qT});function KT(n,...e){const t=e.map((r,o)=>T(r,`tensors${o}`,"einsum")),s={equation:n};return O.runKernel(bh,t,s)}const Wr=L({einsum_:KT});function XT(n){const t={x:T(n,"x","elu","float32")};return O.runKernel(fi,t)}const Zi=L({elu_:XT});function YT(n,e){const t=T(n,"x","ensureShape","string_or_numeric");if(!z0(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const Aw=L({ensureShape_:YT});function JT(n){let e=T(n,"x","erf");C(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=le(e,"float32"));const t={x:e};return O.runKernel(mi,t)}const fd=L({erf_:JT});function Cm(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Rw(n,e,t){const s=n.length+e.length,r=[];let o=0,i=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[o++]):r.push(e[i++]);return r}function Bt(n,e){const t=[],s=n.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&t.push(n[o]);const r=e.map(o=>n[o]);return[t,r]}function yt(n,e){const t=e.map(s=>1);return Rw(n,t,e)}function Xt(n,e,t){C(Cm(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function dt(n,e){if(Cm(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Er(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function bt(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function ZT(n,e=null,t=!1){const r={x:T(n,"x","max")},o={reductionIndices:e,keepDims:t};return O.runKernel(Al,r,o)}const Mn=L({max_:ZT});function QT(n,e=null,t=!1){const r={x:T(n,"x","min")},o={axis:e,keepDims:t};return O.runKernel(_l,r,o)}const Uo=L({min_:QT});function e2(n,e){let t=T(n,"base","pow"),s=T(e,"exp","pow");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(Ri,r)}const As=L({pow_:e2});function xe(n,e){if((Ct(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ct(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return kr(n,[],[],e)}function t2(n){const t={x:T(n,"x","sqrt","float32")};return O.runKernel(Ui,t)}const Lt=L({sqrt_:t2});function n2(n){const e=T(n,"x","square"),t={};return O.runKernel("Square",{x:e},t)}const Ke=L({square_:n2});function s2(n,e=null,t=!1){let s=T(n,"x","sum");s.dtype==="bool"&&(s=le(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return O.runKernel(Yl,r,o)}const fe=L({sum_:s2});function r2(n,e="euclidean",t=null,s=!1){n=T(n,"x","norm");const r=Dw(n,e,t);let o=r.shape;if(s){const i=Re(t,n.shape);o=yt(r.shape,i)}return B(r,o)}function Dw(n,e,t=null){if(n.rank===0)return It(n);if(n.rank!==1&&t===null)return Dw(B(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return fe(It(n),t);if(e===1/0)return Mn(It(n),t);if(e===-1/0)return Uo(It(n),t);if(e==="euclidean"||e===2)return Lt(fe(As(It(n),xe(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Mn(fe(It(n),t[0]),t[1]-1);if(e===1/0)return Mn(fe(It(n),t[1]),t[0]);if(e===-1/0)return Uo(fe(It(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Lt(fe(Ke(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Qi=L({norm_:r2});function o2(n,e=null,t=!1){return Qi(n,"euclidean",e,t)}const km=L({euclideanNorm_:o2});function i2(n){const t={x:T(n,"x","exp")};return O.runKernel(gi,t)}const gn=L({exp_:i2});function a2(n,e=0){const t=T(n,"x","expandDims","string_or_numeric");C(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return O.runKernel(xl,s,r)}const Wt=L({expandDims_:a2});function l2(n){const t={x:T(n,"x","expm1")};return O.runKernel(yi,t)}const Tm=L({expm1_:l2});function u2(n,e){const t=T(n,"x","tile","string_or_numeric");C(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return O.runKernel(Ki,s,r)}const On=L({tile_:u2});function c2(n,e,t,s="float32"){e==null&&(e=n);const r=Ee([n,e],s),o=n<=e?n:e;for(let a=0;a<o;++a)r.set(1,a,a);const i=B(r.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return On(Wt(i,0),[t[0],1,1]);if(t.length===2)return On(Wt(Wt(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return On(Wt(Wt(Wt(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const md=L({eye_:c2});function h2(n){const t={x:T(n,"x","floor","float32")};return O.runKernel(bi,t)}const ea=L({floor_:h2});function d2(n,e,t=0,s=0){const r=T(n,"x","gather"),o=T(e,"indices","gather","int32"),i={x:r,indices:o},a={axis:t,batchDims:s};return O.runKernel(vl,i,a)}const ta=L({gather_:d2});function p2(n,e){let t=T(n,"a","greater","string_or_numeric"),s=T(e,"b","greater","string_or_numeric");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Il,r)}const ln=L({greater_:p2});function f2(n,e){let t=T(n,"a","greaterEqual","string_or_numeric"),s=T(e,"b","greaterEqual","string_or_numeric");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(wi,r)}const er=L({greaterEqual_:f2});function m2(n){const t={input:T(n,"input","imag")};return O.runKernel(Nh,t)}const cu=L({imag_:m2});function g2(n){const t={x:T(n,"x","isFinite")};return O.runKernel(Ii,t)}const Em=L({isFinite_:g2});function y2(n){const t={x:T(n,"x","isInf")};return O.runKernel($i,t)}const Am=L({isInf_:y2});function b2(n){const t={x:T(n,"x","isNaN")};return O.runKernel(Si,t)}const Rm=L({isNaN_:b2});function x2(n,e=.2){const s={x:T(n,"x","leakyRelu")},r={alpha:e};return O.runKernel($l,s,r)}const hu=L({leakyRelu_:x2});function w2(n,e){let t=T(n,"a","less","string_or_numeric"),s=T(e,"b","less","string_or_numeric");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Sl,r)}const Go=L({less_:w2});function v2(n,e){let t=T(n,"a","lessEqual","string_or_numeric"),s=T(e,"b","lessEqual","string_or_numeric");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Nl,r)}const Ar=L({lessEqual_:v2});function Fw(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return O.runKernel(Ch,{},s)}function I2(n,e=5,t=1,s=1,r=.5){const o=T(n,"x","localResponseNormalization");C(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),C(Qr(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=B(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:i},u={depthRadius:e,bias:t,alpha:s,beta:r},c=O.runKernel(El,l,u);return a?B(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Dm=L({localResponseNormalization_:I2});function $2(n){const t={x:T(n,"x","log","float32")};return O.runKernel(Ni,t)}const Cn=L({log_:$2});function S2(n){const t={x:T(n,"x","log1p")};return O.runKernel(Ci,t)}const du=L({log1p_:S2});function N2(n){return C(gr(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=T(e,"x","tf.grad","string_or_numeric"),r=t!=null?T(t,"dy","tf.grad"):null;return O.tidy(()=>{const{value:o,grads:i}=O.gradients(()=>n(s),[s],r);return r!=null&&qt(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),gd(i),i[0]})}}function C2(n){return C(gr(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{C(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=Wa(e,"args","tf.grads","string_or_numeric"),r=t!=null?T(t,"dy","tf.grads"):null;return O.tidy(()=>{const{value:o,grads:i}=O.gradients(()=>n(...s),s,r);return r!=null&&qt(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),gd(i),i})}}function k2(n){return C(gr(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{C(e instanceof ze,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),C(t==null||t instanceof ze,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=O.gradients(()=>n(e),[e],t);return gd(s),{grad:s[0],value:r}}}function T2(n){return C(gr(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{C(Array.isArray(e)&&e.every(r=>r instanceof ze),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),C(t==null||t instanceof ze,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=O.gradients(()=>n(...e),e,t);return t!=null&&qt(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),gd(s.grads),s}}function _w(n,e){C(gr(n),()=>"The f passed in variableGrads(f) must be a function"),C(e==null||Array.isArray(e)&&e.every(u=>u instanceof Va),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in O.registeredVariables)e.push(O.registeredVariables[u])}const s=t?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),C(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:i,grads:a}=O.gradients(n,e,null,o);C(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),C(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),s?.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Rs(n){return O.customGrad(n)}function gd(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function E2(n){const t={x:T(n,"x","neg")};return O.runKernel(Ll,t)}const tt=L({neg_:E2});function A2(n){const t={x:T(n,"x","softplus")};return O.runKernel(Wi,t)}const $o=L({softplus_:A2});function R2(n){const e=T(n,"x","logSigmoid");return Rs(s=>({value:tt($o(tt(s))),gradFunc:i=>P(i,is(tt(s)))}))(e)}const Fm=L({logSigmoid_:R2});function D2(n,e){let t=T(n,"a","sub"),s=T(e,"b","sub");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(Hi,r)}const pe=L({sub_:D2});function F2(n,e=-1){const t=T(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Rs((r,o)=>{const a=Mn(r,e,!0),l=pe(r,a),u=pe(le(l,"float32"),Cn(fe(gn(l),e,!0)));return o([u]),{value:u,gradFunc:(h,d)=>{const[p]=d,f=!0,m=gn(p);return pe(h,P(fe(h,e,f),m))}}})(t)}const yd=L({logSoftmax_:F2});function _2(n,e=null,t=!1){const s=T(n,"x","logSumExp"),r=Re(e,s.shape),o=Mn(s,r,!0),i=pe(s,o),a=gn(i),l=fe(a,r),u=Cn(l),c=re(B(o,u.shape),u);if(t){const h=yt(c.shape,r);return B(c,h)}return c}const pu=L({logSumExp_:_2});function O2(n,e){const t=T(n,"a","logicalAnd","bool"),s=T(e,"b","logicalAnd","bool");Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Cl,r)}const Kn=L({logicalAnd_:O2});function L2(n){const t={x:T(n,"x","logicalNot","bool")};return O.runKernel(kl,t)}const fu=L({logicalNot_:L2});function P2(n,e){const t=T(n,"a","logicalOr","bool"),s=T(e,"b","logicalOr","bool");Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Tl,r)}const bd=L({logicalOr_:P2});function z2(n,e){const t=T(n,"a","logicalXor","bool"),s=T(e,"b","logicalXor","bool");return Ne(t.shape,s.shape),Kn(bd(n,e),fu(Kn(n,e)))}const _m=L({logicalXor_:z2});const Gu=2147483648;function B2(n,e,t="left"){const s=T(n,"sortedSequence","searchSorted"),r=T(e,"values","searchSorted"),o=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],a=B(s,[-1,o]),l=B(r,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(X(l.shape)>=Gu)throw new Error(`values tensor size must less than ${Gu}`);if(a.shape[1]>=Gu)throw new Error(`trailing dim_size must less than ${Gu} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:t};return O.runKernel(Gh,u,c)}const xd=L({searchSorted_:B2});function Ow(n,e){return xd(n,e,"left")}function M2(n,e,t,s,r){const o=T(n,"x","maxPool"),i=1;let a=o,l=!1;o.rank===3&&(l=!0,a=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),C(Kt(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),an("maxPool",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r},h=O.runKernel(Rl,u,c);return l?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const mu=L({maxPool_:M2});function V2(n,e=[1,1,1],t,s,r,o="NDHWC"){const i=T(n,"x","maxPool3d");let a=i,l=!1;i.rank===4&&(l=!0,a=B(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),C(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),C(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),an("maxPool3d",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o},h=O.runKernel(Dl,u,c);return l?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Om=L({maxPool3d_:V2});function W2(n,e,t,s,r=!1){const i={x:T(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=O.runKernel(Ah,i,a);return{result:l[0],indexes:l[1]}}const Lw=L({maxPoolWithArgmax_:W2});function U2(n,e){let t=T(n,"a","maximum"),s=T(e,"b","maximum");[t,s]=ht(t,s),t.dtype==="bool"&&(t=le(t,"int32"),s=le(s,"int32")),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(ki,r)}const Fs=L({maximum_:U2});function G2(n,e=null,t=!1){const r={x:T(n,"x","mean")},o={axis:e,keepDims:t};return O.runKernel(Fl,r,o)}const ut=L({mean_:G2});function mt(n,e="float32"){if(En(n),e==="complex64"){const s=mt(n,"float32"),r=mt(n,"float32");return Gs(s,r)}const t=jt(X(n),e);return O.makeTensor(t,n,e)}function hn(n,e="float32"){if(En(n),e==="complex64"){const s=hn(n,"float32"),r=mt(n,"float32");return Gs(s,r)}const t=Qc(X(n),e);return O.makeTensor(t,n,e)}function Pw(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=T(n,"x","meshgrid",n instanceof ze?n.dtype:"float32");if(e===void 0)return[s];let r=T(e,"y","meshgrid",e instanceof ze?e.dtype:"float32");const o=X(s.shape),i=X(r.shape);return t==="xy"?(s=B(s,[1,-1]),r=B(r,[-1,1]),[Ae(hn([i,1],s.dtype),s),Ae(r,hn([1,o],r.dtype))]):(s=B(s,[-1,1]),r=B(r,[1,-1]),[Ae(s,hn([1,i],s.dtype)),Ae(hn([o,1],r.dtype),r)])}function H2(n,e){let t=T(n,"a","minimum"),s=T(e,"b","minimum");[t,s]=ht(t,s),t.dtype==="bool"&&(t=le(t,"int32"),s=le(s,"int32")),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Ti,r)}const wr=L({minimum_:H2});function j2(n,e,t){C(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=T(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");C(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)C(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),C(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:t},i={x:s};return O.runKernel(Ol,i,o)}const Lm=L({mirrorPad_:j2});function q2(n,e){let t=T(n,"a","mod"),s=T(e,"b","mod");[t,s]=ht(t,s);const r={a:t,b:s};return O.runKernel(Ei,r)}const Pm=L({mod_:q2});function K2(n,e=null,t=!1){n=T(n,"x","moments");const s=Re(e,n.shape),r=ut(n,s,t);let o=r.shape;t||(o=yt(r.shape,s));const i=Ke(pe(le(n,"float32"),B(r,o))),a=ut(i,s,t);return{mean:r,variance:a}}const gu=L({moments_:K2});function X2(n,e,t,s){const r=T(e,"data","multiRNNCell"),o=Wa(t,"c","multiRNNCell"),i=Wa(s,"h","multiRNNCell");let a=r;const l=[];for(let h=0;h<n.length;h++){const d=n[h](a,o[h],i[h]);l.push(d[0]),l.push(d[1]),a=d[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const zw=L({multiRNNCell_:X2});function Y2(n,e,t,s=!1){const r=T(n,"logits","multinomial"),o=r.size,i=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const l={logits:i===1?B(r,[1,-1]):r},u={numSamples:e,seed:t,normalized:s},c=O.runKernel(Rh,l,u);return i===1?B(c,[c.size]):c}const Bw=L({multinomial_:Y2});function J2(n,e){let t=T(n,"a","notEqual","string_or_numeric"),s=T(e,"b","notEqual","string_or_numeric");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s};return O.runKernel(Pl,r)}const io=L({notEqual_:J2});function Z2(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:T(n,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:t,offValue:s};return O.runKernel(Bl,i,a)}const Ho=L({oneHot_:Z2});function Q2(n){const t={x:T(n,"x","onesLike")};return O.runKernel(zl,t)}const kn=L({onesLike_:Q2});function eE(n,e){const t=T(n,"v1","outerProduct"),s=T(e,"v2","outerProduct");C(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=B(t,[-1,1]),o=B(s,[1,-1]);return Ae(r,o)}const Mw=L({outerProduct_:eE});function tE(n,e,t=0){const s=T(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},o={x:s};return O.runKernel(Vl,o,r)}const tr=L({pad_:tE});function nE(n,e,t=0){return C(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),tr(n,[e],t)}const Vw=L({pad1d_:nE});function sE(n,e,t=0){return C(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),tr(n,e,t)}const Ww=L({pad2d_:sE});function rE(n,e,t=0){return C(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),tr(n,e,t)}const Uw=L({pad3d_:rE});function oE(n,e,t=0){return C(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),tr(n,e,t)}const Gw=L({pad4d_:oE});function iE(n,e,t){const s=T(n,"x","spaceToBatchND");C(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),C(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),C(s.shape.reduce((i,a,l)=>l>0&&l<=e.length?i&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:t};return O.runKernel(Jl,r,o)}const yu=L({spaceToBatchND_:iE});function aE(n,e,t,s,r,o,i){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const a=T(n,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(Kt(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=Xn(l.shape,e,o,r,s),h=[c.dilationHeight,c.dilationWidth];let d;s==="same"?d=uE([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,m]=lE([c.inHeight,c.inWidth],h,d),g=p?s:"valid",y=p?l:yu(l,h,f),v=(t==="avg"?()=>au(y,e,o,g,i):()=>mu(y,e,o,g,i))(),x=p?v:lu(v,h,m);return u?B(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function lE(n,e,t){const s=t.map(c=>c[0]),r=t.map(c=>c[1]),o=n.concat(s,r),i=e.map((c,h)=>(c-o[h]%c)%c),a=r.map((c,h)=>c+i[h]),l=e.map((c,h)=>[s[h],a[h]]),u=e.map((c,h)=>[0,i[h]]);return[l,u]}function uE(n,e){const s=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),o=s.map((i,a)=>i-r[a]);return s.map((i,a)=>[r[a],o[a]])}const zm=L({pool_:aE});function cE(n,e){const t=T(n,"x","prelu"),s=T(e,"alpha","prelu"),r={x:t,alpha:s};return O.runKernel(Wl,r)}const bu=L({prelu_:cE});function hE(n,e=null,t=!1){let s=T(n,"x","prod");s.dtype==="bool"&&(s=le(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return O.runKernel(Ul,r,o)}const Bm=L({prod_:hE});function dE(n,e,t,s){const r=n.map((c,h)=>T(c,`tensors${h}`,"raggedGather","int32")),o=T(e,"paramsDenseValues","raggedGather"),i=T(t,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:o,indices:i},l={outputRaggedRank:s},u=O.runKernel(Oh,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const Hw=L({raggedGather_:dE});function pE(n,e,t){const s=T(n,"starts","raggedRange"),r=T(e,"limits","raggedRange",s.dtype),o=T(t,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:o},a=O.runKernel(Lh,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const jw=L({raggedRange_:pE});function fE(n,e,t,s,r){const o=T(n,"shape","raggedTensorToTensor","int32"),i=T(e,"values","raggedTensorToTensor"),a=T(t,"defaultValue","raggedTensorToTensor",i.dtype),l=s.map((h,d)=>T(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:o,values:i,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:r};return O.runKernel(Ph,u,c)}const qw=L({raggedTensorToTensor_:fE});function mE(n,e,t){En(n);const s=X(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<s;o++)r[o]=e();return O.makeTensor(r,n,t)}const Kw=L({rand_:mE});var ac={exports:{}},gE=ac.exports,ex;function yE(){return ex||(ex=1,function(n){(function(e,t,s){function r(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function o(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,c),d.state=function(){return o(c,{})}),d}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=i:this.alea=i})(gE,n)}(ac)),ac.exports}var lc={exports:{}},bE=lc.exports,tx;function xE(){return tx||(tx=1,function(n){(function(e,t,s){function r(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function i(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xor128=i})(bE,n)}(lc)),lc.exports}var uc={exports:{}},wE=uc.exports,nx;function vE(){return nx||(nx=1,function(n){(function(e,t,s){function r(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function i(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xorwow=i})(wE,n)}(uc)),uc.exports}var cc={exports:{}},IE=cc.exports,sx;function $E(){return sx||(sx=1,function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,a)}function o(a,l){return l.x=a.x.slice(),l.i=a.i,l}function i(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xorshift7=i})(IE,n)}(cc)),cc.exports}var hc={exports:{}},SE=hc.exports,rx;function NE(){return rx||(rx=1,function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,m,g,y=[],b=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,b=Math.max(b,h.length)),f=0,m=-32;m<b;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=p+g,f=d==0?f+1:0);for(f>=128&&(y[(h&&h.length||0)&127]=-1),f=127,m=512;m>0;--m)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;c.w=g,c.X=y,c.i=f}u(l,a)}function o(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function i(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.xor4096=i})(SE,n)}(hc)),hc.exports}var dc={exports:{}},CE=dc.exports,ox;function kE(){return ox||(ox=1,function(n){(function(e,t,s){function r(a){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function o(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function i(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:this.tychei=i})(CE,n)}(dc)),dc.exports}var pc={exports:{}};const TE={},EE=Object.freeze(Object.defineProperty({__proto__:null,default:TE},Symbol.toStringTag,{value:"Module"})),AE=jN(EE);var RE=pc.exports,ix;function DE(){return ix||(ix=1,function(n){(function(e,t,s){var r=256,o=6,i=52,a="random",l=s.pow(r,o),u=s.pow(2,i),c=u*2,h=r-1,d;function p(x,S,k){var D=[];S=S==!0?{entropy:!0}:S||{};var F=y(g(S.entropy?[x,v(t)]:x??b(),3),D),A=new f(D),R=function(){for(var N=A.g(o),z=l,V=0;N<u;)N=(N+V)*r,z*=r,V=A.g(1);for(;N>=c;)N/=2,z/=2,V>>>=1;return(N+V)/z};return R.int32=function(){return A.g(4)|0},R.quick=function(){return A.g(4)/4294967296},R.double=R,y(v(A.S),t),(S.pass||k||function(N,z,V,j){return j&&(j.S&&m(j,A),N.state=function(){return m(A,{})}),V?(s[a]=N,z):N})(R,F,"global"in S?S.global:this==s,S.state)}function f(x){var S,k=x.length,D=this,F=0,A=D.i=D.j=0,R=D.S=[];for(k||(x=[k++]);F<r;)R[F]=F++;for(F=0;F<r;F++)R[F]=R[A=h&A+x[F%k]+(S=R[F])],R[A]=S;(D.g=function(N){for(var z,V=0,j=D.i,G=D.j,q=D.S;N--;)z=q[j=h&j+1],V=V*r+q[h&(q[j]=q[G=h&G+z])+(q[G]=z)];return D.i=j,D.j=G,V})(r)}function m(x,S){return S.i=x.i,S.j=x.j,S.S=x.S.slice(),S}function g(x,S){var k=[],D=typeof x,F;if(S&&D=="object")for(F in x)try{k.push(g(x[F],S-1))}catch{}return k.length?k:D=="string"?x:x+"\0"}function y(x,S){for(var k=x+"",D,F=0;F<k.length;)S[h&F]=h&(D^=S[h&F]*19)+k.charCodeAt(F++);return v(S)}function b(){try{var x;return d&&(x=d.randomBytes)?x=x(r):(x=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(x)),v(x)}catch{var S=e.navigator,k=S&&S.plugins;return[+new Date,e,k,e.screen,v(t)]}}function v(x){return String.fromCharCode.apply(0,x)}if(y(s.random(),t),n.exports){n.exports=p;try{d=AE}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:RE,[],Math)}(pc)),pc.exports}var Cp,ax;function FE(){if(ax)return Cp;ax=1;var n=yE(),e=xE(),t=vE(),s=$E(),r=NE(),o=kE(),i=DE();return i.alea=n,i.xor128=e,i.xorwow=t,i.xorshift7=s,i.xor4096=r,i.tychei=o,Cp=i,Cp}var na=FE();const _E=.001,Xw=.1;function OE(n,e,t){return t==null&&(t=Mm()),ef(n,e,(s,r)=>Vm(s,r,t))}function Mm(){return O.backend.floatPrecision()===32?_E:Xw}function ef(n,e,t){let s=!0;if((Ct(n)||Ct(e))&&(s=!1),Ct(n)&&Ct(e)&&(s=!0),s){const i=n.constructor.name,a=e.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const i=Es(n),a=Es(e);if(!_e(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}const r=Ct(n)?n:Ts(n),o=Ct(e)?e:Ts(e);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let i=0;i<o.length;++i){const a=r[i],l=o[i];if(!t(a,l))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${l}.
Actual:   ${r}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function LE(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function PE(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return vs(n)||vs(n[0])||vs(e)||vs(e[0])?ef(n,t,(s,r)=>s==r):ef(n,e,(s,r)=>Vm(s,r,0))}function zE(n,e,t){if(t==null&&(t=Mm()),!Vm(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function Vm(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function BE(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function ME(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function Yw(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?Yw(t):n[e]=$s(t)}return n}function VE(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function WE(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const UE=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Xw,createVideoElement:VE,encodeStrings:Yw,expectArrayBuffersEqual:ME,expectArraysClose:OE,expectArraysEqual:PE,expectNumbersClose:zE,expectPromiseToFail:LE,expectValuesInRange:BE,play:WE,testEpsilon:Mm},Symbol.toStringTag,{value:"Module"}));class Wm{constructor(e,t,s,r,o){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=na.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,o,i;do r=2*this.random()-1,o=2*this.random()-1,i=r*r+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class GE{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const o=r||Math.random();this.randu=na.alea(o.toString()),this.randn=new Wm(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,o,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<t||Math.log(o)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class HE{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=na.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function jE(n,e,t=1,s="float32",r){if(En(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new GE(e,t,s,r),i=Ee(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Jw=L({randomGamma_:jE});function qE(n,e=0,t=1,s,r){if(En(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new Wm(e,t,s,!1,r),i=Ee(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const wd=L({randomNormal_:qE});function KE(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return wd(n,0,1,e,t)}const Zw=L({randomStandardNormal_:KE});function XE(n,e=0,t=1,s="float32",r){En(n);const o=Ee(n,s),i=new HE(e,t,null,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Rr=L({randomUniform_:XE});function YE(n,e,t,s){return Rr(n,e,t,"int32",s)}const Qw=L({randomUniformInt_:YE});function ao(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return O.runKernel(zh,{},r)}function JE(n){const t={input:T(n,"input","real")};return O.runKernel(Bh,t)}const jo=L({real_:JE});function ZE(n){const t={x:T(n,"x","reciprocal")};return O.runKernel(Di,t)}const Um=L({reciprocal_:ZE});function QE(n){const t={x:T(n,"x","relu")};return O.runKernel(Fi,t)}const fs=L({relu_:QE});function eA(n){const t={x:T(n,"x","relu6")};return O.runKernel(_i,t)}const vd=L({relu6_:eA});function tA(n,e){const s={x:T(n,"x","reverse")},r={dims:e};return O.runKernel(ql,s,r)}const Vn=L({reverse_:tA});function nA(n){const e=T(n,"x","reverse");return C(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Vn(e,0)}const e1=L({reverse1d_:nA});function sA(n,e){const t=T(n,"x","reverse");return C(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Vn(t,e)}const t1=L({reverse2d_:sA});function rA(n,e){const t=T(n,"x","reverse");return C(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Vn(t,e)}const n1=L({reverse3d_:rA});function oA(n,e){const t=T(n,"x","reverse");return C(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Vn(t,e)}const s1=L({reverse4d_:oA});function iA(n){const t={x:T(n,"x","round")};return O.runKernel(Oi,t)}const Id=L({round_:iA});function aA(n){const t={x:T(n,"x","rsqrt","float32")};return O.runKernel(Li,t)}const $d=L({rsqrt_:aA});function lA(n){const t={x:T(n,"x","selu")};return O.runKernel(Pi,t)}const Sd=L({selu_:lA});function uA(n,e,t,s,r,o=[1,1],i="NHWC"){const a=T(n,"x","separableConv2d"),l=T(e,"depthwiseFilter","separableConv2d"),u=T(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),C(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),C(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),C(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),C(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];C(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=Ji(c,l,s,r,i,o),g=Hs(f,u,1,"valid",i);return h?B(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Nd=L({separableConv2d_:uA});async function cA(n,e){const t=T(n,"x","setdiff1d"),s=T(e,"y","setdiff1d");C(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),C(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),C(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),o=await s.data(),i=new Set(o);let a=0;for(let c=0;c<r.length;c++)i.has(r[c])||a++;const l=new St([a],t.dtype),u=new St([a],"int32");for(let c=0,h=0;c<r.length;c++)i.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const r1=cA;function hA(n){const t={x:T(n,"x","sign")};return O.runKernel(Mi,t)}const Gm=L({sign_:hA});function dA(n){const t={x:T(n,"x","sin","float32")};return O.runKernel(zi,t)}const Cd=L({sin_:dA});function pA(n){const t={x:T(n,"x","sinh")};return O.runKernel(Bi,t)}const kd=L({sinh_:pA});function fA(n,e,t){const s=T(n,"x","slice1d");return C(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Le(s,[e],[t])}const xu=L({slice1d_:fA});function mA(n,e,t){const s=T(n,"x","slice2d");return C(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Le(s,e,t)}const Td=L({slice2d_:mA});function gA(n,e,t){const s=T(n,"x","slice3d");return C(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Le(s,e,t)}const wu=L({slice3d_:gA});function yA(n,e,t){const s=T(n,"x","slice4d");return C(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Le(s,e,t)}const qo=L({slice4d_:yA});function bA(n,e=-1){const t=T(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return O.runKernel(Ql,s,r)}const vu=L({softmax_:bA});function xA(n){C(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return O.runKernel(wh,e)}const Iu=L({fft_:xA});function wA(n){C(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return O.runKernel(Sh,e)}const Ko=L({ifft_:wA});function vA(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=B(n,[t,e]);s=Ko(r)}else{const r=[t,2*(e-1)],o=B(jo(n),[t,e]),i=B(cu(n),[t,e]),a=Vn(Le(o,[0,1],[t,e-2]),1),l=P(Vn(Le(i,[0,1],[t,e-2]),1),xe(-1)),u=gt([o,a],1),c=gt([i,l],1),h=B(Gs(u,c),[r[0],r[1]]);s=Ko(h)}if(s=jo(s),n.rank===3&&n.shape[0]!==0){const r=s,o=n.shape[0];s=B(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const Ed=L({irfft_:vA});function IA(n,e,t=0){const r={x:T(n,"x","split")},o={numOrSizeSplits:e,axis:t};return O.runKernel(Zl,r,o)}const dn=L({split_:IA});function $A(n,e){C(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,r=Le(n,f,m),t=e}else if(e!=null&&e>t){const f=n.shape.map(m=>m);f[n.shape.length-1]=e-t,r=gt([n,mt(f)],n.shape.length-1),t=e}else r=n;const o=Pe(r),i=B(Gs(r,o),[s,t]),a=Iu(i),l=Math.floor(t/2)+1,u=jo(a),c=cu(a),h=dn(u,[l,t-l],u.shape.length-1),d=dn(c,[l,t-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,B(Gs(h[0],d[0]),p)}const $u=L({rfft_:$A});function SA(n,e){let t=T(n,"a","squaredDifference"),s=T(e,"b","squaredDifference");[t,s]=ht(t,s),Ne(t.shape,s.shape);const r={a:t,b:s},o={};return O.runKernel(Gi,r,o)}const Ad=L({squaredDifference_:SA});function NA(n,e){const t=T(n,"x","squeeze","string_or_numeric");return B(t,Ys(t.shape,e).newShape)}const Dr=L({squeeze_:NA});function CA(n,e=0){const t=Wa(n,"tensors","stack","string_or_numeric");C(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&C(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return O.runKernel(Ml,s,r)}const rn=L({stack_:CA});function kA(n,e=0){const s={x:T(n,"x","step")},r={alpha:e};return O.runKernel(Xi,s,r)}const So=L({step_:kA});function TA(n,e,t,s,r=0,o=0,i=0,a=0,l=0){const c={x:T(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return O.runKernel(Jh,c,h)}const Hm=L({stridedSlice_:TA});function EA(n){const t={x:T(n,"x","tan","float32")};return O.runKernel(ji,t)}const jm=L({tan_:EA});function Ht(n,e){bo(n);const t=Es(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return kr(n,null,t,e)}function dr(n,e,t){if(bo(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Es(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return kr(n,e,s,t)}function qm(n,e,t){if(bo(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Es(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return kr(n,e,s,t)}function o1(n,e,t){if(bo(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Es(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return kr(n,e,s,t)}function i1(n,e,t){if(bo(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Es(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return kr(n,e,s,t)}function a1(n,e,t){if(bo(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Es(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,kr(n,e,s,t)}function Km(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(o+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let i=0;i<r;++i)if(t.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-r;++i)if(t.shape[i+r]!==n[i+s])throw new Error(o+` updates.shape[${i+r}] (${t.shape[i+r]}) != shape[${i+r}] (${n[i+r]})`)}function Rd(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Km(t,e,n)}function Fr(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=t.length;let i=1;for(let h=r;h<o;++h)i*=t[h];const a=r<1?1:r,l=X(e.shape)/a,u=[...we(t.slice(0,r)),1],c=X(t);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}const AA=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Fr,validateInput:Rd,validateUpdateShape:Km},Symbol.toStringTag,{value:"Module"}));function RA(n,e,t){const s=T(n,"tensor","tensorScatterupdate"),r=T(e,"indices","tensorScatterupdate","int32"),o=T(t,"updates","tensorScatterupdate");if(Rd(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const i={tensor:s,indices:r,updates:o},a={};return O.runKernel(Uh,i,a)}const l1=L({tensorScatterUpdate_:RA});function DA(n,e=1,t=!0){const s=T(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},i={k:e,sorted:t},[a,l]=O.runKernel(td,o,i);return{values:a,indices:l}}const Xm=L({topk_:DA});function FA(n,e=0,t=1,s,r){if(En(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Wm(e,t,s,!0,r),i=Ee(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Dd=L({truncatedNormal_:FA});function _A(n,e=0){const t=T(n,"x","unique","string_or_numeric");C(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[o,i]=O.runKernel(sd,s,r);return{values:o,indices:i}}const Ym=L({unique_:_A});function OA(n,e,t){const s=T(n,"x","unsortedSegmentSum"),r=T(e,"segmentIds","unsortedSegmentSum","int32");C(Qr(t),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},i={numSegments:t};return O.runKernel(nu,o,i)}const Fd=L({unsortedSegmentSum_:OA});function LA(n,e=0){const t=T(n,"x","unstack","string_or_numeric");C(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return O.runKernel(tu,s,r)}const Wn=L({unstack_:LA});function u1(n,e){return xd(n,e,"right")}function Jm(n,e=!0,t,s){return O.makeVariable(n,e,t,s)}function _d(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const s=Ee(n,"int32"),r=Ee([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const i=s.indexToLoc(t[o]),a=o*n.length;r.values.set(i,a)}return r.toTensor()}async function PA(n){const e=T(n,"condition","whereAsync","bool"),t=await e.data(),s=_d(e.shape,t);return n!==e&&e.dispose(),s}const Zm=PA;async function zA(n,e,t){const s=T(n,"tensor","boolMask"),r=T(e,"mask","boolMask","bool"),o=t??0,i=r.rank,a=s.shape;C(i>0,()=>"mask cannot be scalar"),qt(a.slice(o,o+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+i;m++)l*=a[m];const u=a.slice(0,o).concat([l],a.slice(o+i)),c=B(s,u),h=B(r,[-1]),d=await Zm(h),p=Dr(d,[1]),f=ta(c,p,o);return n!==s&&s.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f}const c1=zA;function BA(n,e,t){const s=T(n,"x","transpose");if(e==null&&(e=s.shape.map((i,a)=>a).reverse()),C(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{C(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?U(()=>{let i=jo(s),a=cu(s);return i=O.runKernel(Xr,{x:i},o),a=O.runKernel(Xr,{x:a},o),t&&(a=tt(a)),Gs(i,a)}):O.runKernel(Xr,r,o)}const Oe=L({transpose_:BA});function MA(n,e,t,s,r=!0){const o=T(n,"v","movingAverage"),i=T(e,"x","movingAverage"),a=T(t,"decay","movingAverage");iw(o,i),C(_e(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=xe(1),u=pe(l,a);let c=P(pe(i,o),u);if(r){C(s!=null,()=>"When using zeroDebias: true, step is required.");const h=T(s,"step","movingAverage");c=ge(c,pe(l,As(a,h)))}return re(o,c)}const h1=L({movingAverage_:MA});function VA(n,e,t){En(t);const s=T(n,"indices","scatterND","int32"),r=T(e,"updates","scatterND");Rd(r,s,t);const o={indices:s,updates:r},i={shape:t};return O.runKernel(Wh,o,i)}const d1=L({scatterND_:VA});function WA(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function UA(n,e,t,s=0){En(t);const r=T(n,"sparseIndices","sparseToDense","int32"),o=T(e,"sparseValues","sparseToDense","string_or_numeric"),i=T(s,"defaultValue","sparseToDense",o.dtype);WA(r,o,t,i);const a={sparseIndices:r,sparseValues:o,defaultValue:i},l={outputShape:t};return O.runKernel(Xh,a,l)}const p1=L({sparseToDense_:UA});function GA(n,e){const t=T(e,"indices","gatherND","int32"),r={params:T(n,"x","gatherND","string_or_numeric"),indices:t};return O.runKernel($h,r)}const f1=L({gatherND_:GA});function HA(n,e){if(e==null)return n.shape.slice();if(_e(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function jA(n,e,t,s){const r=T(n,"x","dropout");if(C(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),C(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof ze?r.clone():r;const o=HA(r,t),i=1-e,a=ge(ea(re(Rr(o,0,1,"float32",s),i)),i);return P(r,a)}const Qm=L({dropout_:jA});function eg(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Od(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+s-1);r[o]=e-t*Math.cos(i)}return Ht(r,"float32")}async function qA(n,e,t=1){const s=T(n,"predictions","inTopK"),r=T(e,"targets","inTopK");C(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),C(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),qt(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];C(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const i=await s.data(),a=await r.data(),[l,u]=[i.length/o,o],c=Ot("bool",l);for(let h=0;h<l;h++){const d=h*u,p=i.subarray(d,d+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[h]=0;for(let m=0;m<t;m++)if(f[m].index===a[h]){c[h]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Sn(c,r.shape,"bool")}const m1=qA;function KA(n,e,t,s,r,o="NHWC",i){let a=n;n.rank===3&&(a=B(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=B(e,[1,e.shape[0],e.shape[1],e.shape[2]])),C(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),C(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),C(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=o==="NHWC"?a.shape[3]:a.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];C(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),C(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),an("conv2dDerFilter",r,i);const h={x:a,dy:l},d={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,filterShape:t};return O.runKernel(ah,h,d)}const tg=L({conv2DBackpropFilter_:KA});function Ld(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return P(n,So(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Pd(n,e){let t=e;const s=Nt(n.shape,e.shape);return s.length>0&&(t=fe(t,s)),B(t,n.shape)}function zd(n,e,t,s){if(e==="linear")return n;if(e==="relu")return fs(n);if(e==="elu")return Zi(n);if(e==="relu6")return vd(n);if(e==="prelu")return bu(n,t);if(e==="leakyrelu")return hu(n,s);if(e==="sigmoid")return is(n);throw new Error(`Unknown fused activation ${e}.`)}const Bd=(n,e)=>!(n>0)||e==="linear";function XA({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Bd(O.state.gradientDepth,l)===!1){C(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=Hs(n,e,t,s,r,o,i);return a!=null&&(k=re(k,a)),zd(k,l,u,c)}const h=T(n,"x","conv2d","float32"),d=T(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),C(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),C(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),an("fused conv2d",s,i);const m=r==="NHWC"?p.shape[3]:p.shape[1];C(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),C(Kt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const g=zt(p.shape,d.shape,t,o,s,i);let y;a!=null&&(y=T(a,"bias","fused conv2d"),[y]=ht(y,h),r==="NHWC"?Ne(g.outShape,y.shape):(C(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),C(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){const k=u.shape;if(C(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)C(k[0]===1||k[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${g.outChannels}).`);else if(k.length===3)try{Ne(k,g.outShape)}catch{const F=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(F)}b=T(u,"prelu weights","fused conv2d")}const v=(k,D)=>{C(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[F,A,R,N]=D,z=Ld(k,R,l);C(br(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const V=xm(A.shape,z,F,t,s),j=tg(A,z,F.shape,t,s),G=[V,j];if(N!=null){const q=Pd(N,z);G.push(q)}return G},x={x:p,filter:d,bias:y,preluActivationWeights:b},S={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?Rs((D,F,A)=>{let R=O.runKernel(Pa,x,S);return A([F,D,R]),f&&(R=B(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(p,d):Rs((D,F,A,R)=>{let N=O.runKernel(Pa,x,S);return R([F,D,N,A]),f&&(N=B(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:v}})(p,d,y)}const g1=L({fusedConv2d_:XA});function YA(n,e,t,s,r,o=[1,1],i){let a=n;n.rank===3&&(a=B(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,filterShape:t};return O.runKernel(fh,u,c)}const y1=L({depthwiseConv2dNativeBackpropFilter_:YA});function JA(n,e,t,s,r,o=[1,1],i){let a=e,l=!1;e.rank===3&&(l=!0,a=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,inputShape:n},h=O.runKernel(mh,u,c);return l?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const b1=L({depthwiseConv2dNativeBackpropInput_:JA});function ZA({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(Bd(O.state.gradientDepth,l)===!1){let S=Ji(n,e,t,s,r,o,i);return a!=null&&(S=re(S,a)),zd(S,l,u,c)}const h=T(n,"x","depthwiseConv2d","float32"),d=T(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),C(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),C(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),C(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),C(Kt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),an("fused depthwiseConv2d",s,i);const m=zt(p.shape,d.shape,t,o,s,i,!0);let g;a!=null&&(g=T(a,"bias","fused conv2d"),[g]=ht(g,h),Ne(m.outShape,g.shape));let y;u!=null&&(y=T(u,"prelu weights","fused depthwiseConv2d"));const b=(S,k)=>{C(br(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[D,F,A,R]=k,N=Ld(S,A,l),z=b1(F.shape,N,D,t,s,o,i),V=y1(F,N,D.shape,t,s,o,i);if(R!=null){const j=Pd(g,N);return[z,V,j]}return[z,V]},v={x:p,filter:d,bias:g,preluActivationWeights:y},x={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?Rs((k,D,F)=>{let A=O.runKernel(za,v,x);return F([D,k,A]),f&&(A=B(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(p,d):Rs((k,D,F,A)=>{let R=O.runKernel(za,v,x);return A([D,k,R,F]),f&&(R=B(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(p,d,g)}const QA=L({fusedDepthwiseConv2d_:ZA});function eR({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Bd(O.state.gradientDepth,o)===!1){let N=Ae(n,e,t,s);return r!=null&&(N=re(N,r)),zd(N,o,i,a)}let l=T(n,"a","fused matMul"),u=T(e,"b","fused matMul");[l,u]=ht(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=X(f),y=X(m);C(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${s} must match.`);const v=Ne(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),x=t?B(l,[g,c,d]):B(l,[g,d,c]),S=s?B(u,[y,p,h]):B(u,[y,h,p]);let k;r!=null&&(k=T(r,"bias","fused matMul"),[k]=ht(k,l),Ne(v,k.shape));let D;i!=null&&(D=T(i,"prelu weights","fused matMul"));const F=(N,z)=>{const[V,j,G,q]=z,J=Ld(B(N,G.shape),G,o);let K,Q;if(!t&&!s?(K=Ae(J,j,!1,!0),Q=Ae(V,J,!0,!1)):!t&&s?(K=Ae(J,j,!1,!1),Q=Ae(J,V,!0,!1)):t&&!s?(K=Ae(j,J,!1,!0),Q=Ae(V,J,!1,!1)):(K=Ae(j,J,!0,!0),Q=Ae(J,V,!0,!0)),r!=null){const te=Pd(q,J);return[K,Q,te]}else return[K,Q]},A={a:x,b:S,bias:k,preluActivationWeights:D},R={transposeA:t,transposeB:s,activation:o,leakyreluAlpha:a};return r==null?Rs((z,V,j)=>{const G=O.runKernel(La,A,R);return j([z,V,G]),{value:B(G,v),gradFunc:F}})(x,S):Rs((z,V,j,G)=>{const q=O.runKernel(La,A,R);return G([z,V,q,j]),{value:B(q,v),gradFunc:F}})(x,S,k)}const tf=L({fusedMatMul_:eR});const x1=Object.freeze(Object.defineProperty({__proto__:null,conv2d:g1,depthwiseConv2d:QA,matMul:tf},Symbol.toStringTag,{value:"Module"}));function tR(n){return Od(n,.54,.46)}const nR=L({hammingWindow_:tR});function sR(n){return Od(n,.5,.5)}const w1=L({hannWindow_:sR});function rR(n,e,t,s=!1,r=0){let o=0;const i=[];for(;o+e<=n.size;)i.push(Le(n,o,e)),o+=t;if(s)for(;o<n.size;){const a=o+e-n.size,l=gt([Le(n,o,e-a),Io([a],r)]);i.push(l),o+=t}return i.length===0?dr([],[0,e]):B(gt(i),[i.length,e])}const v1=L({frame_:rR});function oR(n,e,t,s,r=w1){s==null&&(s=eg(e));const o=v1(n,e,t),i=P(o,r(e));return $u(i,s)}const iR=L({stft_:oR});function aR(n,e,t,s,r="bilinear",o=0){const i=T(n,"image","cropAndResize"),a=T(e,"boxes","cropAndResize","float32"),l=T(t,"boxInd","cropAndResize","int32"),u=a.shape[0];C(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),C(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),C(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),C(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),C(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),C(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:i,boxes:a,boxInd:l},h={method:r,extrapolationValue:o,cropSize:s};return O.runKernel(hh,c,h)}const lR=L({cropAndResize_:aR});function uR(n){const e=T(n,"image","flipLeftRight","float32");C(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return O.runKernel(Ih,t,{})}const cR=L({flipLeftRight_:uR});function hR(n){const e=T(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];C(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),C(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,On(e,r)}const dR=L({grayscaleToRGB_:hR});function pR(n){const e=T(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];C(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),C(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,o=le(e,"float32"),i=Ht([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Wr("ij,j->i",o,i);break;case 3:a=Wr("ijk,k->ij",o,i);break;case 4:a=Wr("ijkl,l->ijk",o,i);break;case 5:a=Wr("ijklm,m->ijkl",o,i);break;case 6:a=Wr("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Wt(a,-1),le(a,r)}const fR=L({rgbToGrayscale_:pR});function mR(n,e,t=0,s=.5){const r=T(n,"image","rotateWithOffset","float32");C(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},i={radians:e,fillValue:t,center:s};return O.runKernel(rd,o,i)}const gR=L({rotateWithOffset_:mR});function sa(n,e,t,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=n.shape[0];return t=Math.min(t,i),C(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),C(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),C(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),C(e.rank===1,()=>"scores must be a 1D tensor"),C(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),C(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}function yR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=T(n,"boxes","nonMaxSuppression","float32"),i=T(e,"scores","nonMaxSuppression","float32"),a=sa(o,i,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return O.runKernel(Dh,{boxes:o,scores:i},l)}const bR=L({nonMaxSuppression_:yR});function xR(n,e,t){const s=wR(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function wR(n,e,t){return IR(n,e,t||vR)}function vR(n,e){return n>e?1:n<e?-1:0}function IR(n,e,t){let s=0,r=n.length,o=0,i=!1;for(;s<r;){o=s+(r-s>>>1);const a=t(e,n[o]);a>0?s=o+1:(r=o,i=!a)}return i?s:-s-1}function Md(n,e,t,s,r){return ng(n,e,t,s,r,0)}function Vd(n,e,t,s,r,o){return ng(n,e,t,s,r,0,!1,o,!0)}function Wd(n,e,t,s,r,o){return ng(n,e,t,s,r,o,!0)}function ng(n,e,t,s,r,o,i=!1,a=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(lx);const c=o>0?-.5/o:0,h=[],d=[];for(;h.length<t&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:v}=g;if(y<r)break;let x=!1;for(let S=h.length-1;S>=v;--S){const k=$R(n,b,h[S]);if(k>=s){x=!0;break}if(g.score=g.score*SR(s,c,k),g.score<=r)break}g.suppressBeginIndex=h.length,x||(g.score===y?(h.push(b),d.push(g.score)):g.score>r&&xR(u,g,lx))}const p=h.length,f=t-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function $R(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),o=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-o)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(o,u),g=Math.max(i,c),y=Math.min(a,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function SR(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function lx(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function NR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=T(n,"boxes","nonMaxSuppressionAsync"),i=T(e,"scores","nonMaxSuppressionAsync"),a=sa(o,i,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=Md(u,c,t,s,r);return o!==n&&o.dispose(),i!==e&&i.dispose(),Ht(h,"int32")}const CR=NR;function kR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=T(n,"boxes","nonMaxSuppression"),a=T(e,"scores","nonMaxSuppression"),l=sa(i,a,t,s,r,o);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u={boxes:i,scores:a},c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},h=O.runKernel(_h,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const TR=L({nonMaxSuppressionWithScore_:kR});async function ER(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=T(n,"boxes","nonMaxSuppressionAsync"),a=T(e,"scores","nonMaxSuppressionAsync"),l=sa(i,a,t,s,r,o);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u=await Promise.all([i.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=Wd(c,h,t,s,r,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Ht(d,"int32"),selectedScores:Ht(p)}}const AR=ER;function RR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=T(n,"boxes","nonMaxSuppression"),a=T(e,"scores","nonMaxSuppression"),l=sa(i,a,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:a},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:o},f=O.runKernel(Fh,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const DR=L({nonMaxSuppressionPadded_:RR});async function FR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=T(n,"boxes","nonMaxSuppressionAsync"),a=T(e,"scores","nonMaxSuppressionAsync"),l=sa(i,a,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:m}=Vd(d,p,u,c,h,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Ht(f,"int32"),validOutputs:xe(m,"int32")}}const _R=FR;function OR(n,e,t=!1,s=!1){const r=T(n,"images","resizeBilinear");C(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),C(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),C(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=B(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},l={alignCorners:t,halfPixelCenters:s,size:e},u=O.runKernel(jl,a,l);return i?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const I1=L({resizeBilinear_:OR});function LR(n,e,t=!1,s=!1){const r=T(n,"images","resizeNearestNeighbor");C(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),C(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),C(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),C(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=B(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},l={alignCorners:t,halfPixelCenters:s,size:e},u=O.runKernel(Hl,a,l);return i?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const $1=L({resizeNearestNeighbor_:LR});function PR(n,e="binary",t=!1,s=.5){const r=T(n,"image","threshold"),o=.2989,i=.587,a=.114,l=r.shape[0]*r.shape[1];let u=P(Ht([s]),255),c,h,d,p;if(C(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),C(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),C(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),C(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,d]=dn(r,[1,1,1],-1);const g=P(c,o),y=P(h,i),b=P(d,a);p=re(re(g,y),b)}else p=n;if(e==="otsu"){const g=pm(le(Id(p),"int32"),Sn([]),256);u=zR(g,l)}const f=t?Ar(p,u):ln(p,u);return le(P(f,255),"int32")}function zR(n,e){let t=Ht([-1]),s=Ht([0]),r=Ht([0]),o,i,a,l,u,c;for(let h=0;h<n.size-1;h++){o=Le(n,0,h+1),i=Le(n,h+1),u=ge(fe(o),e),c=ge(fe(i),e);const d=fe(P(o,ao(0,o.size)));a=ge(d,fe(o));const p=Io(i.shape,o.size),f=re(ao(0,i.size),p),m=P(i,f);l=ge(fe(m),fe(i));const g=pe(a,l),y=pe(a,l),b=P(u,c);r=P(P(b,g),y);const v=ln(r,s);s=_t(v,r,s),t=_t(v,Ht([h]),t)}return t}const BR=L({threshold_:PR});function MR(n,e,t="nearest",s="constant",r=0,o){const i=T(n,"image","transform","float32"),a=T(e,"transforms","transform","float32");C(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),C(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),C(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:i,transforms:a},u={interpolation:t,fillMode:s,fillValue:r,outputShape:o};return O.runKernel(nd,l,u)}const VR=L({transform_:MR});function WR(n,e,t){const s=T(n,"a","bandPart");C(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,i]=s.shape.slice(-2);let a,l;typeof e=="number"?(C(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),C(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=T(e<0?o:e,"numLower","bandPart")):(C(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=_t(Go(e,0),o,wr(e,o))),typeof t=="number"?(C(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),C(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),l=T(t<0?i:t,"numUpper","bandPart")):(C(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=_t(Go(t,0),i,wr(t,i)));const u=B(ao(0,o,1,"int32"),[-1,1]),c=ao(0,i,1,"int32"),h=pe(u,c),d=Kn(Ar(h,a),er(h,tt(l))),p=mt([o,i],s.dtype);return B(rn(Wn(B(s,[-1,o,i])).map(f=>_t(d,f,p))),r)}const UR=L({bandPart_:WR});function GR(n){let e;if(Array.isArray(n)){e=!1,C(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let o=1;o<n.length;++o)C(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else e=!0,n=dn(n,n.shape[0],0).map(r=>Dr(r,[0]));C(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(O.tidy(()=>{let o=s[r];if(r>0)for(let i=0;i<r;++i){const a=P(fe(P(t[i],o)),t[i]);o=pe(o,a)}return ge(o,Qi(o,"euclidean"))}));return e?rn(t,0):t}const HR=L({gramSchmidt_:GR});function jR(n,e=!1){if(C(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return ux(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),s=Wn(B(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(l=>{const[u,c]=ux(l,e);r.push(u),o.push(c)});const i=B(rn(r,0),n.shape),a=B(rn(o,0),n.shape);return[i,a]}}function ux(n,e=!1){return O.tidy(()=>{C(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=md(t),o=Ss(n);const i=dr([[1]],[1,1]);let a=Ss(i);const l=t>=s?s:t;for(let u=0;u<l;++u){const c=o,h=a,d=r;[a,o,r]=O.tidy(()=>{const p=Le(o,[u,u],[t-u,1]),f=Qi(p),m=Le(o,[u,u],[1,1]),g=_t(ln(m,0),dr([[-1]]),dr([[1]])),y=pe(m,P(g,f)),b=ge(p,y);b.shape[0]===1?a=Ss(i):a=gt([i,Le(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=tt(ge(Ae(g,y),f)),x=Le(o,[u,0],[t-u,s]),S=P(v,a),k=Oe(a);if(u===0)o=pe(x,Ae(S,Ae(k,x)));else{const A=pe(x,Ae(S,Ae(k,x)));o=gt([Le(o,[0,0],[u,s]),A],0)}const D=Oe(S),F=Le(r,[0,u],[t,r.shape[1]-u]);if(u===0)r=pe(F,Ae(Ae(F,a),D));else{const A=pe(F,Ae(Ae(F,a),D));r=gt([Le(r,[0,0],[t,u]),A],1)}return[a,o,r]}),Se([c,h,d])}return!e&&t>s&&(r=Le(r,[0,0],[t,s]),o=Le(o,[0,0],[s,s])),[r,o]})}const qR=L({qr_:jR});var nn;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(nn||(nn={}));function KR(n,e,t=nn.SUM_BY_NONZERO_WEIGHTS){const s=T(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=T(e,"weights","computeWeightedLoss"));const o=r==null?s:P(s,r);if(t===nn.NONE)return o;if(t===nn.SUM)return fe(o);if(t===nn.MEAN){if(r==null)return ut(o);{const i=s.size/r.size,a=ge(fe(o),fe(r));return i>1?ge(a,xe(i)):a}}if(t===nn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ge(fe(o),xe(s.size));{const i=P(r,hn(s.shape)),a=le(fe(io(i,xe(0))),"float32");return ge(fe(o),a)}}throw Error(`Unknown reduction: ${t}`)}const nr=L({computeWeightedLoss_:KR});function XR(n,e,t,s=nn.SUM_BY_NONZERO_WEIGHTS){const r=T(n,"labels","absoluteDifference"),o=T(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=T(t,"weights","absoluteDifference")),qt(r.shape,o.shape,"Error in absoluteDifference: ");const a=It(pe(r,o));return nr(a,i,s)}const YR=L({absoluteDifference_:XR});function JR(n,e,t,s,r=nn.SUM_BY_NONZERO_WEIGHTS){const o=T(n,"labels","cosineDistance"),i=T(e,"predictions","cosineDistance");let a=null;s!=null&&(a=T(s,"weights","cosineDistance")),qt(o.shape,i.shape,"Error in cosineDistance: ");const l=xe(1),u=pe(l,fe(P(o,i),t,!0));return nr(u,a,r)}const ZR=L({cosineDistance_:JR});function QR(n,e,t,s=nn.SUM_BY_NONZERO_WEIGHTS){let r=T(n,"labels","hingeLoss");const o=T(e,"predictions","hingeLoss");let i=null;t!=null&&(i=T(t,"weights","hingeLoss")),qt(r.shape,o.shape,"Error in hingeLoss: ");const a=xe(1);r=pe(P(xe(2),r),a);const l=fs(pe(a,P(r,o)));return nr(l,i,s)}const eD=L({hingeLoss_:QR});function tD(n,e,t,s=1,r=nn.SUM_BY_NONZERO_WEIGHTS){const o=T(n,"labels","huberLoss"),i=T(e,"predictions","huberLoss");let a=null;t!=null&&(a=T(t,"weights","huberLoss")),qt(o.shape,i.shape,"Error in huberLoss: ");const l=xe(s),u=It(pe(i,o)),c=wr(u,l),h=pe(u,c),d=re(P(xe(.5),Ke(c)),P(l,h));return nr(d,a,r)}const nD=L({huberLoss_:tD});function sD(n,e,t,s=1e-7,r=nn.SUM_BY_NONZERO_WEIGHTS){const o=T(n,"labels","logLoss"),i=T(e,"predictions","logLoss");let a=null;t!=null&&(a=T(t,"weights","logLoss")),qt(o.shape,i.shape,"Error in logLoss: ");const l=xe(1),u=xe(s),c=tt(P(o,Cn(re(i,u)))),h=P(pe(l,o),Cn(re(pe(l,i),u))),d=pe(c,h);return nr(d,a,r)}const rD=L({logLoss_:sD});function oD(n,e,t,s=nn.SUM_BY_NONZERO_WEIGHTS){const r=T(n,"labels","meanSquaredError"),o=T(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=T(t,"weights","meanSquaredError")),qt(r.shape,o.shape,"Error in meanSquaredError: ");const a=Ad(r,o);return nr(a,i,s)}const iD=L({meanSquaredError_:oD});function aD(n,e){const t=T(n,"labels","sigmoidCrossEntropyWithLogits"),s=T(e,"logits","sigmoidCrossEntropyWithLogits");qt(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=fs(s),o=P(s,t),i=du(gn(tt(It(s))));return re(pe(r,o),i)}function lD(n,e,t,s=0,r=nn.SUM_BY_NONZERO_WEIGHTS){let o=T(n,"multiClassLabels","sigmoidCrossEntropy");const i=T(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=T(t,"weights","sigmoidCrossEntropy")),qt(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=xe(s),c=xe(1),h=xe(.5);o=re(P(o,pe(c,u)),P(h,u))}const l=aD(o,i);return nr(l,a,r)}const uD=L({sigmoidCrossEntropy_:lD});function cD(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Rs((r,o,i)=>{const l=pu(o,[t],!0),u=pe(le(o,"float32"),l);i([r,u]);const c=tt(P(u,r));return{value:fe(c,[t]),gradFunc:(p,f)=>{const[m,g]=f,y=yt(p.shape,[t]);return[P(B(p,y),pe(le(m,"float32"),gn(g))),P(B(p,y),pe(gn(g),le(m,"float32")))]}}})(n,e)}function hD(n,e,t,s=0,r=nn.SUM_BY_NONZERO_WEIGHTS){let o=T(n,"onehotLabels","softmaxCrossEntropy");const i=T(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=T(t,"weights","softmaxCrossEntropy")),qt(o.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const u=xe(s),c=xe(1),h=xe(o.shape[1]);o=re(P(o,pe(c,u)),ge(u,h))}const l=cD(o,i);return nr(l,a,r)}const dD=L({softmaxCrossEntropy_:hD});function pD(n,e,t,s){const r=T(n,"indices","sparseFillEmptyRows","int32"),o=T(e,"values","sparseFillEmptyRows"),i=T(t,"denseShape","sparseFillEmptyRows","int32"),a=T(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:o,denseShape:i,defaultValue:a},u=O.runKernel(Hh,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const fD=L({sparseFillEmptyRows_:pD});function mD(n,e,t){const s=T(n,"inputIndices","sparseReshape","int32"),r=T(e,"inputShape","sparseReshape","int32"),o=T(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:s,inputShape:r,newShape:o},a=O.runKernel(jh,i);return{outputIndices:a[0],outputShape:a[1]}}const gD=L({sparseReshape_:mD});function yD(n,e,t){const s=T(n,"data","sparseSegmentMean"),r=T(e,"indices","sparseSegmentMean","int32"),o=T(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return O.runKernel(qh,i)}const bD=L({sparseSegmentMean_:yD});function xD(n,e,t){const s=T(n,"data","sparseSegmentSum"),r=T(e,"indices","sparseSegmentSum","int32"),o=T(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return O.runKernel(Kh,i)}const wD=L({sparseSegmentSum_:xD});function vD(n,e,t,s,r,o,i,a){const l=T(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=T(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:s,leftPad:r,rightPad:o,padWidth:i,preserveShortSequences:a},h={data:l,dataSplits:u},d=O.runKernel(Zh,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const ID=L({stringNGrams_:vD});function $D(n,e,t=!0){const s=T(n,"input","stringSplit","string"),r=T(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},i={input:s,delimiter:r},a=O.runKernel(Qh,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const SD=L({stringSplit_:$D});function ND(n,e){const t=T(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return O.runKernel(ed,r,s)}const CD=L({stringToHashBucketFast_:ND});function kD(n,e,t,s=!0){const r=T(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:s};return O.runKernel(eu,{x:r},o)}const TD=L({staticRegexReplace_:kD});const S1={fft:Iu,ifft:Ko,rfft:$u,irfft:Ed},N1={hammingWindow:nR,hannWindow:w1,frame:v1,stft:iR},Ln={flipLeftRight:cR,grayscaleToRGB:dR,resizeNearestNeighbor:$1,resizeBilinear:I1,rgbToGrayscale:fR,rotateWithOffset:gR,cropAndResize:lR,nonMaxSuppression:bR,nonMaxSuppressionAsync:CR,nonMaxSuppressionWithScore:TR,nonMaxSuppressionWithScoreAsync:AR,nonMaxSuppressionPadded:DR,nonMaxSuppressionPaddedAsync:_R,threshold:BR,transform:VR},sg={bandPart:UR,gramSchmidt:HR,qr:qR},C1={absoluteDifference:YR,computeWeightedLoss:nr,cosineDistance:ZR,hingeLoss:eD,huberLoss:nD,logLoss:rD,meanSquaredError:iD,sigmoidCrossEntropy:uD,softmaxCrossEntropy:dD},k1={sparseFillEmptyRows:fD,sparseReshape:gD,sparseSegmentMean:bD,sparseSegmentSum:wD},T1={stringNGrams:ID,stringSplit:SD,stringToHashBucketFast:CD,staticRegexReplace:TD};const ED=new Map,nf=new Map;class No{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class _n{constructor(){this.classNameMap={}}static getMap(){return _n.instance==null&&(_n.instance=new _n),_n.instance}static register(e){_n.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ie(n,e,t){C(n.className!=null,()=>"Class being registered does not have the static className property defined."),C(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),C(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return _n.register(n),ED.set(r,n),nf.set(n,r),n}function AD(n){return nf.has(n)?nf.get(n):n.className}const RD=Object.freeze(Object.defineProperty({__proto__:null,Serializable:No,SerializationMap:_n,getRegisteredName:AD,registerClass:ie},Symbol.toStringTag,{value:"Module"}));class sr extends No{minimize(e,t=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const i=s.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return Se(o),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return _w(e,t)}dispose(){this.iterations_!=null&&Se(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:xe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(sr,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class rg extends sr{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=O.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:U(()=>Pe(o).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:U(()=>Pe(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;U(()=>{const c=re(P(l,this.rho),P(Ke(a),1-this.rho)),h=P(ge(Lt(re(u,this.epsilon)),Lt(re(l,this.epsilon))),a),d=re(P(u,this.rho),P(Ke(h),1-this.rho));l.assign(c),u.assign(d);const p=re(P(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Se(this.accumulatedGrads.map(e=>e.variable)),Se(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class og extends sr{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=O.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:U(()=>Io(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=this.accumulatedGrads[r].variable;U(()=>{const l=re(a,Ke(i));a.assign(l);const u=re(P(ge(i,Lt(re(l,O.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Se(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class ig extends sr{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],U(()=>{this.accBeta1=xe(t).variable(),this.accBeta2=xe(s).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=pe(1,this.accBeta1),r=pe(1,this.accBeta2);t.forEach((o,i)=>{const a=O.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:U(()=>Pe(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:U(()=>Pe(a).variable(l))});const u=Array.isArray(e)?e[i].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedSecondMoment[i].variable,d=re(P(c,this.beta1),P(u,1-this.beta1)),p=re(P(h,this.beta2),P(Ke(u),1-this.beta2)),f=ge(d,s),m=ge(p,r);c.assign(d),h.assign(p);const g=re(P(ge(f,re(Lt(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(P(this.accBeta1,this.beta1)),this.accBeta2.assign(P(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Se(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Se(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),U(()=>{this.accBeta1.assign(As(this.beta1,this.iterations_+1)),this.accBeta2.assign(As(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class ag extends sr{static get className(){return"Adamax"}constructor(e,t,s,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],U(()=>{this.iteration=xe(0).variable(),this.accBeta1=xe(t).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=pe(1,this.accBeta1),r=ge(-this.learningRate,re(P(this.iteration,this.decay),1));t.forEach((o,i)=>{const a=O.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:Pe(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:Pe(a).variable(l)});const u=Array.isArray(e)?e[i].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedWeightedInfNorm[i].variable,d=re(P(c,this.beta1),P(u,1-this.beta1)),p=P(h,this.beta2),f=It(u),m=Fs(p,f);c.assign(d),h.assign(m);const g=re(P(ge(r,s),ge(d,re(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(re(this.iteration,1)),this.accBeta1.assign(P(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Se(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Se(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Ud extends sr{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const i=O.registeredVariables[s];U(()=>{const a=re(P(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=kt(xe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class lg extends Ud{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=xe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=O.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:U(()=>Pe(o).variable(!1))});const i=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&U(()=>{let l;const u=re(P(this.m,i),a);this.useNesterov?l=re(P(this.c,re(a,P(u,this.m))),o):l=re(P(this.c,u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Se(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class ug extends sr{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=O.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=O.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:U(()=>Pe(o).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:U(()=>Pe(o).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:U(()=>Pe(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;U(()=>{const c=re(P(l,this.decay),P(Ke(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,d=re(P(h,this.decay),P(a,1-this.decay)),p=ge(P(a,this.learningRate),Lt(pe(c,re(Ke(d),this.epsilon)))),f=re(P(u,this.momentum),p);l.assign(c),h.assign(d),u.assign(f);const m=pe(o,f);o.assign(m)}else{const h=re(P(l,this.decay),P(Ke(a),1-this.decay)),d=re(P(u,this.momentum),ge(P(a,this.learningRate),Lt(re(h,this.epsilon))));l.assign(h),u.assign(d);const p=pe(o,d);o.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Se(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Se(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Se(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const DD=[rg,og,ig,ag,lg,ug,Ud];function FD(){for(const n of DD)ie(n)}const _D="model",OD=".json",LD=".weights.bin";function cx(n){return new Promise(e=>setTimeout(e)).then(n)}class lo{constructor(e){if(!H().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(lo.URL_SCHEME)&&(e=e.slice(lo.URL_SCHEME.length)),(e==null||e.length===0)&&(e=_D),this.modelJsonFileName=e+OD,this.weightDataFileName=e+LD}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ps.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=fw(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await cx(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await cx(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ou(e)}}}}lo.URL_SCHEME="downloads://";class PD{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),i=o.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=Zf(o,u=>this.loadWeights(u));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const i of e)t.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(o).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((s,r)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;s(a)},o.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(o=>Qb(o.name)),r={};for(const o of e)o.paths.forEach(i=>{const a=Qb(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const zD=n=>H().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(lo.URL_SCHEME)?BD(n.slice(lo.URL_SCHEME.length)):null;lt.registerSaveRouter(zD);function BD(n="model"){return new lo(n)}function MD(n){return new PD(n)}function hx(n,e,t,s){i(n),t=t??0,s=s??1,a(t,s);let r=0;const o=l=>(l.then(u=>{const c=t+ ++r/n.length*(s-t);return e(c),u}),l);function i(l){C(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){C(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),C(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),C(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(o))}async function E1(n,e){e==null&&(e={});const t=e.fetchFunc==null?H().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(s):await hx(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(a):await hx(a,e.onProgress,.5,1)}function VD(n,e){var t;const s=e.fetchFunc==null?H().platform.fetch:e.fetchFunc;let r=0,o;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var a;r<n.length;){o||(o=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await o.read();if(l){r++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,r/n.length);continue}i.enqueue(u);return}i.close()}})}async function A1(n,e="",t,s){return R1(i=>E1(i,{requestInit:s}))(n,e,t)}function R1(n){return async(e,t="",s)=>{const r=e.map(()=>!1),o={},i=s!=null?s.map(()=>!1):[],a=[];if(e.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=eo[y]*X(g.shape),v=()=>{r[f]=!0,o[f]==null&&(o[f]=[]),o[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};s!=null?s.forEach((x,S)=>{x===g.name&&(v(),i[S]=!0)}):v(),a.push(g.name),m+=b})}),!i.every(p=>p)){const p=s.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,f,m)=>(f&&p.push(m),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(f=>{const m=t+(t.endsWith("/")?"":"/")+f;u.push(m)})});const c=await n(u),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length,m=new ps(c.slice(d,d+f));o[p].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),v=Xf(b,[y.manifestEntry]);for(const x in v)h[x]=v[x]}),d+=f}),h}}const WD="application/octet-stream",UD="application/json";class cg{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(C(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=H().platform.fetch,C(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&C(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=fw(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:UD}),"model.json"),e.weightData!=null){const i=ps.join(e.weightData);t.body.append("model.weights.bin",new Blob([i],{type:WD}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:ou(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Zf(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=Tc(e.weightsManifest),r=()=>VD(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=GD(t),o=this.weightPathPrefix||s,i=[],a=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(u)):i.push(o+u+r);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const t=await this.getWeightUrls(e),s=Tc(e),r=await E1(t,this.loadOptions);return[s,r]}}cg.URL_SCHEME_REGEX=/^https?:\/\//;function GD(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function sf(n){return n.match(cg.URL_SCHEME_REGEX)!=null}const D1=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>sf(s)):t=sf(n),t)return hg(n,e)}return null};lt.registerSaveRouter(D1);lt.registerLoadRouter(D1);function hg(n,e){return new cg(n,e)}function F1(n,e){return hg(n,e)}class kp{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class _1{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class HD{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function jD(n,e,t,s){const r=arguments;return new HD(Ac(...r))}function Ac(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new kp(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new kp({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new kp({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function qD(n){return new _1(n)}function KD(n){return new _1(n)}const dg=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:ps,browserFiles:MD,browserHTTPRequest:F1,concatenateArrayBuffers:pw,copyModel:Ck,decodeWeights:Xf,decodeWeightsStream:dw,encodeWeights:Xp,fromMemory:jD,fromMemorySync:Ac,getLoadHandlers:gw,getModelArtifactsForJSON:Zf,getModelArtifactsForJSONSync:Jf,getModelArtifactsInfoForJSON:ou,getSaveHandlers:mw,getWeightSpecs:Tc,http:hg,isHTTPScheme:sf,listModels:Sk,loadWeights:A1,moveModel:kk,registerLoadRouter:dk,registerSaveRouter:hk,removeModel:Nk,weightsLoaderFactory:R1,withSaveHandler:qD,withSaveHandlerSync:KD},Symbol.toStringTag,{value:"Module"}));function XD(n,e,t){const s=T(n,"labels","confusionMatrix"),r=T(e,"predictions","confusionMatrix");C(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),C(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),C(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),C(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),C(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const o=Ho(le(s,"int32"),t),i=Ho(le(r,"int32"),t),a=Oe(o),l=Ae(a,i);return le(l,"int32")}const YD=L({confusionMatrix_:XD});const JD=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:YD},Symbol.toStringTag,{value:"Module"}));let Pr,dx=!1;function O1(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Ma(Cc,O.backendName)!=null){const f={pixels:n},m={numChannels:e};return O.runKernel(Cc,f,m)}const[u,c]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(i)h=n.getContext("2d").getImageData(0,0,u,c).data;else if(s||t)h=n.data;else if(o||r||a){if(Pr==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Pr=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Pr=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Pr.canvas.width=u,Pr.canvas.height=c,Pr.drawImage(n,0,0,u,c),h=Pr.getImageData(0,0,u,c).data}let d;if(e===4)d=new Int32Array(h);else{const f=u*c;d=new Int32Array(f*e);for(let m=0;m<f;m++)for(let g=0;g<e;++g)d[m*e+g]=h[m*4+g]}return qm(d,[c,u,e],"int32")}function ZD(n){return n!=null&&n.data instanceof Uint8Array}function QD(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function eF(n){return n!=null&&n.width!==0&&n.height!==0}function tF(n){return QD()&&!(n instanceof ImageBitmap)&&eF(n)&&!ZD(n)}async function nF(n,e=3){let t=null;if(H().getBool("WRAP_TO_IMAGEBITMAP")&&tF(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return O1(t,e)}function L1(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function sF(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function rF(n,e){let t=T(n,"img","toPixels");if(!(n instanceof ze)){const u=t;t=le(u,"int32"),u.dispose()}L1(t);const[s,r]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2],i=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const c=[0,0,0,255];for(let d=0;d<o;d++){const p=i[u*o+d];if(t.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(t.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);o===1?(c[0]=p*a,c[1]=p*a,c[2]=p*a):c[d]=p*a}const h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(e!=null){dx||Ma(yh,O.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),dx=!0),e.width=r,e.height=s;const u=e.getContext("2d"),c=new ImageData(l,r,s);u.putImageData(c,0,0)}return t!==n&&t.dispose(),l}function oF(n,e,t){let s=T(n,"img","draw");if(!(n instanceof ze)){const i=s;s=le(i,"int32"),i.dispose()}L1(s),sF(t?.imageOptions);const r={image:s},o={canvas:e,options:t};O.runKernel(yh,r,o)}const pg=L({fromPixels_:O1}),iF=Object.freeze(Object.defineProperty({__proto__:null,draw:oF,fromPixels:pg,fromPixelsAsync:nF,toPixels:rF},Symbol.toStringTag,{value:"Module"}));function Gd(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(X(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,o=r[r.length-1];let i=1;for(let h=0;h<r.length-1;++h)i*=r[h];const a=n.shape,l=r.slice();l.pop();let u=1;for(let h=o;h<t;++h)u*=a[h],l.push(a[h]);const c=[...we(n.shape).map(h=>h/u),1].slice(0,o);return[l,i,u,c]}const aF=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:Gd},Symbol.toStringTag,{value:"Module"}));const rf=-2,lF=-1;function fg(n,e,t){const s=n.shape.length;C(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),C(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)C(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function uF(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function mg(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function P1(n,e,t,s){const r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<t;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function z1(n,e,t){return t<=n?t:t-(e-1)}function B1(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function cF(n,e,t,s,r,o,i,a,l){const u=n.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&t>0){const p=e[0],f=t+1;c=M1(i,p,f,s,n),h=V1(a,p,f,r,n),d=P1(o,p,f,n)}else for(let p=0;p<u;p++)c[p]=U1(i,s,o,n,p,l),h[p]=G1(a,r,o,n,p,l),d[p]=W1(o,p,l);return{begin:c,end:h,strides:d}}function M1(n,e,t,s,r){const o=[...r],i=B1(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=z1(e,t,a);let u=s[l];n&1<<l&&(u=0),o[a]=u}return o}function V1(n,e,t,s,r){const o=[...r],i=B1(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=z1(e,t,a);let u=s[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=r[a];o[a]<0&&(o[a]+=l),o[a]=mr(0,o[a],r[a])}return o}function W1(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function U1(n,e,t,s,r,o){let i=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),i=mr(0,i,l-1),i}function G1(n,e,t,s,r,o){let i=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),a>0?i=mr(0,i,l):i=mr(-1,i,l-1),i}function gg(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function yg(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function Hd(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{C(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(r).fill(-1):typeof t=="number"?o=[t,...new Array(r-1).fill(-1)]:t.length<r?o=t.concat(new Array(r-t.length).fill(-1)):o=t,o=o.map((i,a)=>i>=0?i:(C(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,o]}function bg(n,e,t,s,r,o,i,a,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)c&&(1<<v&a)!==0&&h.numAddAxisAfterEllipsis++,1<<v&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};hF(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let v=0;v<n.length;++v){if(d.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);const x=!!(d.shrinkAxisMask&1<<v),S=n[v];if(S===-1){g.push(x?1:-1);continue}const k=[d.beginMask&1<<v,d.endMask&1<<v],D=[d.strides[v]>0?0:-1,d.strides[v]>0?S:S-1];if(x&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[v]===1;const F=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(x){const z=d.begin[v]<0?S+d.begin[v]:d.begin[v];if(d.begin[v]=z,d.end[v]=d.begin[v]+1,z<0||z>=S)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=px(d.begin[v],0,d.strides[v],S,k,D),d.end[v]=px(d.end[v],1,d.strides[v],S,k,D);const N=d.strides[v]===1&&d.begin[v]===0&&d.end[v]===S;p=p&&N,f=f&&(v===0&&d.strides[v]===1||N)}else p=p&&d.strides[v]===1&&F,f=f&&(v===0&&d.strides[v]===1||F);let A,R=!1;if(d.beginValid&&d.endValid?(A=d.end[v]-d.begin[v],R=!0):x?(A=1,R=!0):F&&S>=0&&(d.strides[v]<0?A=-S:A=S,R=!0),R){let N;A===0||A<0!=d.strides[v]<0?N=0:N=Math.trunc(A/d.strides[v])+(A%d.strides[v]!==0?1:0),g.push(N)}else g.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const x=d.finalShapeGatherIndices[v];x>=0?y.push(g[x]):x===rf&&y.push(1)}return{finalShapeSparse:y.filter((v,x)=>d.finalShapeGatherIndices[x]!==rf),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function hF(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(rf),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(lF),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function px(n,e,t,s,r,o){if(r[e])return t>0?o[e]:o[e+1&1];{const i=n<0?s+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const H1=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:fg,computeFlatOffset:yg,computeOutShape:mg,getNormalizedAxes:cF,isSliceContinous:gg,maskToAxes:uF,parseSliceParams:Hd,sliceInfo:bg,startForAxis:U1,startIndicesWithElidedDims:M1,stopForAxis:G1,stopIndicesWithElidedDims:V1,stridesForAxis:W1,stridesWithElidedDims:P1},Symbol.toStringTag,{value:"Module"}));const j1="4.22.0";class q1{static sgd(e){return new Ud(e)}static momentum(e,t,s=!1){return new lg(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,o=!1){return new ug(e,t,s,r,o)}static adam(e=.001,t=.9,s=.999,r=null){return new ig(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new rg(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,o=0){return new ag(e,t,s,r,o)}static adagrad(e,t=.1){return new og(e,t)}}const Mr=q1;const dF=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function xg(){return new Promise(n=>dF(()=>n()))}function wg(n,e){const t=n[0].length;n.forEach((r,o)=>{C(r.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),C(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,o)=>{for(let i=0;i<t;i++)C(i===e||r[i]===s[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Ns(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var rs;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(rs||(rs={}));function K1(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const o=t[r],i=s[s.length-t.length+r],a=s[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${o} but shape[${r+n}] = ${a}`)}else s[i]=o}return s}function X1(n){const e={FIRST_DIM_SIZE:rs.FIRST_DIM_SIZE,VALUE_ROWIDS:rs.VALUE_ROWIDS,ROW_LENGTHS:rs.ROW_LENGTHS,ROW_SPLITS:rs.ROW_SPLITS,ROW_LIMITS:rs.ROW_LIMITS,ROW_STARTS:rs.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function Y1(n){return n.length===0?0:n[0]===rs.FIRST_DIM_SIZE?n.length-1:n.length}function J1(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const o=n[r],i=e[r+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${o} but ragged tensor input.flatValues.shape[${r-n.length}] = ${i}`)}}const vg=30;function jd(n){return n<=vg?n:$c(n,Math.floor(Math.sqrt(n)))}function Ig(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function Su(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const o=e.length;for(let i=0;i<o;++i)r=r.concat([n[i+1]/e[i],e[i]]);r=r.concat(n.slice(o+1))}return r}function Nu(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?o.push(i):r.push(i);s.push(...r),s.push(0),s.push(...o)}return s}function Cu(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?s?r.push(e[o-1]*n[o]):r.push(n[o]/e[o-1]):r.push(n[o]);return r}function $g(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Sg(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const qd=1.7580993408473768,Kd=1.0507009873554805;const Ng=.3275911,Cg=.254829592,kg=-.284496736,Tg=1.421413741,Eg=-1.453152027,Ag=1.061405429;function js(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function Z1(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function Q1(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function ev(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Rg(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function tv(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function nv(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const o=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:t,imag:s}}function sv(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}const Tp="->",pF=/->/g,fx=",",mx="...";function Dg(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(pF,"").length)/Tp.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Tp}").`);const[s,r]=n.split(Tp);C(s.indexOf(mx)===-1,()=>`The ellipsis notation ("${mx}") is not supported yet.`);const o=s.split(fx),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!o.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<s.length;++d){const p=s[d];a.indexOf(p)===-1&&p!==fx&&a.push(p)}const l=new Array(o.length);for(let d=0;d<i;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<o[d].length;++p)l[d].push(a.indexOf(o[d][p]))}const u=a.length,c=r.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function Fg(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function _g(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const o=t[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=o[i]:C(s[e[r][i]]===o[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function Og(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let i=0;i<r;++i)s.push([]);const o=[];for(let i=0;i<t.length;++i){const a=t[i],l=fF(e,a);for(const u of l)o.indexOf(u)===-1&&(s[i].push(u),o.push(u))}return{path:t,steps:s}}function Lg(n){return n.every((e,t)=>e===t)}function fF(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Pg(n,e,t=0){let s=[];if(typeof e=="number")C(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);C(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,l)=>l>0?a+l:a);e[o]=n.shape[t]-i}C(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function rv(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function ov(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function iv(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function av(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function lv(n,e){return`size ${n} must be non-negative, not ${e}`}function uv(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function cv(n,e){const t=X(n),s=X(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function hv(n,e){const t=X(n),s=X(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function of(){return"segment ids must be >= 0"}function dv(){return"segment ids are not increasing"}function pv(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function fv(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function mv(n,e){let t=!1,s;for(n<=vg?(s=n,t=!0):s=$c(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=$c(n,s+1);return s}function gv(n,e,t){const s=[],r=n.length;for(let o=0;o<r;o++)o!==e?s.push(n[o]):s.push(t);return s}function zg(n,e,t,s){const r=e.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=n.shape[t],a=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)a.push(n.shape[h]),u*=n.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=t+1;h<o;h++)a.push(n.shape[h]),c*=n.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}const mF=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:zg,computeOutShape:gv,segOpComputeOptimalWindowSize:mv},Symbol.toStringTag,{value:"Module"}));function qs(n){try{return n.map(e=>Ws(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function yv(n){return n.map(e=>$s(e))}const bv=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Cg,ERF_A2:kg,ERF_A3:Tg,ERF_A4:Eg,ERF_A5:Ag,ERF_P:Ng,PARALLELIZE_THRESHOLD:vg,get RowPartitionType(){return rs},SELU_SCALE:Kd,SELU_SCALEALPHA:qd,applyActivation:zd,assertAndGetBroadcastShape:Ne,assertAxesAreInnerMostDims:Xt,assertParamsConsistent:wg,assignToTypedArray:tv,axesAreInnerMostDims:Cm,calculateShapes:Fr,checkEinsumDimSizes:_g,checkPadOnDimRoundingMode:an,combineLocations:Rw,combineRaggedTensorToTensorShapes:K1,complexWithEvenIndex:Q1,complexWithOddIndex:ev,computeConv2DInfo:zt,computeConv3DInfo:Tr,computeDefaultPad:lm,computeDilation2DInfo:iu,computeOptimalWindowSize:jd,computeOutAndReduceShapes:Bt,computeOutShape:Ns,computePool2DInfo:Xn,computePool3DInfo:Zs,convertConv2DDataFormat:Qs,decodeEinsumEquation:Dg,eitherStridesOrDilationsAreOne:Kt,expandShapeToKeepDim:yt,exponent:sv,exponents:nv,fromStringArrayToUint8:yv,fromUint8ToStringArray:qs,getAxesPermutation:dt,getBroadcastDims:oo,getComplexWithIndex:Rg,getEinsumComputePath:Og,getEinsumPermutation:Fg,getFusedBiasGradient:Pd,getFusedDyActivation:Ld,getImageCenter:Ig,getInnerMostAxes:bt,getPermuted:Nu,getRaggedRank:Y1,getReductionAxes:Nt,getReshaped:Su,getReshapedPermuted:Cu,getRowPartitionTypesHelper:X1,getSliceBeginCoords:$g,getSliceSize:Sg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:rv,getSparseFillEmptyRowsNegativeIndexErrorMessage:ov,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:iv,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:uv,getSparseReshapeInputOutputMismatchErrorMessage:hv,getSparseReshapeInputOutputMultipleErrorMessage:cv,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:av,getSparseReshapeNegativeOutputDimErrorMessage:lv,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:fv,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:of,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:dv,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:pv,getUndoAxesPermutation:Er,isIdentityPermutation:Lg,log:dC,mergeRealAndImagArrays:js,prepareAndValidate:Gd,prepareSplitSize:Pg,segment_util:mF,shouldFuse:Bd,slice_util:H1,splitRealAndImagArrays:Z1,stridesOrDilationsArePositive:ro,tupleValuesAreOne:br,upcastType:pn,validateDefaultValueShape:J1,validateInput:Rd,validateUpdateShape:Km,warn:Fn},Symbol.toStringTag,{value:"Module"}));const gF=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Md,nonMaxSuppressionV4Impl:Vd,nonMaxSuppressionV5Impl:Wd,whereImpl:_d},Symbol.toStringTag,{value:"Module"}));FD();const xv={kernelName:tl,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,So(le(t,"float32"),-1))}}};const yF={kernelName:ti,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ke(le(t,"float32")),r=Lt(pe(xe(1),s));return tt(ge(n,r))}}}};const bF={kernelName:ni,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Lt(pe(Ke(le(t,"float32")),1));return ge(n,s)}}}};const xF={kernelName:vo,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{let a=n;const l=Nt(t.shape,r);return l.length>0&&(a=fe(a,l)),B(a,t.shape)},b:()=>{let a=n;const l=Nt(s.shape,r);return l.length>0&&(a=fe(a,l)),B(a,s.shape)}}}};const wF={kernelName:nl,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const vF={kernelName:sl,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(t)}}};const IF={kernelName:rl,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(t)}}};const $F={kernelName:si,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,Lt(pe(xe(1),Ke(le(t,"float32")))))}}};const SF={kernelName:ri,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Lt(re(xe(1),Ke(le(t,"float32"))));return ge(n,s)}}}};const NF={kernelName:ai,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{const a=re(Ke(t),Ke(s));let l=P(n,ge(s,a));const u=Nt(t.shape,r);return u.length>0&&(l=fe(l,u)),B(l,t.shape)},b:()=>{const a=re(Ke(t),Ke(s));let l=tt(P(n,ge(t,a)));const u=Nt(s.shape,r);return u.length>0&&(l=fe(l,u)),B(l,s.shape)}}}};const CF={kernelName:oi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,re(Ke(le(t,"float32")),1))}}};const kF={kernelName:ii,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,pe(xe(1),Ke(le(t,"float32"))))}}};function TF(n,e,t,s,r,o){const i=T(n,"dy","avgPool3dGrad"),a=T(e,"input","avgPool3dGrad");let l=i,u=a,c=!1;a.rank===4&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=B(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),C(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),C(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),an("avgPool3dGrad",r,o);const h={dy:l,input:u},d={filterSize:t,strides:s,pad:r,dimRoundingMode:o},p=O.runKernel(sh,h,d);return c?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const EF=L({avgPool3dGrad_:TF});const AF={kernelName:il,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:o,pad:i,dimRoundingMode:a}=t;return{x:()=>EF(n,s,r,o,i,a)}}};function RF(n,e,t,s,r){const o=T(n,"dy","avgPoolGrad"),i=T(e,"input","avgPoolGrad");C(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;i.rank===3&&(u=!0,a=B(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),C(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:t,strides:s,pad:r},d=O.runKernel(nh,c,h);return u?B(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const DF=L({avgPoolGrad_:RF});const FF={kernelName:ol,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:o,pad:i}=t;return{x:()=>DF(n,s,r,o,i)}}};const _F={kernelName:al,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:o,transposeB:i}=t;return!o&&!i?{a:()=>Ae(n,r,!1,!0),b:()=>Ae(s,n,!0,!1)}:!o&&i?{a:()=>Ae(n,r,!1,!1),b:()=>Ae(n,s,!0,!1)}:o&&!i?{a:()=>Ae(r,n,!1,!0),b:()=>Ae(s,n,!1,!1)}:{a:()=>Ae(r,n,!0,!0),b:()=>Ae(n,s,!0,!0)}}};const OF={kernelName:ll,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>yu(n,s,r)}}};const LF={kernelName:q0,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,o=s.shape,i=Array.from(o);for(let l=r.length-1;l>=0;l--)if(r[l]===o[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>fe(n,a,!0)}}};const PF={kernelName:li,gradFunc:n=>({x:()=>n.clone()})};const zF={kernelName:ui,gradFunc:n=>({x:()=>Pe(n)})};const BF={kernelName:ci,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:o}=t;return{x:()=>_t(Kn(er(s,r),Ar(s,o)),n,Pe(n))}}};const MF={kernelName:cl,inputsToSave:["x"],gradFunc:xv.gradFunc};const VF={kernelName:hl,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,o=Re(r,e[0].shape)[0],i=s.map(l=>l[o]);return dn(n,i,o).map(l=>()=>l)}};const WF={kernelName:dl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:o,strides:i,pad:a,dataFormat:l}=t;return C(br(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>xm(s.shape,n,r,i,a,l),filter:()=>tg(s,n,r.shape,i,a,l)}}};const UF={kernelName:pl,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>Hs(n,r,o,i,a,1,l),filter:()=>tg(n,s,r.shape,o,i,a,l)}}};function GF(n,e,t,s,r){let o=n;n.rank===4&&(o=B(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=e;i.rank===4&&(i=B(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),C(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),C(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),C(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),C(o.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${t[3]}.`),C(i.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:o,dy:i},l={strides:s,pad:r,filterShape:t};return O.runKernel(lh,a,l)}const HF=L({conv3DBackpropFilter_:GF});const jF={kernelName:fl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:o}=t;C(br(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,a]=e;return{x:()=>Tw(i.shape,n,a,r,o),filter:()=>HF(i,n,a.shape,r,o)}}};const qF={kernelName:hi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(tt(Cd(le(t,"float32"))),n)}}};const KF={kernelName:di,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(kd(le(t,"float32")),n)}}};const XF={kernelName:ml,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:o,reverse:i}=t;return{x:()=>{const a=dt([r],s.rank);let l=pd(n,r,o,!i);return a!=null&&(l=Oe(l,a)),l}}}};const YF={kernelName:gl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:o,dimRoundingMode:i}=t,a=s??[1,1];C(br(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return C(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),C(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),C(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),C(Kt(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),an("depthwiseConv2d",o,i),{x:()=>b1(l.shape,n,u,r,o,a,i),filter:()=>y1(l,n,u.shape,r,o,a,i)}}};const JF={kernelName:yl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,o={x:s,filter:r,dy:n},i={x:s,filter:r,dy:n};return{x:()=>O.runKernel(Sc,o,t),filter:()=>O.runKernel(Nc,i,t)}}};const ZF={kernelName:fi,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>O.runKernel(xh,s)}}};const QF={kernelName:mi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=P(gn(tt(Ke(t))),2/Math.sqrt(Math.PI));return{x:()=>P(n,s)}}};const e_={kernelName:gi,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,t)}}};const t_={kernelName:xl,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>B(n,t.shape)}}};const n_={kernelName:yi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,gn(t))}}};const s_={kernelName:bi,gradFunc:n=>({x:()=>Pe(n)})};const r_={kernelName:xi,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{const a=ge(n,le(s,"float32")),l=Nt(t.shape,r);return l.length>0?B(fe(a,l),t.shape):a},b:()=>{let a=P(n,le(t,"float32"));const l=Nt(s.shape,r);l.length>0&&(a=B(fe(a,l),s.shape));const u=Ke(s);return tt(ge(a,le(u,"float32")))}}}};const o_={kernelName:wl,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,o,i,a]=e,l=a??xe(1),u=Nt(o.shape,r.shape),c=[];if(o.rank===1){for(let x=0;x<r.shape.length-1;++x)c.push(r.shape[x]);c.push(1)}const h=pe(r,o),d=P(n,l),p=$d(re(i,xe(s))),f=P(P(P(p,p),p),xe(-.5));return{x:()=>o.rank===1?B(P(P(n,On(B(p,[1,1,1,o.shape[0]]),c)),l),r.shape):B(P(P(n,p),l),r.shape),mean:()=>{let x=P(P(p,xe(-1)),d);return o.rank===1&&(x=fe(x,u)),B(x,o.shape)},variance:()=>{let x=P(P(f,h),d);return o.rank===1&&(x=fe(x,u)),B(x,o.shape)},scale:()=>{const x=P(h,p);let S=P(n,x);return o.rank===1&&(S=fe(S,u)),B(S,o.shape)},offset:()=>{let x=n;return o.rank===1&&(x=fe(x,u)),B(x,o.shape)}}}};const i_={kernelName:vl,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:o,batchDims:i}=t,a=Re(o,s.shape)[0],l=(u,c,h)=>()=>{const d=u.shape,p=c.size,f=d.slice(0,a),m=f.length,g=d.slice(o,d.length).slice(1),y=g.length,b=gx(0,m),v=gx(m+1,m+1+y),x=yx([f,[p],g]),S=B(h,x),k=B(c,[p]),D=yx([[m],b,v]),F=Oe(S,D);let A=Fd(F,k,u.shape[a]);const R=Er(D);return A=Oe(A,R),A};if(i===1){const u=s.shape[0],c=s.split(u,0);return{x:()=>rn(c.map((p,f)=>l(p,r.slice(f,1),n.slice(f,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function gx(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function yx(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const a_={kernelName:wi,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Pe(t),b:()=>Pe(s)}}};const l_={kernelName:vi,gradFunc:n=>({x:()=>le(n,"float32")})};const u_={kernelName:Ii,gradFunc:n=>({x:()=>Pe(n)})};const c_={kernelName:$i,gradFunc:n=>({x:()=>Pe(n)})};const h_={kernelName:Si,gradFunc:n=>({x:()=>Pe(n)})};const d_={kernelName:$l,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,o=ln(s,0);return{x:()=>_t(o,n,P(n,r))}}};const p_={kernelName:Ci,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,re(t,1))}}};const f_={kernelName:Ni,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,le(t,"float32"))}}};const m_={kernelName:K0,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const i=gn(s);return pe(n,P(fe(n,r,!0),i))}}}};function g_(n,e,t,s=5,r=1,o=1,i=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:o,beta:i};return O.runKernel(kh,a,l)}const y_=L({localResponseNormalizationBackprop_:g_});const b_={kernelName:El,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:o,bias:i,alpha:a,beta:l}=t;return{x:()=>y_(s,r,n,o,i,a,l)}}};function wv(n,e,t,s){return e.rank<t.rank&&(e=B(e,yt(e.shape,s))),n.rank<t.rank&&(n=B(n,yt(n.shape,s))),{x:()=>P(n,le(Nn(t,e),n.dtype))}}const bx={kernelName:Al,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,o=e[0],i=e[1],a=Re(r,o.shape),l=wv(n,i,o,a);return{x:()=>l.x()}}};const x_={kernelName:ki,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>P(n,le(er(t,s),"float32")),b:()=>P(n,le(Go(t,s),"float32"))}}};function w_(n,e,t,s,r,o,i){const a=T(n,"dy","maxPool3dGrad"),l=T(e,"input","maxPool3dGrad"),u=T(t,"output","maxPool3dGrad");let c=a,h=l,d=u,p=!1;l.rank===4&&(p=!0,c=B(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=B(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=B(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),C(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),C(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),C(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),an("maxPool3dGrad",o,i);const f={dy:c,input:h,output:d},m={filterSize:s,strides:r,pad:o,dimRoundingMode:i},g=O.runKernel(Eh,f,m);return p?B(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const v_=L({maxPool3dGrad_:w_});const I_={kernelName:Dl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=t;return{x:()=>v_(n,s,r,o,i,a,l)}}};function $_(n,e,t,s,r,o,i){const a=T(n,"dy","maxPoolGrad"),l=T(e,"input","maxPoolGrad"),u=T(t,"output","maxPoolGrad");C(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),C(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),C(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),an("maxPoolGrad",o,i);const c={dy:a,input:l,output:u},h={filterSize:s,strides:r,pad:o,dimRoundingMode:i};return O.runKernel(Th,c,h)}const S_=L({maxPoolGrad_:$_});const N_={kernelName:Rl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:o,strides:i,pad:a}=t;return{x:()=>S_(n,s,r,o,i,a)}}};const C_={kernelName:Fl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,o=Re(r,s.shape),a=Bt(s.shape,o)[1],l=X(a);return{x:()=>{const c=s.shape.slice();o.forEach(p=>{c[p]=1});const h=B(n,c);return ge(P(h,hn(s.shape,"float32")),l)}}}};const k_={kernelName:_l,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[o,i]=e,a=Re(r,o.shape),l=wv(n,i,o,a);return{x:()=>l.x()}}};const T_={kernelName:Ti,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>P(n,le(Ar(t,s),"float32")),b:()=>P(n,le(ln(t,s),"float32"))}}};const E_={kernelName:Ol,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,o=r.map(i=>i[0]);return{x:()=>Le(n,o,s.shape)}}};const A_={kernelName:Ei,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{const a=Nt(t.shape,r);return a.length>0?B(fe(n,a),t.shape):n},b:()=>{const a=P(n,tt(ea(ge(t,s)))),l=Nt(s.shape,r);return l.length>0?B(fe(a,l),s.shape):a}}}};const R_={kernelName:Ai,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{const a=P(n,le(s,"float32")),l=Nt(t.shape,r);return l.length>0?B(fe(a,l),t.shape):a},b:()=>{const a=P(n,le(t,"float32")),l=Nt(s.shape,r);return l.length>0?B(fe(a,l),s.shape):a}}}};const D_={kernelName:Ll,gradFunc:n=>({x:()=>tt(n)})};const F_={kernelName:Bl,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>mt(t.shape,"float32")}}};const __={kernelName:zl,gradFunc:n=>({x:()=>Pe(n)})};const O_={kernelName:Ml,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Wn(n,s).map(o=>()=>o)}};const xx={kernelName:Vl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,o=r.map(i=>i[0]);return{x:()=>Le(n,o,s.shape)}}};const L_={kernelName:Ri,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,o=t,i=s,a=Ne(o.shape,i.shape);return{a:()=>{const c=le(i,"float32");let h=P(n,P(c,As(o,pe(c,xe(1)))));const d=Nt(o.shape,a);return d.length>0&&(h=fe(h,d)),B(h,o.shape)},b:()=>{const c=ln(o,0),h=_t(c,Cn(o),Pe(o));let d=P(n,P(r,h));const p=Nt(i.shape,a);return p.length>0&&(d=fe(d,p)),B(d,i.shape)}}}};const P_={kernelName:Wl,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=ln(t,0);return{x:()=>_t(r,n,P(n,s)),alpha:()=>{let o=_t(r,Pe(n),P(n,t));const i=Nt(s.shape,n.shape);return i.length>0&&(o=fe(o,i)),B(o,s.shape)}}}};function z_(n,e,t){const s=n.shape.slice();s[t]=1;const r=B(e,s),o=ja(n,t,!0,!1),i=ja(n,t,!0,!0),a=P(o,i);return P(r,a)}function B_(n,e,t){const s=n.shape.length,r=s-t.length,o=dt(t,s);let i=n;o!=null&&(i=Oe(n,o));const a=i.shape.slice(),u=a.splice(s-t.length,t.length).reduce((d,p)=>d*p,1);a.push(u);const c=i.reshape(a);let h=z_(c,e,r);if(h=h.reshape(i.shape),o!=null){const d=Er(o);h=Oe(h,d)}return h}const M_={kernelName:Ul,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let o=[];return r==null?o=s.shape.map((i,a)=>a):typeof r=="number"?o=[r]:o=r,{x:()=>B_(s,n,o)}}};const V_={kernelName:pi,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{const a=ge(n,le(s,"float32")),l=Nt(t.shape,r);return l.length>0?B(fe(a,l),t.shape):a},b:()=>{let a=P(n,le(t,"float32"));const l=Nt(s.shape,r);l.length>0&&(a=B(fe(a,l),s.shape));const u=Ke(s);return tt(ge(a,le(u,"float32")))}}}};const W_={kernelName:Di,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,tt(Ke(t)))}}};const U_={kernelName:_i,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=P(Ar(t,6),So(t));return{x:()=>P(n,le(s,"float32"))}}};const G_={kernelName:Fi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,le(So(t),"float32"))}}};const H_={kernelName:Gl,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>B(n,t.shape)}}};const j_={kernelName:jl,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>O.runKernel(Vh,r,t)}}};const q_={kernelName:Hl,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>O.runKernel(Mh,r,t)}}};const K_={kernelName:ql,gradFunc:(n,e,t)=>{const{dims:s}=t,r=Re(s,n.shape);return{x:()=>Vn(n,r)}}};const X_={kernelName:Oi,gradFunc:n=>({x:()=>Pe(n)})};const Y_={kernelName:Li,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>tt(ge(n,P(As(t,1.5),2)))}}};const J_={kernelName:Kl,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>le(Pe(t),"float32"),t:()=>P(n,le(t,n.dtype)),e:()=>P(n,le(fu(t),n.dtype))}}};const Z_={kernelName:Pi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=ln(t,xe(0)),r=xe(qd),o=xe(Kd),i=P(n,o),a=P(P(n,r),gn(le(t,"float32")));return _t(s,i,a)}}}};const Q_={kernelName:Vi,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,P(t,pe(xe(1),t)))}}};const eO={kernelName:Mi,gradFunc:n=>({x:()=>Pe(n)})};const tO={kernelName:zi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(uu(le(t,"float32")),n)}}};const nO={kernelName:Bi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(dd(le(t,"float32")),n)}}};const sO={kernelName:Xl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:o}=t,i=s.shape,[a,l]=Hd(s,r,o),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>tr(n,u)}}};const rO={kernelName:Ql,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,o=!0,i=P(n,s);return{logits:()=>pe(i,P(fe(i,[r],o),s))}}};const oO={kernelName:Wi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,is(t))}}};const wx={kernelName:Jl,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>lu(n,s,r)}}};const vx={kernelName:Zl,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>gt(n,s)}}};const iO={kernelName:Ui,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,P(Lt(le(t,"float32")),2))}}};const aO={kernelName:Yh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,P(le(t,"float32"),2))}}};const lO={kernelName:Gi,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(2);return{a:()=>P(n,P(r,pe(t,s))),b:()=>P(n,P(r,pe(s,t)))}}};const uO={kernelName:Xi,gradFunc:n=>({x:()=>Pe(n)})};const cO={kernelName:Hi,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ne(t.shape,s.shape);return{a:()=>{let a=n;const l=Nt(t.shape,r);return l.length>0&&(a=fe(a,l)),B(a,t.shape)},b:()=>{let a=n;const l=Nt(s.shape,r);return l.length>0&&(a=fe(a,l)),B(tt(a),s.shape)}}}};const hO={kernelName:Yl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:o}=t;Re(o,s.shape).forEach(u=>{r[u]=1});const a=B(n,r),l=P(a,hn(s.shape,"float32"));return{x:()=>l}}};const dO={kernelName:ji,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ge(n,Ke(uu(t)))}}};const pO={kernelName:qi,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(pe(xe(1),Ke(t)),n)}}};const fO={kernelName:Ki,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let i=Pe(s);if(s.rank===1)for(let a=0;a<r[0];++a)i=re(i,Le(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)i=re(i,Le(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)i=re(i,Le(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)i=re(i,Le(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return i}}}};const mO={kernelName:Xr,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,o=Er(r);return{x:()=>Oe(n,o)}}};const gO={kernelName:tu,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>rn(n,r)}}};const yO={kernelName:nu,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bO(n,t)}}};function bO(n,e){const t=Fs(e,Pe(e)),s=ta(n,t);let r=er(e,xe(0,"int32"));const o=s.rank-r.rank;for(let a=0;a<o;++a)r=Wt(r,a+1);r=Kn(r,hn(s.shape,"bool"));const i=Pe(s);return _t(r,s,i)}const xO={kernelName:su,gradFunc:n=>({x:()=>Pe(n)})};const wO=[xv,yF,bF,xF,wF,vF,IF,$F,SF,NF,CF,kF,AF,FF,_F,OF,LF,PF,zF,BF,MF,VF,UF,WF,jF,qF,KF,XF,YF,JF,V_,ZF,QF,e_,t_,n_,r_,s_,o_,i_,a_,l_,u_,c_,h_,d_,p_,f_,m_,b_,bx,bx,x_,I_,N_,C_,k_,T_,E_,A_,R_,D_,F_,__,O_,xx,xx,L_,P_,M_,W_,U_,G_,H_,j_,q_,K_,X_,Y_,J_,Z_,Q_,eO,tO,nO,sO,rO,oO,wx,wx,vx,vx,iO,lO,aO,uO,cO,hO,dO,pO,fO,mO,gO,yO,xO];for(const n of wO)X0(n);Z().prototype.abs=function(){return this.throwIfDisposed(),It(this)};Z().prototype.acos=function(){return this.throwIfDisposed(),em(this)};Z().prototype.acosh=function(){return this.throwIfDisposed(),tm(this)};Z().prototype.add=function(n){return this.throwIfDisposed(),re(this,n)};Z().prototype.all=function(n,e){return this.throwIfDisposed(),ud(this,n,e)};Z().prototype.any=function(n,e){return this.throwIfDisposed(),Ua(this,n,e)};Z().prototype.argMax=function(n){return this.throwIfDisposed(),so(this,n)};Z().prototype.argMin=function(n){return this.throwIfDisposed(),nm(this,n)};Z().prototype.asScalar=function(){return this.throwIfDisposed(),C(this.size===1,()=>"The array must have only 1 element."),B(this,[])};Z().prototype.asType=function(n){return this.throwIfDisposed(),le(this,n)};Z().prototype.as1D=function(){return this.throwIfDisposed(),B(this,[this.size])};Z().prototype.as2D=function(n,e){return this.throwIfDisposed(),B(this,[n,e])};Z().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),B(this,[n,e,t])};Z().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),B(this,[n,e,t,s])};Z().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),B(this,[n,e,t,s,r])};Z().prototype.asin=function(){return this.throwIfDisposed(),sm(this)};Z().prototype.asinh=function(){return this.throwIfDisposed(),rm(this)};Z().prototype.atan=function(){return this.throwIfDisposed(),om(this)};Z().prototype.atan2=function(n){return this.throwIfDisposed(),im(this,n)};Z().prototype.atanh=function(){return this.throwIfDisposed(),am(this)};Z().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),au(this,n,e,t,s)};Z().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),lu(this,n,e)};Z().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Yi(this,n,e,t,s,r)};Z().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Yr(this,n)};Z().prototype.cast=function(n){return this.throwIfDisposed(),le(this,n)};Z().prototype.ceil=function(){return this.throwIfDisposed(),fm(this)};Z().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),mn(this,n,e)};Z().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof ze&&(n=[n]),gt([this,...n],e)};Z().prototype.conv1d=function(n,e,t,s,r,o){return this.throwIfDisposed(),cd(this,n,e,t,s,r,o)};Z().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),hd(this,n,e,t,s,r)};Z().prototype.conv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),Hs(this,n,e,t,s,r,o)};Z().prototype.cos=function(){return this.throwIfDisposed(),uu(this)};Z().prototype.cosh=function(){return this.throwIfDisposed(),dd(this)};Z().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),ja(this,n,e,t)};Z().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),pd(this,n,e,t)};Z().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),Im(this,n,e)};Z().prototype.depthwiseConv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),Ji(this,n,e,t,s,r,o)};Z().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),$m(this,n,e,t,s,r)};Z().prototype.divNoNan=function(n){return this.throwIfDisposed(),Sm(this,n)};Z().prototype.div=function(n){return this.throwIfDisposed(),ge(this,n)};Z().prototype.dot=function(n){return this.throwIfDisposed(),Nm(this,n)};Z().prototype.elu=function(){return this.throwIfDisposed(),Zi(this)};Z().prototype.equal=function(n){return this.throwIfDisposed(),Nn(this,n)};Z().prototype.erf=function(){return this.throwIfDisposed(),fd(this)};Z().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),km(this,n,e)};Z().prototype.exp=function(){return this.throwIfDisposed(),gn(this)};Z().prototype.expandDims=function(n){return this.throwIfDisposed(),Wt(this,n)};Z().prototype.expm1=function(){return this.throwIfDisposed(),Tm(this)};Z().prototype.fft=function(){return this.throwIfDisposed(),Iu(this)};Z().prototype.flatten=function(){return this.throwIfDisposed(),B(this,[this.size])};Z().prototype.floor=function(){return this.throwIfDisposed(),ea(this)};Z().prototype.floorDiv=function(n){return this.throwIfDisposed(),ld(this,n)};Z().prototype.gather=function(n,e,t){return this.throwIfDisposed(),ta(this,n,e,t)};Z().prototype.greaterEqual=function(n){return this.throwIfDisposed(),er(this,n)};Z().prototype.greater=function(n){return this.throwIfDisposed(),ln(this,n)};Z().prototype.ifft=function(){return this.throwIfDisposed(),Ko(this)};Z().prototype.irfft=function(){return this.throwIfDisposed(),Ed(this)};Z().prototype.isFinite=function(){return this.throwIfDisposed(),Em(this)};Z().prototype.isInf=function(){return this.throwIfDisposed(),Am(this)};Z().prototype.isNaN=function(){return this.throwIfDisposed(),Rm(this)};Z().prototype.leakyRelu=function(n){return this.throwIfDisposed(),hu(this,n)};Z().prototype.lessEqual=function(n){return this.throwIfDisposed(),Ar(this,n)};Z().prototype.less=function(n){return this.throwIfDisposed(),Go(this,n)};Z().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),Dm(this,n,e,t,s)};Z().prototype.logSigmoid=function(){return this.throwIfDisposed(),Fm(this)};Z().prototype.logSoftmax=function(n){return this.throwIfDisposed(),yd(this,n)};Z().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),pu(this,n,e)};Z().prototype.log=function(){return this.throwIfDisposed(),Cn(this)};Z().prototype.log1p=function(){return this.throwIfDisposed(),du(this)};Z().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Kn(this,n)};Z().prototype.logicalNot=function(){return this.throwIfDisposed(),fu(this)};Z().prototype.logicalOr=function(n){return this.throwIfDisposed(),bd(this,n)};Z().prototype.logicalXor=function(n){return this.throwIfDisposed(),_m(this,n)};Z().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Ae(this,n,e,t)};Z().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),mu(this,n,e,t,s)};Z().prototype.max=function(n,e){return this.throwIfDisposed(),Mn(this,n,e)};Z().prototype.maximum=function(n){return this.throwIfDisposed(),Fs(this,n)};Z().prototype.mean=function(n,e){return this.throwIfDisposed(),ut(this,n,e)};Z().prototype.min=function(n,e){return this.throwIfDisposed(),Uo(this,n,e)};Z().prototype.minimum=function(n){return this.throwIfDisposed(),wr(this,n)};Z().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),Lm(this,n,e)};Z().prototype.mod=function(n){return this.throwIfDisposed(),Pm(this,n)};Z().prototype.mul=function(n){return this.throwIfDisposed(),P(this,n)};Z().prototype.neg=function(){return this.throwIfDisposed(),tt(this)};Z().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Qi(this,n,e,t)};Z().prototype.notEqual=function(n){return this.throwIfDisposed(),io(this,n)};Z().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Ho(this,n,e,t)};Z().prototype.onesLike=function(){return this.throwIfDisposed(),kn(this)};Z().prototype.pad=function(n,e){return this.throwIfDisposed(),tr(this,n,e)};Z().prototype.pool=function(n,e,t,s,r,o){return this.throwIfDisposed(),zm(this,n,e,t,s,r,o)};Z().prototype.pow=function(n){return this.throwIfDisposed(),As(this,n)};Z().prototype.prelu=function(n){return this.throwIfDisposed(),bu(this,n)};Z().prototype.prod=function(n,e){return this.throwIfDisposed(),Bm(this,n,e)};Z().prototype.reciprocal=function(){return this.throwIfDisposed(),Um(this)};Z().prototype.relu=function(){return this.throwIfDisposed(),fs(this)};Z().prototype.relu6=function(){return this.throwIfDisposed(),vd(this)};Z().prototype.reshapeAs=function(n){return this.throwIfDisposed(),B(this,n.shape)};Z().prototype.reshape=function(n){return this.throwIfDisposed(),B(this,n)};Z().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),I1(this,n,e,t)};Z().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),$1(this,n,e,t)};Z().prototype.reverse=function(n){return this.throwIfDisposed(),Vn(this,n)};Z().prototype.rfft=function(){return this.throwIfDisposed(),$u(this)};Z().prototype.round=function(){return this.throwIfDisposed(),Id(this)};Z().prototype.rsqrt=function(){return this.throwIfDisposed(),$d(this)};Z().prototype.selu=function(){return this.throwIfDisposed(),Sd(this)};Z().prototype.separableConv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),Nd(this,n,e,t,s,r,o)};Z().prototype.sigmoid=function(){return this.throwIfDisposed(),is(this)};Z().prototype.sign=function(){return this.throwIfDisposed(),Gm(this)};Z().prototype.sin=function(){return this.throwIfDisposed(),Cd(this)};Z().prototype.sinh=function(){return this.throwIfDisposed(),kd(this)};Z().prototype.slice=function(n,e){return this.throwIfDisposed(),Le(this,n,e)};Z().prototype.softmax=function(n){return this.throwIfDisposed(),vu(this,n)};Z().prototype.softplus=function(){return this.throwIfDisposed(),$o(this)};Z().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),yu(this,n,e)};Z().prototype.split=function(n,e){return this.throwIfDisposed(),dn(this,n,e)};Z().prototype.sqrt=function(){return this.throwIfDisposed(),Lt(this)};Z().prototype.square=function(){return this.throwIfDisposed(),Ke(this)};Z().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Ad(this,n)};Z().prototype.squeeze=function(n){return this.throwIfDisposed(),Dr(this,n)};Z().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof ze?[this,n]:[this,...n];return rn(t,e)};Z().prototype.step=function(n){return this.throwIfDisposed(),So(this,n)};Z().prototype.stridedSlice=function(n,e,t,s,r,o,i,a){return this.throwIfDisposed(),Hm(this,n,e,t,s,r,o,i,a)};Z().prototype.sub=function(n){return this.throwIfDisposed(),pe(this,n)};Z().prototype.sum=function(n,e){return this.throwIfDisposed(),fe(this,n,e)};Z().prototype.tan=function(){return this.throwIfDisposed(),jm(this)};Z().prototype.tanh=function(){return this.throwIfDisposed(),xr(this)};Z().prototype.tile=function(n){return this.throwIfDisposed(),On(this,n)};Z().prototype.toBool=function(){return this.throwIfDisposed(),le(this,"bool")};Z().prototype.toFloat=function(){return this.throwIfDisposed(),le(this,"float32")};Z().prototype.toInt=function(){return this.throwIfDisposed(),le(this,"int32")};Z().prototype.topk=function(n,e){return this.throwIfDisposed(),Xm(this,n,e)};Z().prototype.transpose=function(n){return this.throwIfDisposed(),Oe(this,n)};Z().prototype.unique=function(n){return this.throwIfDisposed(),Ym(this,n)};Z().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Fd(this,n,e)};Z().prototype.unstack=function(n){return this.throwIfDisposed(),Wn(this,n)};Z().prototype.where=function(n,e){return this.throwIfDisposed(),_t(n,this,e)};Z().prototype.zerosLike=function(){return this.throwIfDisposed(),Pe(this)};class bs extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bs.prototype)}}class qn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,qn.prototype)}}class M extends Error{constructor(e){super(e),Object.setPrototypeOf(this,M.prototype)}}class Te extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Te.prototype)}}class Bg extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Bg.prototype)}}class vv{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function uo(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function xs(n,e){if(!n)throw new Bg(e)}function Ix(n,e){let t=0;for(const s of n)s===e&&t++;return t}function cn(n){return n.length===1?n[0]:n}function Ge(n){return Array.isArray(n)?n:[n]}function Os(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Ur(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Gn={};function Mg(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function af(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>af(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:af(s))}}}function ku(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const o=n;let i;if(o in t)i=t[o];else if(o in Gn)i=Gn[o];else if(i=e[o],i==null)throw new M(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const o=n;if(o.className==null||o.config==null)throw new M(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const i=o.className;let a,l;if(i in t?[a,l]=t[i]:i in Gn?[a,l]=Gn.className:i in e&&([a,l]=e[i]),a==null)throw new M(`Unknown ${s}: ${i}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Gn))u[p]=Gn[p];for(const p of Object.keys(t))u[p]=t[p];const c=o.config;c.customObjects=u;const h=Object.assign({},Gn);for(const p of Object.keys(t))Gn[p]=t[p];af(o.config);const d=l(a,o.config,t,r);return Gn=Object.assign({},h),d}else{const u=Object.assign({},Gn);for(const h of Object.keys(t))Gn[h]=t[h];const c=new a(o.config);return Gn=Object.assign({},u),c}}}function vO(n,e){return n<e?-1:n>e?1:0}function Hu(n,e){return-1*vO(n,e)}function pr(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function IO(n){if(n==null)throw new M(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Co(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new M(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Vg(n,e,t=0,s=1/0){return xs(t>=0),xs(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Ft(n,e){Array.isArray(n)?(C(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Ft(t,`element ${s+1} of ${e}`))):C(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Iv(n)}.`)}function Iv(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Iv(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function $O(n,e,t){let s=t!=null?t():Vt(),r;return(...i)=>{const a=t!=null?t():Vt();return a-s<e||(s=a,r=n(...i)),r}}function $v(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let SO=0;function Sv(){return SO++}const ju={};function Xd(n=""){return n in ju||(ju[n]=0),ju[n]+=1,n+ju[n].toString()}const NO=["channelsFirst","channelsLast"],CO=["nearest","bilinear"],kO=["valid","same","causal"],TO=["max","avg"],EO=["sum","mul","concat","ave"];const Fo=new Map;function xt(n){Co(NO,"DataFormat",n)}function AO(n){Co(CO,"InterpolationFormat",n)}function Un(n){Co(kO,"PaddingMode",n)}function Nv(n){Co(TO,"PoolMode",n)}const _a=[],$x="/";function Jr(n,e){_a.push(n);try{const t=e();return _a.pop(),t}catch(t){throw _a.pop(),t}}function RO(){return _a.length===0?"":_a.join($x)+$x}function Cv(n){if(!Tv(n))throw new Error("Not a valid tensor name: '"+n+"'");return RO()+n}function kv(n){if(!Tv(n))throw new Error("Not a valid tensor name: '"+n+"'");Fo.has(n)||Fo.set(n,0);const e=Fo.get(n);if(Fo.set(n,Fo.get(n)+1),e>0){const t=`${n}_${e}`;return Fo.set(t,1),t}else return n}const DO=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Tv(n){return!!n.match(DO)}function FO(n){return n===parseInt(n.toString(),10)}function fr(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Xo(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function vr(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function us(n,e){if(e<n)throw new M(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let Ep;function Tt(){return Ep==null&&(Ep=Kf().epsilon()),Ep}function cs(){return"channelsLast"}function Cs(n,e){return le(n,e)}function Tu(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),B(n,t)}function _O(n,e){return U(()=>{if(n.shape.length!==2)throw new M(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Tu(n,1);return lf(t,[1,e,1])})}function OO(n){const e=[fr(n.shape)];return B(n,e)}function LO(n){if(n.rank<=1)throw new M(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],fr(n.shape,1)];return B(n,e)}function Zr(n,e,t){return U(()=>{switch(n.rank){case 1:return xu(n,e,t);case 2:return Td(n,[e,0],[t,n.shape[1]]);case 3:return wu(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return qo(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Le(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Le(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new M(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ap(n,e,t){return U(()=>{switch(n.rank){case 1:return xu(n,e,t);case 2:return Td(n,[0,e],[n.shape[0],t]);case 3:return wu(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return qo(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function qu(n,e,t,s){return U(()=>{switch(n.rank){case 1:return xu(n,e,t);case 2:switch(s){case 1:return Zr(n,e,t);case 2:return Ap(n,e,t);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Zr(n,e,t);case 2:return wu(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Ap(n,e,t);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Zr(n,e,t);case 2:return qo(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return qo(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Ap(n,e,t);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Wg(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),gt(n,e)}function Sx(n,e){switch(n.rank){case 1:return mm([n,e]);case 2:return gm([n,e],0);case 3:return ym([n,e],0);case 4:return bm([n,e],0);default:throw new M(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function lf(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new M(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return On(n,e)}function Yd(n,e=0,t=1,s,r){return wd(n,e,t,s,r)}function ks(n,e,t,s){if(n.rank<2||e.rank<2)throw new Te(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],o=e.shape.slice(-2)[0];if(r!==o)throw new Te(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return tf({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?uf(n.rank,s,cs()):null,activation:t});{const r=n.shape.slice(),o=r.pop();n=B(n,[-1,o]);const i=e.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:e.rank},(f,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=B(Oe(e,c),[l,-1]);const h=[...r,...u];return B(tf({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?uf(n.rank,s,cs()):null,activation:t}),h)}}function Ev(n,e,t){return U(()=>(Array.isArray(e)?e=Ht(e,"int32"):e=le(e,"int32"),ta(n,e,t)))}function Eu(n){return P(n,n)}function uf(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new M(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?B(e,[1,s[0],1,1,1]):B(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?B(e,[1,1,1,1,s[0]]):B(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?B(e,[1,s[0],1,1]):B(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?B(e,[1,1,1,s[0]]):B(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?B(e,[1,s[0],1]):B(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?B(e,[1,1,s[0]]):B(e,[1].concat(s))}else if(n<3)return e;throw new M(`Unsupported input rank by biasAdd: ${e.rank}`)}function ms(n,e,t){return U(()=>(t==null&&(t=cs()),xt(t),re(n,uf(n.rank,e,t))))}function PO(n,e=1){if(e!==1)throw new Te(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Zi(n)}function zO(n){return U(()=>ge(n,re(It(n),1)))}function Av(n,e,t,s){return U(()=>Qm(n,e,t,s))}function BO(n){return U(()=>{const e=re(.5,P(.2,n));return mn(e,0,1)})}function Au(n,e,t=!1){return t?n():e()}const MO=["fanIn","fanOut","fanAvg"],VO=["normal","uniform","truncatedNormal"];function WO(n){Co(MO,"FanMode",n)}function UO(n){Co(VO,"Distribution",n)}class Yn extends No{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Ug extends Yn{apply(e,t){return mt(e,t)}}Ug.className="Zeros";ie(Ug);class Jd extends Yn{apply(e,t){return hn(e,t)}}Jd.className="Ones";ie(Jd);class Gg extends Yn{constructor(e){if(super(),typeof e!="object")throw new M(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new M(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return U(()=>P(xe(this.value),hn(e,t)))}getConfig(){return{value:this.value}}}Gg.className="Constant";ie(Gg);class Hg extends Yn{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Rr(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Hg.className="RandomUniform";ie(Hg);class jg extends Yn{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Te(`randomNormal does not support dType ${t}.`);return Yd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}jg.className="RandomNormal";ie(jg);class qg extends Yn{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Te(`truncatedNormal does not support dType ${t}.`);return Dd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qg.className="TruncatedNormal";ie(qg);class Kg extends Yn{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return U(()=>{if(e.length!==2||e[0]!==e[1])throw new M("Identity matrix initializer can only be used for 2D square matrices.");return P(this.gain,md(e[0]))})}getConfig(){return{gain:this.gain}}}Kg.className="Identity";ie(Kg);function GO(n,e="channelsLast"){let t,s;if(xt(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=fr(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=fr(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=fr(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class yn extends Yn{constructor(e){if(super(),e.scale<0)throw new M(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,WO(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,UO(this.distribution),this.seed=e.seed}apply(e,t){const s=GO(e),r=s[0],o=s[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,o):i/=Math.max(1,(r+o)/2),this.distribution==="normal"){const a=Math.sqrt(i);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Te(`${this.getClassName()} does not support dType ${t}.`);return Dd(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*i);return Rr(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}yn.className="VarianceScaling";ie(yn);class Zd extends yn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return yn.className}}Zd.className="GlorotUniform";ie(Zd);class Qd extends yn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return yn.className}}Qd.className="GlorotNormal";ie(Qd);class ep extends yn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return yn.className}}ep.className="HeNormal";ie(ep);class tp extends yn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return yn.className}}tp.className="HeUniform";ie(tp);class np extends yn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return yn.className}}np.className="LeCunNormal";ie(np);class sp extends yn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return yn.className}}sp.className="LeCunUniform";ie(sp);class Xg extends Yn{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return U(()=>{if(e.length<2)throw new Te("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=X(e.slice(0,-1)),r=e[e.length-1],o=s*r;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const i=[Math.max(r,s),Math.min(r,s)],a=Yd(i,0,1,t,this.seed),l=sg.qr(a,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return u=P(u,h.sign()),s<r&&(u=u.transpose()),P(xe(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Xg.className="Orthogonal";ie(Xg);const Nx={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Cx(n,e={}){return ku(n,_n.getMap().classNameMap,e,"initializer")}function ct(n){return Mg(n)}function st(n){if(typeof n=="string"){const e=n in Nx?Nx[n]:n;if(e==="GlorotNormal")return new Qd;if(e==="GlorotUniform")return new Zd;if(e==="HeNormal")return new ep;if(e==="HeUniform")return new tp;if(e==="LeCunNormal")return new np;if(e==="LeCunUniform")return new sp;{const t={};return t.className=e,t.config={},Cx(t)}}else return n instanceof Yn?n:Cx(n)}function cf(n){return Array.isArray(n)&&Array.isArray(n[0])}function Rc(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function $e(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new M(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Ve(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new M(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function Dc(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const kx="Variable";class Rv{constructor(e,t="float32",s=kx,r=!0,o=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Sv(),s=s??kx,this.originalName=Cv(s),this.name=kv(this.originalName),this.trainable_=r,this.constraint=o,this.val=Jm(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),HO(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function HO(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function hf(n){return n.map(e=>e.read())}function Yg(n){n.forEach(e=>{e[0].write(e[1])})}class $t{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class hs{constructor(e,t,s,r,o,i,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=a,this.id=Sv(),i!=null&&(this.originalName=Cv(i),this.name=kv(this.originalName)),this.rank=t.length}}let jO=0;class rp{constructor(e,t){this.callArgs=t,this.id=jO++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let qO=0;class De extends No{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=qO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=Os(s)+"_"+Xd(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let o=null;e.batchSize!=null&&(o=e.batchSize),s=[o].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new qn(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new M(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return cn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return cn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new bs(`Layer ${this.name} is not connected, no input to return.`);return cn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new bs(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new bs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return cn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ge(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Ge(this.inputSpec);if(t.length!==s.length)throw new M(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const o=t[r],i=s[r];if(i==null)continue;const a=o.rank;if(i.ndim!=null&&a!==i.ndim)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&o.dtype!==i.dtype)throw new M(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${o.dtype}.`);if(i.axes){const l=o.shape;for(const u in i.axes){const c=Number(u),h=i.axes[u],d=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=o.shape[l];if(u!=null&&c!=null&&u!==c)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Ge(e),r=YO(e),o=JO(e);if(r===o)throw new M("Arguments to apply() must be all SymbolicTensors or all Tensors");return Jr(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const a of Ge(e))i.push(a.shape);this.build(cn(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(e),o){let i=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,i);const a=Ge(i),l=[];for(let u of a)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=cn(l),this.activityRegularizer!=null)throw new Te("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=KO(e),a=this.computeOutputShape(i);let l;const u=XO(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new hs(u,c,this,Ge(e),t,this.name,h)):l=new hs(u,a,this,Ge(e),t,this.name),this.addInboundNode(e,l,null,null,i,a,t),this._refCount++,this.activityRegularizer!=null)throw new Te("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new bs(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new bs(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new qn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Dc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return hf(e?this.trainableWeights:this.weights)}setWeights(e){U(()=>{const t=this.weights;if(t.length!==e.length)throw new M(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=hf(t);for(let o=0;o<r.length;++o){const i=r[o],a=t[o],l=e[o];if(!_e(i.shape,l.shape))throw new M(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}Yg(s)})}addWeight(e,t,s,r,o,i,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new M(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():st("zeros"));const u=r.apply(t,s),c=new Rv(u,s,e,i,a);return u.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ge(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),o=Ge(t),i=Ge(r);if(o.length!==i.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=i[a]}addInboundNode(e,t,s,r,o,i,a=null){const l=Ge(e);t=Ge(t),s=Ge(s),r=Ge(r),o=Rc(o),i=Rc(i);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new rp({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:o,outputShapes:i},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function KO(n){n=Ge(n);const e=[];for(const t of n)e.push(t.shape);return cn(e)}function XO(n){return"float32"}function Dv(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let o=0;o<s.inboundLayers.length;o++){const i=s.inputTensors[o],a=s.inboundLayers[o],l=s.nodeIndices[o],u=Dv(i,a,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function YO(n){let e=!0;for(const t of Ge(n))if(!(t instanceof hs)){e=!1;break}return e}function JO(n){let e=!0;for(const t of Ge(n))if(t instanceof hs){e=!1;break}return e}class ra extends De{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Xd("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new M("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new M("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new M("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new hs(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new rp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new M(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}ra.className="InputLayer";ie(ra);function Fv(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new M("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new ra({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function ZO(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return le(e,n.dtype)}catch{throw new M(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class lr{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof lr)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=ZO(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new M(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof hs){if(this.id2Value[e.id]==null)throw new M(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new M(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof hs){if(this.id2Value[e.id]==null)throw new M(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new M(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Se(this.id2Mask)}}const Fc=new vv,_c=new vv;function QO(n){Fc?.setMaxEntries(n),_c?.setMaxEntries(n)}function ka(n,e,t,s){const r=t==null?!1:t.training,o=Array.isArray(n),i=o?n:[n],a=i.map(f=>f.name),l=[],u=e.names();for(const f of a)u.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);const c=a.join(",")+"|"+e.names().sort().join(",");let h=Fc.get(c),d;if(h==null){const f=eL(i,e);h=f.sorted,d=f.recipientCounts,Fc.put(c,h),_c.put(c,d)}d={},r||Object.assign(d,_c.get(c));const p=new lr(e);for(let f=0;f<h.length;++f){const m=h[f],g=m.sourceLayer;if(g instanceof ra)continue;const y=[],b=[],v=[];let x=!1;for(const A of m.inputs){const R=p.getValue(A),N=p.getMask(A);y.push(R),b.push(N),N!=null&&(x=!0),r||(d[A.name]--,d[A.name]===0&&!e.hasKey(A)&&a.indexOf(A.name)===-1&&!R.isDisposed&&A.sourceLayer.stateful!==!0&&v.push(R))}x&&(t=t||{},t.mask=b[0]);const S=Ge(g.apply(y,t));let k=null;g.supportsMasking&&(k=g.computeMask(y,b));const D=nL(m),F=Array.isArray(D)?D:[D];for(let A=0;A<F.length;++A){p.hasKey(F[A])||p.add(F[A],S[A],Array.isArray(k)?k[0]:k);const R=a.indexOf(F[A].name);R!==-1&&(l[R]=S[A])}r||Se(v)}return p.disposeMasks(),o?l:l[0]}function eL(n,e){C(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=Tx(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const o of n){const{sorted:i,recipientMap:a}=Tx(o,e);for(const l of i)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(u=>s[l].add(u))}}return{sorted:t,recipientCounts:tL(s)}}function tL(n){const e={};for(const t in n)e[t]=n[t].size;return e}function Tx(n,e){const t=new Set,s=[],r={};for(const a of e.names())t.add(a);const o=[],i=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(t.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(a.inputs.length===0||l)o.pop(),s.push(a),t.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(a.name),!t.has(u.name)&&o.push(u)}}return{sorted:s,recipientMap:r}}function nL(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const sL=H();sL.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,QO);function Jg(n,e){return U(()=>Lt(fe(P(n,n),e,!0)))}class Ru extends No{getConfig(){return{}}}class Zg extends Ru{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return U(()=>{const t=Jg(e,this.axis),s=mn(t,0,this.maxValue);return P(e,ge(s,re(Tt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Zg.className="MaxNorm";ie(Zg);class Qg extends Ru{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return U(()=>ge(e,re(Tt(),Jg(e,this.axis))))}getConfig(){return{axis:this.axis}}}Qg.className="UnitNorm";ie(Qg);class ey extends Ru{apply(e){return fs(e)}}ey.className="NonNeg";ie(ey);class ty extends Ru{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return U(()=>{const t=Jg(e,this.axis),s=re(P(this.rate,mn(t,this.minValue,this.maxValue)),P(1-this.rate,t));return P(e,ge(s,re(Tt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ty.className="MinMaxNorm";ie(ty);const Ex={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Et(n){return Mg(n)}function Ax(n,e={}){return ku(n,_n.getMap().classNameMap,e,"constraint")}function At(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Ex?Ex[n]:n,config:{}};return Ax(t)}else return n instanceof Ru?n:Ax(n)}function rL(n){return new Zg(n)}function oL(n){return new Qg(n)}function iL(){return new ey}function aL(n){return new ty(n)}const lL=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:rL,minMaxNorm:aL,nonNeg:iL,unitNorm:oL},Symbol.toStringTag,{value:"Module"}));function uL(){return new Ug}function cL(){return new Jd}function hL(n){return new Gg(n)}function dL(n){return new Hg(n)}function pL(n){return new jg(n)}function fL(n){return new qg(n)}function mL(n){return new Kg(n)}function gL(n){return new yn(n)}function yL(n){return new Zd(n)}function bL(n){return new Qd(n)}function xL(n){return new ep(n)}function wL(n){return new tp(n)}function vL(n){return new np(n)}function IL(n){return new sp(n)}function $L(n){return new Xg(n)}const SL=Object.freeze(Object.defineProperty({__proto__:null,constant:hL,glorotNormal:bL,glorotUniform:yL,heNormal:xL,heUniform:wL,identity:mL,leCunNormal:vL,leCunUniform:IL,ones:cL,orthogonal:$L,randomNormal:pL,randomUniform:dL,truncatedNormal:fL,varianceScaling:gL,zeros:uL},Symbol.toStringTag,{value:"Module"}));async function or(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const o=n[r];if(typeof o!="number"){const i=o;e.push(i.data()),t.push(r),s.push(i)}}if(e.length>0){const r=await Promise.all(e);for(let o=0;o<r.length;++o)n[t[o]]=r[o][0];Se(s)}}function _v(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var Rx;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(Rx||(Rx={}));const NL=125;class Yo{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Ov{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class CL extends Yo{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const o=t[r];if(typeof o=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+o*s;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const a=U(()=>re(this.totals[r],P(o,s)));this.totals[r]=a,i?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:U(()=>{const r=P(ge(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),kt(t[s])}))}}class Lv extends Yo{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const o in this.history){const i=this.history[o];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){const l=i[a];e.push(l.data()),t.push(o),s.push(a)}}const r=await Promise.all(e);for(let o=0;o<r.length;++o)this.history[t[o]][s[o]].dispose(),this.history[t[o]][s[o]]=r[o][0]}}class Pv extends Yo{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||xg,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=NL),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Ic(this.yieldEvery)&&(this.maybeWait=$O(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await or(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await or(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await or(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await or(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await or(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Ic(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await or(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await or(e),await this.trainEnd(e))}}function zv(n,e){return n==null&&(n={}),n instanceof Yo?[n]:Array.isArray(n)&&n[0]instanceof Yo?n:Ge(n).map(s=>new Pv(s,e))}class Dn{constructor(){}static registerCallbackConstructor(e,t){C(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Dn.checkForDuplicate(t),Dn.constructors[e]==null&&(Dn.constructors[e]=[]),Dn.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Dn.constructors)Dn.constructors[+t].forEach(r=>{if(r===e)throw new M("Duplicate callback constructor.")})}static clear(){Dn.constructors={}}static createCallbacks(e){const t=[];for(const s in Dn.constructors){const r=+s;e>=r&&t.push(...Dn.constructors[r])}return t.map(s=>new s)}}Dn.constructors={};function Bv(n,e,t,s,r,o,i,a,l){const u=new Lv,c=[new CL,...Dn.createCallbacks(e)];n!=null&&c.push(...n),c.push(u);const h=new Ov(c);return h.setParams({epochs:t,initialEpoch:s,samples:r,steps:o,batchSize:i,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}function as(n,e={},t=!1){return ku(n,_n.getMap().classNameMap,e,"layer",t)}function Oc(n,e){return U(()=>{n.dtype!=="float32"&&(n=le(n,"float32"));const t=fe(Eu(n),e,!0),s=Io(t.shape,Tt()),r=Lt(Fs(t,s));return ge(n,r)})}function ko(n,e){return U(()=>ut(Eu(pe(e,n)),-1))}function op(n,e){return U(()=>ut(It(pe(e,n)),-1))}function oa(n,e){return U(()=>{const t=pe(n,e),s=mn(It(n),Tt(),Number.MAX_VALUE),r=It(ge(t,s));return P(100,ut(r,-1))})}function kL(n,e){return U(()=>{const t=mn(e,Tt(),Number.MAX_VALUE),s=Cn(re(1,t)),r=mn(n,Tt(),Number.MAX_VALUE),o=Cn(re(1,r));return ut(Eu(pe(s,o)),-1)})}function TL(n,e){return U(()=>{const t=Fs(0,pe(1,P(n,e)));return ut(Eu(t),-1)})}function EL(n,e){return U(()=>{const t=Fs(0,pe(1,P(n,e)));return ut(t,-1)})}function AL(n,e){return U(()=>{const t=fe(P(n,e),-1),s=Mn(P(pe(1,n),e),-1);return Fs(0,re(1,pe(s,t)))})}function RL(n,e){return U(()=>{const t=Math.log(2),s=pe(e,n),r=pe(re(s,$o(P(-2,s))),t);return ut(r,-1)})}function qa(n,e,t=!1){return U(()=>{if(t)e=vu(e);else{const s=fe(e,e.shape.length-1,!0);e=ge(e,s)}return e=mn(e,Tt(),1-Tt()),tt(fe(P(le(n,"float32"),Cn(e)),e.shape.length-1))})}function Lc(n,e,t=!1){return U(()=>{const s=le(ea(OO(n)),"int32");e=mn(e,Tt(),1-Tt());const r=e.shape,o=B(Ho(s,r[r.length-1]),r);return qa(o,e,t)})}function DL(n,e){if(!_e(n.shape,e.shape))throw new M(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return U(()=>{const t=fs(e),s=tt(It(e));return re(pe(t,P(e,n)),du(gn(s)))})}function ip(n,e){return U(()=>{let t;return t=mn(e,Tt(),1-Tt()),t=Cn(ge(t,pe(1,t))),ut(DL(n,t),-1)})}function FL(n,e){return U(()=>{const t=mn(n,Tt(),1),s=mn(e,Tt(),1);return fe(P(n,Cn(ge(t,s))),-1)})}function _L(n,e){return U(()=>{const t=Cn(re(Tt(),e));return ut(pe(e,P(n,t)),-1)})}function ny(n,e){return U(()=>{const t=Oc(n,-1),s=Oc(e,-1),r=P(t,s);return tt(fe(r,-1))})}const Pc={meanSquaredError:ko,meanAbsoluteError:op,meanAbsolutePercentageError:oa,meanSquaredLogarithmicError:kL,squaredHinge:TL,hinge:EL,categoricalHinge:AL,logcosh:RL,categoricalCrossentropy:qa,sparseCategoricalCrossentropy:Lc,binaryCrossentropy:ip,kullbackLeiblerDivergence:FL,poisson:_L,cosineProximity:ny};function Rp(n){if(typeof n=="string"){if(n in Pc)return Pc[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new M(e)}else return n}function sy(n,e){return U(()=>{const t=P(.5,kn(e)),s=Cs(ln(e,t),n.dtype);return ut(Nn(n,s),-1)})}function ry(n,e){return U(()=>Cs(Nn(so(n,-1),so(e,-1)),"float32"))}function Mv(n,e){return U(()=>le(fe(Kn(Nn(n,1),Nn(e,1))),"float32"))}function OL(n,e){return U(()=>le(fe(Kn(Nn(n,1),Nn(e,0))),"float32"))}function LL(n,e){return U(()=>le(fe(Kn(Nn(n,0),Nn(e,1))),"float32"))}function Vv(n,e){return U(()=>{const t=Mv(n,e),s=LL(n,e),r=re(t,s);return le(_t(ln(r,0),ge(t,r),0),"float32")})}function PL(n,e){return U(()=>{const t=Mv(n,e),s=OL(n,e),r=re(t,s);return le(_t(ln(r,0),ge(t,r),0),"float32")})}function Wv(n,e){return ip(n,e)}function Uv(n,e){return n.rank===e.rank&&(n=Dr(n,[n.rank-1])),e=so(e,-1),e.dtype!==n.dtype&&(e=le(e,n.dtype)),le(Nn(n,e),"float32")}function zL(n,e){return U(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return xe(1).sub(t.div(s))})}const BL=ko,ML=ko,VL=op,WL=op,UL=oa,GL=oa,oy=qa,HL=ny,Gv=Lc,zc={binaryAccuracy:sy,categoricalAccuracy:ry,precision:Vv,categoricalCrossentropy:oy,sparseCategoricalCrossentropy:Gv,mse:BL,MSE:ML,mae:VL,MAE:WL,mape:UL,MAPE:GL,cosine:HL};function jL(n){if(typeof n=="string"&&n in zc)return zc[n];if(typeof n!="string"&&n!=null)return n;throw new M(`Unknown metric ${n}`)}function Ku(n){if(xs(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Pc))if(Pc[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(zc))if(zc[t]===n){e=t;break}return e!==void 0?e:n.name}}function qL(n){const e={Adagrad:()=>Mr.adagrad(.01),Adadelta:()=>Mr.adadelta(1,.95,Tt()),Adam:()=>Mr.adam(.001,.9,.999,Tt()),Adamax:()=>Mr.adamax(.002,.9,.999,Tt(),0),RMSProp:()=>Mr.rmsprop(.001,.9,0,Tt()),SGD:()=>Mr.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new M(`Unknown Optimizer ${n}`)}const Dx=1*1024*1024;function Fx(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!df(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>Dx&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Dx}.`)}}function df(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!df(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!df(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function KL(n,e,t,s=console.log){const r=YL(n),o=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let i;if(!r){o.push("Receives inputs"),i=[];for(const c in n.nodesByDepth)i.push(...n.nodesByDepth[c])}s("_".repeat(e)),Bc(o,t,s),s("=".repeat(e));const a=n.layers;for(let c=0;c<a.length;++c)r?JL(a[c],t,s):ZL(a[c],t,i,s),s((c===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=XL(n),u=Dc(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function XL(n){let e;return n.collectedTrainableWeights!=null?e=Dc(n.collectedTrainableWeights):e=Dc(n.trainableWeights),e}function YL(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let o=!1;for(const i of r.inboundNodes)if(s.indexOf(i)!==-1)if(o){e=!1;break}else o=!0;if(!e)break}return e}function Bc(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function JL(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=n.name,i=n.getClassName(),a=[`${o} (${i})`,r,s,n.countParams().toString()];Bc(a,e,t)}function ZL(n,e,t,s){let r,o;try{o=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];i.push(`${p}[${f}][${m}]`)}const a=n.name,l=n.getClassName(),u=i.length===0?"":i[0],c=[`${a} (${l})`,o,r,n.countParams().toString(),u];Bc(c,e,s);for(let h=1;h<i.length;++h)Bc(["","","","",i[h]],e,s)}function Hv(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Ka(n,e){if(n===null)return null;if(typeof n=="string")return Ur(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const o=n[r];Hv(e,r,o)?t.push(o):t.push(Ka(o,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const o=Ur(s);t[o]=Ka(r,o)}}return t}}function pf(n,e){if(n==null)return null;if(typeof n=="string")return Os(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const o=n[r];Hv(e,r,o)?t.push(o):t.push(pf(o,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],o=Os(s);(s==="name"||s==="className")&&typeof r=="string"?t[o]=r:t[o]=pf(r,s)}return t}}const ap="4.22.0";const QL=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class ts extends De{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=Xd(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],pr(this.inputs).length!==this.inputs.length)throw new M(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);pr(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.sourceLayer,x=b.nodeIndex,S=b.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(S)}for(const b of this.inputs){const v=b.sourceLayer,x=b.nodeIndex,S=b.tensorIndex;xs(x===0,"input layer has >1 nodes"),xs(S===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof ra))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},s={},r={},o={},i={},a=[],l=(b,v,x,S,k,D)=>{(S==null||k==null||D==null)&&(S=b.sourceLayer,k=b.nodeIndex,D=b.tensorIndex);const F=S.inboundNodes[k];if(x.indexOf(F)!==-1)throw new qn(`The tensor ${b.name} at layer "${S.name}" is part of a cycle.`);if(v.indexOf(F)!==-1)return;this.containerNodes.add(ts.nodeKey(S,k)),S.id in i||(i[S.id]=Object.keys(i).length),x.indexOf(F)===-1&&x.push(F);const A=F.inboundLayers.length;for(let R=0;R<A;R++){const N=F.inputTensors[R],z=F.inboundLayers[R],V=F.nodeIndices[R],j=F.tensorIndices[R];l(N,v,x,z,V,j)}for(v.push(F);x.indexOf(F)>=0;)x.splice(x.indexOf(F),1);a.push(F)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const h=a.slice().reverse();for(const b of h){s[b.id]=b,b.id in t||(t[b.id]=0);let v=t[b.id];const x=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];v=Math.max(v,x),r[b.outboundLayer.id]=v,o[b.outboundLayer.id]=b.outboundLayer,t[b.id]=v;for(let S=0;S<b.inboundLayers.length;S++){const k=b.inboundLayers[S],D=b.nodeIndices[S],F=k.inboundNodes[D],A=t[F.id]==null?0:t[F.id];t[F.id]=Math.max(v+1,A),s[F.id]=F}}const d={};for(const b in t){const v=t[b];v in d||(d[v]=[]),d[v].push(s[b])}const p={};for(const b in r){const v=r[b];v in p||(p[v]=[]),p[v].push(o[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Hu);this.layers=[];for(const b of f){const v=p[b];v.sort((x,S)=>{const k=i[x.id],D=i[S.id];return k<D?-1:k>D?1:0});for(const x of v)x instanceof ts&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=p,f=Object.keys(d).map(b=>parseInt(b,10)).sort(Hu);const m=this.inputs.slice(),g=[];for(const b of f)for(const v of d[b]){const x=v.outboundLayer;if(x!=null){for(const S of v.inputTensors)if(m.indexOf(S)===-1)throw new qn(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${x.name}". The following previous layers were accessed without issue: ${g}`);for(const S of v.outputTensors)m.push(S);g.push(x.name)}}this.nodesByDepth=d;const y=this.layers.map(b=>b.name);for(const b of y){const v=y.filter(x=>x===b).length;if(v!==1)throw new qn(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new rp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new M("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const o=QL(e);o&&this.parseWeights(e);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=o?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(s[c]!=null)throw new M(`Duplicate weight name: ${c}`);s[c]=u,r++}const i=[];for(const a in e){let l=a;if(s[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[l]!=null)i.push([s[l],e[a]]);else if(t)throw new M(`Provided weight data has no target variable: ${a}`);delete s[l]}if(t){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new M(`${a.length} of ${r} weights are not set: ${a}`)}Yg(i)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],o=s.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");o!==t&&(e[o]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${ap}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=pf(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return U(()=>{e=Ge(e);const s=new lr;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return ka(this.outputs,s,t)})}computeMask(e,t){return U(()=>{e=Ge(e);let s;return t==null?s=uo(null,e.length):s=Ge(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=Rc(e);if(t.length!==this.inputLayers.length)throw new M(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],u=t[a],c=l.name+"_0_0";s[c]=u}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Hu);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const h=[];for(let m=0;m<u.inboundLayers.length;m++){const g=u.inboundLayers[m],y=u.nodeIndices[m],b=u.tensorIndices[m],v=`${g.name}_${y}_${b}`,x=s[v];h.push(x)}const d=c.computeOutputShape(cn(h)),p=Rc(d),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++){const g=`${c.name}_${f}_${m}`;s[g]=p[m]}}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;i.push(h)}for(let a=0;a<i.length;a++){const l=i[a];xs(l in s),o.push(s[l])}return cn(o)}runInternalGraph(e,t){t==null&&(t=uo(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=t[l];s[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Hu);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of d)m.id in s&&f.push(s[m.id]);if(f.length===d.length){let m={},g,y,b,v;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){const[x,S]=f[0];m.mask==null&&(m.mask=S),b=Ge(h.call(x,m)),v=Ge(h.computeMask(x,S)),g=[x],y=[S]}else g=f.map(x=>x[0]),y=f.map(x=>x[1]),m.mask==null&&(m.mask=y),b=Ge(h.call(g,m)),v=Ge(h.computeMask(g,y));if(h.activityRegularizer)throw new Te("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<p.length;++x){const S=p[x],k=b[x],D=v[x];s[S.id]=[k,D]}}}}const o=[],i=[],a=[];for(const l of this.outputs){xs(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof ts?1:0;for(let o=0;o<r.inboundNodes.length;o++){const i=ts.nodeKey(r,o);this.containerNodes.has(i)&&(t[i]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new M("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new M(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new M(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return U(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=ts.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let h=0;h<i.inboundNodes.length;h++){const d=i.inboundNodes[h],p=ts.nodeKey(i,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const m=[];for(let g=0;g<d.inboundLayers.length;g++){const y=d.inboundLayers[g],b=d.nodeIndices[g],v=d.tensorIndices[g],x=ts.nodeKey(y,b);let S=t[x];S==null&&(S=0),m.push([y.name,S,v,f])}u.push(m)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,s.push(c)}e.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=ts.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[i];r.push([a.name,c,h])}e.inputLayers=r;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=ts.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[i];o.push([a.name,c,h])}return e.outputLayers=o,e}static fromConfig(e,t,s={},r=!1){const o={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const b=[];let v;for(const x of y){const S=x[0],k=x[1],D=x[2];if(v=x[3]==null?{}:x[3],!(S in o)){a(g,y);return}const F=o[S];if(F.inboundNodes.length<=k){a(g,y);return}const A=F.inboundNodes[k];b.push(A.outputTensors[D])}b.length>0&&g.apply(cn(b),v)}function u(g){const y=g.name,b=as(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(r),o[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new M(`Corrupted configuration, expected array for nodeData: ${x}`);a(b,x)})}const c=t.name,h=t.layers;for(const g of h)u(g);for(;!IO(i);)for(const g of h){const y=o[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const v of b)l(y,v)}}const d=[],p=[],f=t.inputLayers;for(const g of f){const y=g[0],b=g[1],v=g[2];xs(y in o);const S=o[y].inboundNodes[b].outputTensors;d.push(S[v])}const m=t.outputLayers;for(const g of m){const y=g[0],b=g[1],v=g[2];xs(y in o);const S=o[y].inboundNodes[b].outputTensors;p.push(S[v])}return new e({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new M("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){U(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function eP(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(o=>{o in n?r.push(n[o]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function jv(n,e){return eP(n,e,"classWeight")}async function qv(n,e,t,s){if(t!=null){const r=U(()=>{if(n.shape.length===1)return Ss(n);if(n.shape.length===2){if(n.shape[1]>1)return so(n,1);if(n.shape[1]===1)return B(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await r.data());Se(r);const i=[];return o.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(t[a])}),Ht(i,"float32")}else return null}function tP(n,e){return P(n,e)}const nP=32;function Kv(n,e){let t,s;const r=e;t=r.xs,s=r.ys,C(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const o=_x("input",n.inputNames,t),i=_x("output",n.outputNames,s),a=o[0].shape[0];C(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),C(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)C(o[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<i.length;l++)C(i[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:i}}function _x(n,e,t){if(t instanceof ze)return[t];if(Array.isArray(t))return C(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new M(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function sP(n){if(n.length===3)throw new Te("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function rP(n,e,t){const s=t.batchesPerEpoch!=null;if(C(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),C(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),C(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),C(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),C(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let o,i;if(r)if(Ox(t.validationData))C(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=sP(t.validationData);o=g.xs,i=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();const c=zv(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=Bv(c,h,t.epochs,null,null,oP(e,t),null,r,u);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,m=await e.iterator();for(;f<t.epochs;){const g={};await d.onEpochBegin(f);let y=0,b=0;for(s||(m=await e.iterator());!s||y<t.batchesPerEpoch;){const v=await m.next();if(s&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){const{xs:x,ys:S}=Kv(n,v.value),k={};k.batch=b,k.size=x[0].shape[0],await d.onBatchBegin(b,k);const D=[];if(t.classWeight!=null){const R=jv(t.classWeight,n.outputNames);for(let N=0;N<R.length;++N)D.push(await qv(S[N],null,R[N]))}const F=x.concat(S).concat(D),A=a(F);Se(F);for(let R=0;R<l.length;++R){const N=l[R],z=A[R];k[N]=z,kt(z)}await d.onBatchEnd(b,k),_v(k),b++,y++}if(s?y>=t.batchesPerEpoch:v.done){if(r){let x;Ox(t.validationData)?x=Ge(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):x=Ge(n.evaluate(o,i,{batchSize:t.validationBatchSize==null?nP:t.validationBatchSize,verbose:0}));for(let S=0;S<n.metricsNames.length;++S)g[`val_${n.metricsNames[S]}`]=x[S]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,g),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function oP(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function Ox(n){return typeof n.iterator=="function"}function iP(n){return typeof n.next=="function"}async function aP(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let o=[];if(t.verbose>0)throw new Te("Verbose mode is not implemented yet.");C(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const i=iP(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const u=await i.next();if(o=U(()=>{if(u.value){const{xs:c,ys:h}=Kv(n,u.value),d=c.concat(h),p=U(()=>r(d));if(Se(d),l===0)for(let m=0;m<p.length;++m)o.push(xe(0));const f=d[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=o[m];o[m]=U(()=>re(o[m],P(f,g))),l>0&&Se(y)}Se(p),a+=f,++l}return o}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=ge(o[u],a),Se(c)}return cn(o)}function Dp(n){C(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function wa(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Zr(s,e,t-e)):Zr(n,e,t-e)}function ff(n,e){return U(()=>n==null?null:Array.isArray(n)?n.map(t=>ff(t,e)):Ev(n,e.dtype==="int32"?e:le(e,"int32")))}function Fp(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function Xv(n){const e=[];n instanceof ze&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Tu(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function es(n,e){if(n==null)return;const t=[];if(e instanceof ze)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const o=e[r];t.push(o.id)}const s=[];if(n instanceof ze)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const o=n[r];t.indexOf(o.id)===-1&&s.push(o)}s.forEach(r=>{r.isDisposed||r.dispose()})}function lP(n){return n instanceof ze}function mf(n){return Array.isArray(n)}function Lx(n){return!lP(n)&&!mf(n)}function Px(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let i=!1;if(mf(n)&&n.length>0)i=!0;else if(Lx(n)){for(const a in n)if(n.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new M(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(i=>null);let o;if(Lx(n)){n=n,o=[];for(const i of e){if(n[i]==null)throw new M(`No data provided for "${i}". Need data for each key in: ${e}`);o.push(n[i])}}else if(mf(n)){if(n=n,n.length!==e.length)throw new M(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(n=n,e.length>1)throw new M(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=Xv(o),t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;const a=o[i];if(a.shape.length!==t[i].length)throw new M(`Error when checking ${r}: expected ${e[i]} to have ${t[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[i].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=t[i][l];if(c!=null&&c>=0&&u!==c)throw new M(`${r} expected a batch of elements where each example has shape [${t[i].slice(1,t[i].length)}] (i.e.,tensor shape [*,${t[i].slice(1,t[i].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function uP(n,e,t){const s=pr(n.map(o=>o.shape[0]));s.sort();const r=pr(e.map(o=>o.shape[0]));if(r.sort(),s.length>1)throw new M(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>1)throw new M(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>0&&r.length>0&&!_e(s,r))throw new M(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function cP(n,e,t){const s=[ko,ip,qa];for(let r=0;r<n.length;++r){const o=n[r],i=e[r],a=t[r];if(i!=null){if(i===qa&&o.shape[o.shape.length-1]===1)throw new M(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(i)!==-1){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new M(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function zx(n,e,t,s=!0,r=""){let o;if(Array.isArray(n)){if(n.length!==e.length)throw new M(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(e.length>1)throw new M(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;const a=o[i];if(a.shape.length!==t[i].length)throw new M(`Error when checking ${r}: expected ${e[i]} to have ${t[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[i].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=t[i][l];if(c!=null&&c!==u)throw new M(`Error when checking ${r}: expected ${e[i]} to have shape ${JSON.stringify(t[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function hP(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let o=t.hasOwnProperty(r)?t[r]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const dP="layers-model";class Ms extends ts{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new M("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");KL(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=qL(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof sr))throw new M("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new M(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),t.push(Rp(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new M(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>Rp(a))}else{const i=Rp(e.loss);this.outputs.forEach(a=>{t.push(i)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const a=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Jr("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=hP(e.metrics,this.outputNames),o=(i,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,i])};Jr("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const a=r[i];(u=>{let h,d,p;for(const f of u){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===ip?["accuracy","acc"].indexOf(f)!==-1?d=sy:["crossentropy","ce"].indexOf(f)!==-1&&(d=Wv):this.lossFunctions[i]===Lc?["accuracy","acc"].indexOf(f)!==-1?d=Uv:["crossentropy","ce"].indexOf(f)!==-1&&(d=Gv):["accuracy","acc"].indexOf(f)!==-1?d=ry:["crossentropy","ce"].indexOf(f)!==-1&&(d=oy);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=d,h=""+y}else p=jL(f),h=""+Ku(f);let m;Jr(h,()=>{m=p}),o(i,h,m)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Dp(r);const i=this.standardizeUserDataXY(e,t,!0,r);try{const a=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,r,s.verbose,s.steps);return cn(u)}finally{es(i[0],e),es(i[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),aP(this,e,t)}checkNumSamples(e,t,s,r="steps"){let o;if(s!=null){if(o=null,t!=null)throw new M(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?o=e[0].shape[0]:o=e.shape[0];else throw new M(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return o}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new M("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],o=this.retrieveSymbolicTensors(r),i=new lr;if(e instanceof ze&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new M(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new M(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const a=ka(o,i);return s?a:a[0]}retrieveSymbolicTensors(e){const t=uo(null,e.length);let s=e.length;for(const r of this.layers){const o=Array.isArray(r.output)?r.output:[r.output],i=o.map(a=>a.name);for(let a=0;a<e.length;++a){const l=i.indexOf(e[a]);if(l!==-1&&(t[a]=o[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((o,i)=>{o==null&&r.push(e[i])}),new M(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return U(()=>{const r=this.checkNumSamples(e);if(s)throw new Te("Verbose predictLoop() is not implemented yet.");const o=Fp(r,t),i=this.outputs.map(a=>[]);for(let a=0;a<o.length;++a)U(()=>{const u=o[a][0],c=o[a][1],h=wa(e,u,c),d=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)d.push({key:this.inputs[f],value:h[f]});else d.push({key:this.inputs[0],value:h});const p=new lr(d);return ka(this.outputs,p)}).forEach((u,c)=>i[c].push(u));return cn(i.map(a=>gt(a,0)))})}predict(e,t={}){const s=Xv(e);zx(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Dp(r),this.predictLoop(s,r)}finally{es(s,e)}}predictOnBatch(e){zx(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new qn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let i=0;i<this.feedOutputShapes.length;++i){const a=this.feedOutputShapes[i];this.feedLossFns[i]===Lc?o.push(a.slice(0,a.length-1).concat([1])):o.push(a)}if(e=Px(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Px(t,this.feedOutputNames,o,!1,"target"),uP(e,t),cP(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new M(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,o=!0,i){const[a,l]=this.standardizeUserDataXY(e,t,o,i);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=jv(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await qv(l[h],null,c[h]))}return[a,l,u]}testLoop(e,t,s,r=0,o){return U(()=>{const i=this.checkNumSamples(t,s,o,"steps"),a=[];if(r>0)throw new Te("Verbose mode is not implemented yet.");if(o!=null)throw new Te("steps mode in testLoop() is not implemented yet");{const l=Fp(i,s),u=Ht(us(0,i));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],p=Zr(u,h,d-h),f=ff(t,p),m=e(f);if(c===0)for(let g=0;g<m.length;++g)a.push(xe(0));for(let g=0;g<m.length;++g){const y=m[g];a[g]=re(a[g],P(d-h,y))}}for(let c=0;c<a.length;++c)a[c]=ge(a[c],i)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let o=r;if(Ix(e,r)>1){const i=Ix(e.slice(0,s),r);o+=`_${i}`}t.push(o)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:s[m]});const d=new lr(h),p=ka(this.outputs,d,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(r[m],p[m]);o[m]!=null&&(y=tP(y,o[m]));const b=ut(y);t.push(b),m===0?f=y:f=re(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=ut(y(r[b],p[b]))}kt(g),i.push(g)}return f=ut(f),this.calculateLosses().forEach(m=>{f=re(f,m)}),f},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=e=>U(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:r[u]});const a=new lr(i),l=ka(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=ut(c(o[u],l[u]));u===0?s=h:s=re(s,h),t.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=ut(c(o[h],l[h]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,o,i,a,l,u,c,h,d;try{const p=s.batchSize==null?32:s.batchSize;Dp(p);const m=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);r=m[0],o=m[1],d=m[2];let g=!1,y;if(s.validationData!=null&&s.validationData.length>0){if(g=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new Te("validationData including sample weights is not supported yet."):new M(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const R=await this.standardizeUserData(l,u,null,null,!0,p);c=R[0],h=R[1],y=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){g=!0;const A=Math.floor(r[0].shape[0]*(1-s.validationSplit)),R=r[0].shape[0];c=wa(r,A,R),i=r,r=wa(r,0,A),h=wa(o,A,R),a=o,o=wa(o,0,A),y=c.concat(h)}else s.validationSteps!=null&&(g=!0);const b=r.concat(o).concat(d);this.checkTrainableWeightsConsistency();const v=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let S,k;g?(this.makeTestFunction(),S=this.testFunction,k=x.slice().concat(x.map(A=>"val_"+A))):(S=null,y=[],k=x.slice());const D=zv(s.callbacks,s.yieldEvery);return await this.fitLoop(v,b,x,p,s.epochs,s.verbose,D,S,y,s.shuffle,k,s.initialEpoch,null,null)}finally{this.isTraining=!1,es(r,e),es(o,t),es(i,e),es(a,t),es(c,l),es(h,u),d!=null&&Se(d)}}async fitLoop(e,t,s,r,o,i,a,l,u,c,h,d,p,f){r==null&&(r=32),o==null&&(o=1),c==null&&(c=!0),d==null&&(d=0);let m=!1;if(l!=null&&u!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new M("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,r,p,"steps_per_epoch");let y;g!=null&&(y=us(0,g)),i==null&&(i=1);const{callbackList:b,history:v}=Bv(a,i,o,d,g,p,r,m,h);b.setModel(this),this.history=v,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<o;++x){await b.onEpochBegin(x);const S={};if(p!=null)throw new Te("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Te("batch shuffling is not implemneted yet");c&&Pf(y);const k=Ht(y),D=Fp(g,r);for(let F=0;F<D.length;++F){const A={};if(await b.onBatchBegin(F,A),U(()=>{const R=D[F][0],N=D[F][1],z=Zr(k,R,N-R);A.batch=F,A.size=N-R;const V=ff(t,z),j=e(V);for(let G=0;G<s.length;++G){const q=s[G],J=j[G];A[q]=J,kt(J)}if(F===D.length-1&&m){const G=this.testLoop(l,u,r);for(let q=0;q<s.length;++q){const J=s[q],K=G[q];kt(K),S["val_"+J]=K}}}),await b.onBatchEnd(F,A),_v(A),this.stopTraining_)break}k.dispose()}if(await b.onEpochEnd(x,S),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return rP(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],o=s[1],a=this.makeTrainFunction()(r.concat(o)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return Se(a),es(s[0],e),es(s[1],t),cn(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let i=0;i<r.length;++i)s&&!r[i].trainable||t.push({name:r[i].originalName,tensor:o[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=Kp().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Kp().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Os(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Os(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=Os(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Os(Ku(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Os(Ku(e)));{const e={};for(const t in this.metrics)e[t]=Os(Ku(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Ka(e.optimizer_config),s=as(t);let r;if(typeof e.loss=="string")r=Ur(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>Ur(i));else if(e.loss!=null){r={};for(const i in e.loss)r[i]=Ur(e.loss[i])}let o;if(Array.isArray(e.metrics))o=e.metrics.map(i=>Ur(i));else if(e.metrics!=null){o={};for(const i in e.metrics)o[i]=Ur(e.metrics[i])}this.compile({loss:r,metrics:o,optimizer:s})}async save(e,t){if(typeof e=="string"){const u=mw(e);if(u.length===0)throw new M(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new M(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new M("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Xp(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:dP,generatedBy:`TensorFlow.js tfjs-layers v${ap}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await Xp(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=pw([s.data,c])}return this.userDefinedMetadata!=null&&(Fx(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){Fx(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ms.className="Model";ie(Ms);class Yv extends Ms{}Yv.className="Functional";ie(Yv);async function pP(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=Ka(t),r=as(s,e);if(n.weightsManifest!=null){const o=await A1(n.weightsManifest,n.pathPrefix,r.weights.map(a=>a.originalName)),i={};for(const a of r.weights)i[a.originalName]=o[a.originalName];r.loadWeights(i),Se(o)}return r}async function Jv(n,e){if(e==null&&(e={}),typeof n=="string"){const t=gw(n,e);if(t.length===0)t.push(F1(n,e));else if(t.length>1)throw new M(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return fP(n,void 0,e)}async function fP(n,e,t){if(t==null&&(t={}),n.load==null)throw new M("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const o=t.strict==null?!0:t.strict,i=s.weightData!=null&&s.weightSpecs!=null&&o,a=as(Ka(r),e,i),l=s.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),s.userDefinedMetadata!=null&&a.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new M("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=mP(s.weightData,s.weightSpecs);a.loadWeights(u,o),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),Se(u),Se(c.map(h=>h.tensor))}return a}function mP(n,e){const t=Xf(n,e),s={},r=[];return e.forEach(o=>{o.group==="optimizer"?r.push({name:o.name,tensor:t[o.name]}):s[o.name]=t[o.name]}),{modelWeights:s,optimizerWeights:r}}class co extends Ms{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Xd("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new M(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof co||e instanceof Ms;let s;if(t){if(s=e,s.outputs.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new M("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new M("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=Fv({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new M(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Dv(this.outputs[0])}this.inboundNodes=[],new rp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:uo(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Ve(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ms({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new qn("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new qn("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new qn("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new qn("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let o,i={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new M("Legacy serialization format not supported yet.");o=t}else C(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=t.layers,delete t.layers,i=t;const a=new e(i);if(!(a instanceof co))throw new Te(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of o){const c=as(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new M("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new M("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}co.className="Sequential";ie(co);function Zv(n){return new Ms(n)}function gP(n){return new co(n)}function Qv(n){return Fv(n)}function yP(n,e){Dn.registerCallbackConstructor(n,e)}let Zt=class extends No{getConfig(){return{}}};class eI extends Zt{apply(e,t=1){return PO(e,t)}}eI.className="elu";ie(eI);class tI extends Zt{apply(e){return Sd(e)}}tI.className="selu";ie(tI);class nI extends Zt{apply(e){return fs(e)}}nI.className="relu";ie(nI);class sI extends Zt{apply(e){return U(()=>wr(6,fs(e)))}}sI.className="relu6";ie(sI);class rI extends Zt{apply(e){return e}}rI.className="linear";ie(rI);class oI extends Zt{apply(e){return is(e)}}oI.className="sigmoid";ie(oI);class iI extends Zt{apply(e){return BO(e)}}iI.className="hardSigmoid";ie(iI);class aI extends Zt{apply(e){return $o(e)}}aI.className="softplus";ie(aI);class lI extends Zt{apply(e){return zO(e)}}lI.className="softsign";ie(lI);class uI extends Zt{apply(e){return xr(e)}}uI.className="tanh";ie(uI);let iy=class extends Zt{apply(e,t=-1){return vu(e,t)}};iy.className="softmax";ie(iy);class cI extends Zt{apply(e,t=-1){return yd(e,t)}}cI.className="logSoftmax";ie(cI);class hI extends Zt{apply(e){return U(()=>U(()=>{const t=Math.sqrt(2),s=P(.5,re(1,fd(ge(e,t))));return P(e,s)}))}}hI.className="gelu";ie(hI);class dI extends Zt{apply(e){return U(()=>P(.5,P(e,re(1,xr(P(Lt(ge(2,Math.PI)),re(e,P(.044715,As(e,3)))))))))}}dI.className="gelu_new";ie(dI);class pI extends Zt{apply(e){return U(()=>P(e,xr($o(e))))}}pI.className="mish";ie(pI);class fI extends Zt{apply(e,t=1){return U(()=>P(is(P(e,t)),e))}}fI.className="swish";ie(fI);function Ir(n){return n.getClassName()}function _p(n,e={}){return ku(n,_n.getMap().classNameMap,e,"activation")}function $r(n){if(n==null){const e={};return e.className="linear",e.config={},_p(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},_p(e)}else return n instanceof Zt?n:_p(n)}function ay(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class mI extends No{}class Du extends mI{constructor(e){super(),ay(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return U(()=>{let t=mt([1]);return this.hasL1&&(t=re(t,fe(P(this.l1,It(e))))),this.hasL2&&(t=re(t,fe(P(this.l2,Eu(e))))),B(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Du.className="L1L2";ie(Du);function bP(n){return ay(n),new Du({l1:n!=null?n.l1:null,l2:0})}function xP(n){return ay(n),new Du({l2:n!=null?n.l2:null,l1:0})}const Bx={l1l2:"L1L2"};function Je(n){return Mg(n)}function Mx(n,e={}){return ku(n,_n.getMap().classNameMap,e,"regularizer")}function rt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Bx?Bx[n]:n,config:{}};return Mx(t)}else return n instanceof mI?n:Mx(n)}class ly extends De{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=$e(e);let s=fs(e);return this.maxValue!=null&&(s=mn(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}ly.className="ReLU";ie(ly);class uy extends De{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=$e(e);return hu(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}uy.className="LeakyReLU";ie(uy);class cy extends De{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=st(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=rt(e.alphaRegularizer),this.alphaConstraint=At(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new M(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ve(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new $t({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=$e(e),bu(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ct(this.alphaInitializer),alphaRegularizer:Je(this.alphaRegularizer),alphaConstraint:Et(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}cy.className="PReLU";ie(cy);let hy=class extends De{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Te(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=$e(e);return Zi(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};hy.className="ELU";ie(hy);class dy extends De{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=$e(e);return P(s,le(ln(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}dy.className="ThresholdedReLU";ie(dy);class py extends De{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new iy().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return U(()=>{let s=$e(e);const r=t.mask;if(r!=null){const o=P(pe(hn(s.shape),le(r,s.dtype)),xe(-1e9));s=re(s,o)}return this.axis instanceof Array?this.axis.length>1?gn(pe(s,pu(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}py.className="Softmax";ie(py);function Mo(n,e,t){if(typeof n=="number")return uo(n,e);if(n.length!==e)throw new M(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!FO(r))throw new M(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function ls(n,e,t,s,r=1){if(n==null)return n;const o=e+(e-1)*(r-1);let i;return t==="same"?i=n:i=n-o+1,Math.floor((i+s-1)/s)}function ws(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+vr([t-e,0]);else if(s==="same")n=n*e;else throw new M(`Unsupport padding mode: ${s}.`);return n}function fy(n,e){return U(()=>(xt(e),e==="channelsFirst"?Oe(n,[0,2,3,1]):n))}function gI(n,e){return U(()=>(xt(e),e==="channelsFirst"?Oe(n,[0,2,3,4,1]):n))}function wP(n,e,t,s=1,r="valid",o,i=1){return U(()=>{if(o==null&&(o=cs()),xt(o),n.shape.length!==3)throw new M(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new M(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new M(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(n=Oe(n,[0,2,1])),r==="causal")throw new Te("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=cd(n,e,s,r==="same"?"same":"valid","NWC",i);return t!=null&&(a=ms(a,t)),a})}function Vx(n,e,t,s=[1,1],r="valid",o,i,a=null){return U(()=>{if(o==null&&(o=cs()),xt(o),n.rank!==3&&n.rank!==4)throw new M(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new M(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=fy(n,o);if(r==="causal")throw new Te("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=g1({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:t,activation:a}),o==="channelsFirst"&&(l=Oe(l,[0,3,1,2])),l})}function vP(n,e,t,s=[1,1,1],r="valid",o,i){return U(()=>{if(o==null&&(o=cs()),xt(o),n.rank!==4&&n.rank!==5)throw new M(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new M(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=gI(n,o);if(r==="causal")throw new Te("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=wm(a,e,s,r==="same"?"same":"valid","NDHWC",i),t!=null&&(a=ms(a,t)),o==="channelsFirst"&&(a=Oe(a,[0,4,1,2,3])),a})}class lp extends De{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",lp.verifyArgs(t),this.rank=e,Ft(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Te(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Mo(t.kernelSize,e,"kernelSize"),this.strides=Mo(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Un(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,xt(this.dataFormat),this.activation=$r(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=st(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=At(t.biasConstraint),this.biasRegularizer=rt(t.biasRegularizer),this.activityRegularizer=rt(t.activityRegularizer),this.dilationRate=Mo(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new M(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new M(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new M(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(xs("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Vg(e.kernelSize,"number",1,3))throw new M(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ir(this.activation),useBias:this.useBias,biasInitializer:ct(this.biasInitializer),biasRegularizer:Je(this.biasRegularizer),activityRegularizer:Je(this.activityRegularizer),biasConstraint:Et(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class ia extends lp{constructor(e,t){super(e,t),this.kernel=null,ia.verifyArgs(t),this.filters=t.filters,Ft(this.filters,"filters"),this.kernelInitializer=st(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=At(t.kernelConstraint),this.kernelRegularizer=rt(t.kernelRegularizer)}build(e){e=Ve(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new M(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return U(()=>{e=$e(e);let s;const r=this.bias==null?null:this.bias.read(),o=$v(this.activation.getClassName());if(o!=null&&this.rank===2)s=Vx(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=wP(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=Vx(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=vP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Te("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Ve(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let o=0;o<s.length;++o){const i=ls(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);t.push(i)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:ct(this.kernelInitializer),kernelRegularizer:Je(this.kernelRegularizer),kernelConstraint:Et(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new M(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class aa extends ia{constructor(e){super(2,e),aa.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Vg(e.kernelSize,"number",1,2))throw new M(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}aa.className="Conv2D";ie(aa);class la extends ia{constructor(e){super(3,e),la.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new M(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}la.className="Conv3D";ie(la);class my extends aa{constructor(e){if(super(e),this.inputSpec=[new $t({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ve(e),e.length!==4)throw new M("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new $t({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return U(()=>{let s=$e(e);if(s.shape.length!==4)throw new M(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);const l=r[i],u=r[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=ws(l,d,c,this.padding),m=ws(u,p,h,this.padding),g=[o,f,m,this.filters];this.dataFormat!=="channelsLast"&&(s=Oe(s,[0,2,3,1]));let y=hd(s,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Oe(y,[0,3,1,2])),this.bias!=null&&(y=ms(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=Ve(e);const t=e.slice();let s,r,o;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3):(s=3,r=1,o=2);const i=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[s]=this.filters,t[r]=ws(t[r],l,i,this.padding),t[o]=ws(t[o],u,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}my.className="Conv2DTranspose";ie(my);class gy extends la{constructor(e){if(super(e),this.inputSpec=[new $t({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ve(e),e.length!==5)throw new M("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new $t({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return U(()=>{let s=$e(e);if(s.shape.length!==5)throw new M(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let i,a,l;this.dataFormat==="channelsFirst"?(l=2,i=3,a=4):(l=1,i=2,a=3);const u=r[l],c=r[i],h=r[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=ws(u,m,d,this.padding),v=ws(c,g,p,this.padding),x=ws(h,y,f,this.padding),S=[o,b,v,x,this.filters];this.dataFormat!=="channelsLast"&&(s=Oe(s,[0,2,3,4,1]));let k=vm(s,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=Oe(k,[0,4,1,2,3])),this.bias!==null&&(k=ms(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=Ve(e);const t=e.slice();let s,r,o,i;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3,i=4):(s=4,r=1,o=2,i=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[r]=ws(t[r],c,a,this.padding),t[o]=ws(t[o],h,l,this.padding),t[i]=ws(t[i],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}gy.className="Conv3DTranspose";ie(gy);class yI extends ia{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new M("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new M("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new M(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=st(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=rt(t.depthwiseRegularizer),this.depthwiseConstraint=At(t.depthwiseConstraint),this.pointwiseInitializer=st(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=rt(t.pointwiseRegularizer),this.pointwiseConstraint=At(t.pointwiseConstraint)}build(e){if(e=Ve(e),e.length<this.rank+2)throw new M(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new M(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let a=0;a<this.rank;++a)o.push(1);o.push(s*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new $t({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return U(()=>{e=$e(e);let s;if(this.rank===1)throw new Te("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Oe(e,[0,2,3,1])),s=Nd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ms(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Oe(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ct(this.depthwiseInitializer),e.pointwiseInitializer=ct(this.pointwiseInitializer),e.depthwiseRegularizer=Je(this.depthwiseRegularizer),e.pointwiseRegularizer=Je(this.pointwiseRegularizer),e.depthwiseConstraint=Et(this.depthwiseConstraint),e.pointwiseConstraint=Et(this.pointwiseConstraint),e}}yI.className="SeparableConv";class yy extends yI{constructor(e){super(2,e)}}yy.className="SeparableConv2D";ie(yy);class Fu extends ia{constructor(e){super(1,e),Fu.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Vg(e.kernelSize,"number",1,1))throw new M(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Fu.className="Conv1D";ie(Fu);class by extends De{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return U(()=>{if(e=$e(e),this.dataFormat==="channelsLast"){const s=qu(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return qu(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=qu(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return qu(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}by.className="Cropping2D";ie(by);class xy extends De{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,AO(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return U(()=>{let s=$e(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Oe(s,[0,2,3,1]);const o=this.size[0]*r[2],i=this.size[1]*r[3],a=this.interpolation==="nearest"?Ln.resizeNearestNeighbor(s,[o,i]):Ln.resizeBilinear(s,[o,i]);return Oe(a,[0,3,1,2])}else{const o=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?Ln.resizeNearestNeighbor(s,[o,i]):Ln.resizeBilinear(s,[o,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}xy.className="UpSampling2D";ie(xy);function IP(n,e,t=[1,1],s="valid",r,o){return U(()=>{r==null&&(r=cs()),xt(r);let i=fy(n,r);if(n.rank!==4)throw new M(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new M(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=Ji(i,e,t,s==="same"?"same":"valid","NHWC",o),r==="channelsFirst"&&(i=Oe(i,[0,3,1,2])),i})}class wy extends lp{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=st(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=At(e.depthwiseConstraint),this.depthwiseRegularizer=rt(e.depthwiseRegularizer)}build(e){if(e=Ve(e),e.length<4)throw new M(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new M(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return U(()=>{e=$e(e);let s=IP(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ms(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Ve(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=ls(t,this.kernelSize[0],this.padding,this.strides[0]),i=ls(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,o,i]:[e[0],o,i,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ct(this.depthwiseInitializer),e.depthwiseRegularizer=Je(this.depthwiseRegularizer),e.depthwiseConstraint=Et(this.depthwiseRegularizer),e}}wy.className="DepthwiseConv2D";ie(wy);function bI(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new M("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(o){return o==null||Array.isArray(o)?o:[o]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function xI(n,e,t,s=!1,r,o,i=!1,a=!1){return U(()=>{const l=e.shape.length;if(l<3)throw new M(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(us(2,l));e=Oe(e,u),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=le(le(r,"bool"),"float32"),r.rank===l-1&&(r=Wt(r,-1)),r=Oe(r,u)),s&&(e=Vn(e,0),r!=null&&(r=Vn(r,0)));const c=[];let h,d=t;const p=e.shape[0],f=Wn(e);let m;r!=null&&(m=Wn(r));for(let y=0;y<p;++y){const b=f[y],v=U(()=>n(b,d));if(r==null)h=v[0],d=v[1];else{const x=U(()=>{const S=m[y],k=pe(kn(S),S),D=re(P(v[0],S),P(d[0],k)),F=d.map((A,R)=>re(P(v[1][R],S),P(A,k)));return{output:D,newStates:F}});h=x.output,d=x.newStates}a&&c.push(h)}let g;return a&&(g=rn(c,1)),[h,g,d]})}class gs extends De{constructor(e){super(e);let t;if(e.cell==null)throw new M("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new hp({cells:e.cell}):t=e.cell,t.stateSize==null)throw new M("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new $t({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return us(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){cf(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const o=[];for(const i of t)o.push([e[0],i]);return[r].concat(o)}else return r}computeMask(e,t){return U(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(o=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Te("Constants support is not implemented in RNN yet.");cf(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new $t({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!_e(this.stateSpec.map(i=>i.shape[i.shape.length-1]),o))throw new M(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(i=>new $t({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){U(()=>{if(!this.stateful)throw new bs("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>mt([s,r])):this.states_=[mt([s,this.cell.stateSize])];else if(e==null)Se(this.states_),this.keptStates!=null&&(Se(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>mt([s,r])):this.states_[0]=mt([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Se(this.states_);for(let r=0;r<this.states_.length;++r){const o=e[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,i];if(!_e(o.shape,a))throw new M(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${o.shape}`);this.states_[r]=o}}this.states_=this.states_.map(r=>kt(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const o=bI(e,s,r,this.numConstants);e=o.inputs,s=o.initialState,r=o.constants;let i=[],a=[];if(s!=null){t.initialState=s,i=i.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new $t({shape:u.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof hs){const u=[e].concat(i),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return U(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let o=t==null?null:t.initialState;e=$e(e),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==i)throw new M(`RNN Layer has ${i} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},u=xI((f,m)=>{const g=this.cell.call([f].concat(m),a);return[g[0],g.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],h=u[1],d=u[2];this.stateful&&this.resetStates(d,r);const p=this.returnSequences?h:c;return this.returnState?[p].concat(d):p})}getInitialState(e){return U(()=>{let t=mt(e.shape);return t=fe(t,[1,2]),t=Tu(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?lf(t,[1,s]):t):this.cell.stateSize>1?[lf(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===gs.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,o=as(r,s);return new e(Object.assign(t,{cell:o}))}}gs.className="RNN";ie(gs);class _u extends De{}class up extends _u{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ft(this.units,"units"),this.activation=$r(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=st(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=st(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=st(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=rt(e.kernelRegularizer),this.recurrentRegularizer=rt(e.recurrentRegularizer),this.biasRegularizer=rt(e.biasRegularizer),this.kernelConstraint=At(e.kernelConstraint),this.recurrentConstraint=At(e.recurrentConstraint),this.biasConstraint=At(e.biasConstraint),this.dropout=Xo([1,vr([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Xo([1,vr([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ve(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return U(()=>{if(e=e,e.length!==2)throw new M(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Sr({ones:()=>kn(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Sr({ones:()=>kn(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let o;const i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?o=ks(P(e,i),this.kernel.read()):o=ks(e,this.kernel.read()),this.bias!=null&&(o=ms(o,this.bias.read())),a!=null&&(s=P(s,a));let l=re(o,ks(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ir(this.activation),useBias:this.useBias,kernelInitializer:ct(this.kernelInitializer),recurrentInitializer:ct(this.recurrentInitializer),biasInitializer:ct(this.biasInitializer),kernelRegularizer:Je(this.kernelRegularizer),recurrentRegularizer:Je(this.recurrentRegularizer),biasRegularizer:Je(this.biasRegularizer),activityRegularizer:Je(this.activityRegularizer),kernelConstraint:Et(this.kernelConstraint),recurrentConstraint:Et(this.recurrentConstraint),biasConstraint:Et(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}up.className="SimpleRNNCell";ie(up);class vy extends gs{constructor(e){e.cell=new up(e),super(e)}call(e,t){return U(()=>{this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return new e(t)}}vy.className="SimpleRNN";ie(vy);class cp extends _u{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new M("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ft(this.units,"units"),this.activation=$r(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$r(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=st(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=st(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=st(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=rt(e.kernelRegularizer),this.recurrentRegularizer=rt(e.recurrentRegularizer),this.biasRegularizer=rt(e.biasRegularizer),this.kernelConstraint=At(e.kernelConstraint),this.recurrentConstraint=At(e.recurrentConstraint),this.biasConstraint=At(e.biasConstraint),this.dropout=Xo([1,vr([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Xo([1,vr([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ve(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return U(()=>{if(e=e,e.length!==2)throw new M(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Sr({ones:()=>kn(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Sr({ones:()=>kn(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=P(e,o[0]));let c=ks(e,this.kernel.read());this.useBias&&(c=ms(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=P(r,i[0]));const h=this.recurrentKernel.read(),[d,p]=dn(h,[2*this.units,this.units],h.rank-1),f=ks(r,d),[m,g,y]=dn(c,3,c.rank-1),[b,v]=dn(f,2,f.rank-1);a=this.recurrentActivation.apply(re(m,b)),l=this.recurrentActivation.apply(re(g,v));const x=ks(P(l,r),p);u=this.activation.apply(re(y,x));const S=re(P(a,r),P(re(1,tt(a)),u));return[S,S]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ir(this.activation),recurrentActivation:Ir(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ct(this.kernelInitializer),recurrentInitializer:ct(this.recurrentInitializer),biasInitializer:ct(this.biasInitializer),kernelRegularizer:Je(this.kernelRegularizer),recurrentRegularizer:Je(this.recurrentRegularizer),biasRegularizer:Je(this.biasRegularizer),activityRegularizer:Je(this.activityRegularizer),kernelConstraint:Et(this.kernelConstraint),recurrentConstraint:Et(this.recurrentConstraint),biasConstraint:Et(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}cp.className="GRUCell";ie(cp);class Iy extends gs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new cp(e),super(e)}call(e,t){return U(()=>{this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Iy.className="GRU";ie(Iy);class Ou extends _u{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ft(this.units,"units"),this.activation=$r(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$r(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=st(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=st(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=st(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=rt(e.kernelRegularizer),this.recurrentRegularizer=rt(e.recurrentRegularizer),this.biasRegularizer=rt(e.biasRegularizer),this.kernelConstraint=At(e.kernelConstraint),this.recurrentConstraint=At(e.recurrentConstraint),this.biasConstraint=At(e.biasConstraint),this.dropout=Xo([1,vr([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Xo([1,vr([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Ve(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,i=this.units;r=new(t=class extends Yn{apply(l,u){const c=o.apply([i]),h=new Jd().apply([i]),d=o.apply([i*2]);return Sx(Sx(c,h),d)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return U(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new M(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Sr({ones:()=>kn(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Sr({ones:()=>kn(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=P(e,i[0]));let d=ks(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=P(r,a[0])),d=re(d,ks(r,this.recurrentKernel.read())),this.useBias&&(d=ms(d,this.bias.read()));const[p,f,m,g]=dn(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=re(P(u,o),P(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=P(h,this.activation.apply(c));return[y,y,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ir(this.activation),recurrentActivation:Ir(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ct(this.kernelInitializer),recurrentInitializer:ct(this.recurrentInitializer),biasInitializer:ct(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Je(this.kernelRegularizer),recurrentRegularizer:Je(this.recurrentRegularizer),biasRegularizer:Je(this.biasRegularizer),activityRegularizer:Je(this.activityRegularizer),kernelConstraint:Et(this.kernelConstraint),recurrentConstraint:Et(this.recurrentConstraint),biasConstraint:Et(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Ou.className="LSTMCell";ie(Ou);class $y extends gs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Ou(e),super(e)}call(e,t){return U(()=>{this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}$y.className="LSTM";ie($y);class hp extends _u{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return U(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const o=[];let i;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?i=[e[0]].concat(s):i=[i[0]].concat(s),i=l.call(i,t),o.push(i.slice(1))}s=[];for(const a of o.slice().reverse())s.push(...a);return[i[0]].concat(s)})}build(e){cf(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Jr(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=o=>({className:o.getClassName(),config:o.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const o of t.cells)r.push(as(o,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return hf(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,o=e.splice(r);for(let i=0;i<s.weights.length;++i)t.push([s.weights[i],o[i]])}Yg(t)}}hp.className="StackedRNNCells";ie(hp);function Sr(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:o}=n,i=()=>o!=null?o(e(),t):Av(e(),t),a=()=>Au(i,e,s);return!r||r<=1?kt(a().clone()):Array(r).fill(void 0).map(a).map(u=>kt(u.clone()))}var $P=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class wI extends gs{constructor(e){if(e.unroll)throw new Te("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Te("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new $t({ndim:5})]}call(e,t){return U(()=>{if(this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new M("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return U(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)],i=mt(o);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e,t=!1){U(()=>{if(!this.stateful)throw new bs("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)];if(s[0]==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>mt(o)):this.states_=[mt(o)];else if(e==null)Se(this.states_),this.keptStates!=null&&(Se(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>mt(o)):this.states_[0]=mt(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Se(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],u=o;if(!_e(l.shape,u))throw new M(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>kt(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:o,strides:i,dilationRate:a}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=ls(u,r[0],o,i[0],a[0]),d=ls(c,r[1],o,i[1],a[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}}wI.className="ConvRNN2D";class dp extends Ou{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:o,dataFormat:i,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ft(this.filters,"filters"),this.kernelSize=Mo(s,2,"kernelSize"),this.kernelSize.forEach(l=>Ft(l,"kernelSize")),this.strides=Mo(r||1,2,"strides"),this.strides.forEach(l=>Ft(l,"strides")),this.padding=o||"valid",Un(this.padding),this.dataFormat=i||"channelsLast",xt(this.dataFormat),this.dilationRate=Mo(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ft(l,"dilationRate"))}build(e){var t;e=Ve(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new M(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],o=4,i=this.kernelSize.concat([r,this.filters*o]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends Yn{apply(d,p){const f=u.apply([c]),m=hn([c]),g=u.apply([c*2]);return Wg([f,m,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return U(()=>{if(e.length!==3)throw new M(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],o=e[1],i=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Sr({ones:()=>kn(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(te,ee,ne)=>!ee||!ee[ne]?te:P(ee[ne],te);let c=u(r,l,0),h=u(r,l,1),d=u(r,l,2),p=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Sr({ones:()=>kn(o),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=u(o,f,0),g=u(o,f,1),y=u(o,f,2),b=u(o,f,3);const v=3,[x,S,k,D]=dn(this.kernel.read(),a,v),[F,A,R,N]=this.useBias?dn(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,x,F,this.padding),h=this.inputConv(h,S,A,this.padding),d=this.inputConv(d,k,R,this.padding),p=this.inputConv(p,D,N,this.padding);const[z,V,j,G]=dn(this.recurrentKernel.read(),a,v);m=this.recurrentConv(m,z),g=this.recurrentConv(g,V),y=this.recurrentConv(y,j),b=this.recurrentConv(b,G);const q=this.recurrentActivation.apply(re(c,m)),J=this.recurrentActivation.apply(re(h,g)),K=re(P(J,i),P(q,this.activation.apply(re(d,y)))),Q=P(this.recurrentActivation.apply(re(p,b)),this.activation.apply(K));return[Q,Q,K]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=$P(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const o=Hs(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?ms(o,s,this.dataFormat):o}recurrentConv(e,t){return Hs(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}dp.className="ConvLSTM2DCell";ie(dp);class Sy extends wI{constructor(e){const t=new dp(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Sy.className="ConvLSTM2D";ie(Sy);class pp extends De{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,o=this.getNoiseShape(s);return Au(()=>Av(s,this.rate,o,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}pp.className="Dropout";ie(pp);class Ny extends pp{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Ny.className="SpatialDropout1D";ie(Ny);class Cy extends De{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ft(this.units,"units"),this.activation=$r(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=st(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=st(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=At(e.kernelConstraint),this.biasConstraint=At(e.biasConstraint),this.kernelRegularizer=rt(e.kernelRegularizer),this.biasRegularizer=rt(e.biasRegularizer),this.activityRegularizer=rt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ve(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ve(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e),r=$v(this.activation.getClassName());let o;return r!=null?o=ks(s,this.kernel.read(),r,this.bias?this.bias.read():null):(o=ks(s,this.kernel.read()),this.bias!=null&&(o=ms(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:Ir(this.activation),useBias:this.useBias,kernelInitializer:ct(this.kernelInitializer),biasInitializer:ct(this.biasInitializer),kernelRegularizer:Je(this.kernelRegularizer),biasRegularizer:Je(this.biasRegularizer),activityRegularizer:Je(this.activityRegularizer),kernelConstraint:Et(this.kernelConstraint),biasConstraint:Et(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Cy.className="Dense";ie(Cy);class ky extends De{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ve(e);for(const t of e.slice(1))if(t==null)throw new M(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],fr(e,1)]}call(e,t){return U(()=>{this.invokeCallHook(e,t);let s=$e(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let o=2;o<s.rank;++o)r.push(o);r.push(1),s=Oe(s,r)}return LO(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}ky.className="Flatten";ie(ky);class Ty extends De{constructor(e){super(e),this.supportsMasking=!0,this.activation=$r(e.activation)}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e);return this.activation.apply(s)})}getConfig(){const e={activation:Ir(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Ty.className="Activation";ie(Ty);class Ey extends De{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return U(()=>(e=$e(e),_O(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Ey.className="RepeatVector";ie(Ey);class Ay extends De{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let o=1,i=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(i===null)i=l;else throw new M("Can only specifiy one unknown dimension.");else o*=u}const a=fr(e);if(i!==null){if(o===0||a%o!==0)throw new M(s);r[i]=a/o}else if(a!==o)throw new M(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e),r=s.shape,o=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return B(s,o)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Ay.className="Reshape";ie(Ay);class Ry extends De{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=us(1,e.dims.length+1);if(!_e(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new $t({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ve(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return Oe($e(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}Ry.className="Permute";ie(Ry);class Dy extends De{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=$e(e);return Ua(io(s,this.maskValue),-1)}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e),i=Ua(io(s,this.maskValue),-1,!0);return P(s,le(i,s.dtype))})}}Dy.className="Masking";ie(Dy);class Fy extends De{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ge(e.inputLength))}this.inputDim=e.inputDim,Ft(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ft(this.outputDim,"outputDim"),this.embeddingsInitializer=st(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=rt(e.embeddingsRegularizer),this.activityRegularizer=rt(e.activityRegularizer),this.embeddingsConstraint=At(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return U(()=>this.maskZero?(e=$e(e),io(e,Pe(e))):null)}computeOutputShape(e){if(e=Ve(e),this.inputLength==null)return[...e,this.outputDim];const t=Ge(this.inputLength);if(t.length!==e.length-1)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const o=t[r],i=e[r+1];if(o!=null&&i!=null&&o!==i)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);o==null&&(t[s]=i),s++}}return[e[0],...t,this.outputDim]}call(e,t){return U(()=>{this.invokeCallHook(e,t);let s=$e(e);s.dtype!=="int32"&&(s=Cs(s,"int32"));const r=Ev(this.embeddings.read(),B(s,[s.size]));return B(r,Ve(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ct(this.embeddingsInitializer),embeddingsRegularizer:Je(this.embeddingsRegularizer),activityRegularizer:Je(this.activityRegularizer),embeddingsConstraint:Et(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Fy.className="Embedding";ie(Fy);class To extends De{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Te}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const o=e[e.length-t.length+r],i=t[r];if(o==null||i==null||o<0||i<0)s.push(null);else if(o===1)s.push(i);else if(i===1)s.push(o);else{if(o!==i)throw new M("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(o)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ve(e)]),e=e,e.length<2)throw new M(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const o of e)o!=null&&o[0]!==null&&t.push(o[0]);if(t=pr(t),t.length>1)throw new M(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let o=1;o<e.length;++o){const i=e[o]==null?null:e[o].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=e.map(o=>o.length);e.indexOf(null)===-1&&pr(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return U(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(o=>o.rank);if(r.indexOf(null)===-1){const o=vr(r);for(let i of e){const a=i.rank;for(let l=0;l<o-a;++l)i=Tu(i,1);s.push(i)}return this.mergeFunction(s)}else{let o=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let p=B(l,[h].concat(fr(c.slice(1))));p=Oe(p,[1,0]),p=B(p,d),s.push(p),o=!0}else if(u>1){const c=us(1,u).concat([0]);s.push(Oe(l,c)),o=!0}else s.push(l)}let i=this.mergeFunction(s);const a=i.rank;if(o){if(a==null){const l=i.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));i=B(Oe(B(i,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat(us(0,a-1));i=Oe(i,l)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,o)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=pr(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return U(()=>{if(t==null)return null;if(!Array.isArray(t))throw new M("`mask` should be an Array");if(!Array.isArray(e))throw new M("`inputs` should be an Array");if(t.length!==e.length)throw new M(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Wt(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Kn(s,t[r]);return s})}}class _y extends To{constructor(e){super(e)}mergeFunction(e){return U(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=re(t,e[s]);return t})}}_y.className="Add";ie(_y);class Oy extends To{constructor(e){super(e)}mergeFunction(e){return U(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=P(t,e[s]);return t})}}Oy.className="Multiply";ie(Oy);class Ly extends To{constructor(e){super(e)}mergeFunction(e){return U(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=re(t,e[s]);return P(1/e.length,t)})}}Ly.className="Average";ie(Ly);class Py extends To{constructor(e){super(e)}mergeFunction(e){return U(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Fs(t,e[s]);return t})}}Py.className="Maximum";ie(Py);class zy extends To{constructor(e){super(e)}mergeFunction(e){return U(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=wr(t,e[s]);return t})}}zy.className="Minimum";ie(zy);class By extends To{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new M("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const o=e[r].slice();o.splice(this.axis,1);let i=!1;for(const a of s)if(_e(a,o)){i=!0;break}i||s.push(o)}if(s.length>1)throw new M("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return U(()=>Wg(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new M("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const o of t.slice(1)){if(s[r]==null||o[r]==null){s[r]=null;break}s[r]+=o[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new M("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new M("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new M(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return U(()=>{let s=!0;if(t.forEach(i=>{if(i!=null){s=!1;return}}),s)return null;const r=[];for(let i=0;i<e.length;++i)t[i]==null?r.push(le(kn(e[i]),"bool")):t[i].rank<e[i].rank?r.push(Wt(t[i],-1)):r.push(t[i]);const o=gt(r,this.axis);return ud(o,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}By.className="Concatenate";ie(By);function va(n,e){for(;n<0;)n+=e;return n}function SP(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Te("batchDot is not implemented for tensors of 4D or higher rank yet");if(C(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),C(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Te("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const o=t;return U(()=>{let i;if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);e=B(e,e.shape.concat(l))}else if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=B(n,n.shape.concat(l))}else i=0;let a;if(n.shape.length===2&&e.shape.length===2)o[0]===o[1]?a=fe(P(n,e),o[0]):a=fe(P(Oe(n,[1,0]),e),o[1]);else{const l=o[0]!==n.shape.length-1,u=o[1]===e.shape.length-1;a=Ae(n,e,l,u)}if(i>0){let l;s>r?l=s+r-3:l=s-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=Dr(a,u)}return a.shape.length===1&&(a=Wt(a,1)),a})}class My extends To{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){C(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Te("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new M(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new M(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((o,i)=>va(o,e[i].shape.length)):r=[va(this.axes,t.shape.length),va(this.axes,s.shape.length)],this.normalize&&(t=Oc(t,r[0]),s=Oc(s,r[1])),SP(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[va(this.axes,e.length),va(this.axes,t.length)],s}computeOutputShape(e){C(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Te("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const o=t.concat(s);return o.length===1&&o.push(1),o}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}My.className="Dot";ie(My);class Vy extends De{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e);return Au(()=>re(Yd(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}Vy.className="GaussianNoise";ie(Vy);class Wy extends De{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return U(()=>{this.invokeCallHook(e,t);const s=$e(e);return this.rate>0&&this.rate<1?Au(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return P(s,Yd(s.shape,1,o))},()=>s,t.training||!1):s})}}Wy.className="GaussianDropout";ie(Wy);class Uy extends De{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||$e(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return U(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Au(()=>{const o=$e(e),a=-1.6732632423543772*1.0507009873554805;let l=er(Rr(s),this.rate);l=Cs(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,h=re(P(o,l),P(re(l,-1),a));return re(P(h,u),c)},()=>$e(e),t.training||!1)}return e})}}Uy.className="AlphaDropout";ie(Uy);function Xa(n,e,t,s,r,o=.001){let i;if(n.rank===2)i=cm(n,e,t,s,r,o);else if(n.rank===3)i=hm(n,e,t,s,r,o);else if(n.rank===4)i=dm(n,e,t,s,r,o);else throw new Te(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return i}function NP(n,e,t,s,r=.001){return U(()=>{const o=gu(n,s),i=o.mean,a=o.variance;return[Xa(n,i,a,t,e,r),i,a]})}function CP(n,e,t,s,r=.001){return U(()=>{const o=gu(n,s),i=o.mean,a=o.variance,l=[];for(const f of us(0,n.rank))s.indexOf(f)!==-1?l.push(1):l.push(n.shape[f]);const u=B(i,l),c=B(a,l),h=e==null?null:B(e,l),d=t==null?null:B(t,l);return[Xa(n,u,c,d,h,r),i,a]})}function kP(n,e,t,s,r=.001){return _e(s.slice().sort(),us(0,n.rank-1))?NP(n,e,t,s,r):CP(n,e,t,s,r)}class Gy extends De{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=st(e.betaInitializer||"zeros"),this.gammaInitializer=st(e.gammaInitializer||"ones"),this.movingMeanInitializer=st(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=st(e.movingVarianceInitializer||"ones"),this.betaConstraint=At(e.betaConstraint),this.gammaConstraint=At(e.gammaConstraint),this.betaRegularizer=rt(e.betaRegularizer),this.gammaRegularizer=rt(e.gammaRegularizer)}build(e){e=Ve(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new M(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new $t({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return U(()=>{const s=t.training==null?!1:t.training,r=$e(e),o=r.shape,i=o.length,a=us(0,i),l=this.axis>=0?this.axis:this.axis+i;a.splice(l,1);const u=uo(1,i);u[l]=o[l];const c=a.slice();c.sort();const h=!_e(c,us(0,i).slice(0,i-1)),d=()=>{if(h){const b=B(this.movingMean.read(),u),v=B(this.movingVariance.read(),u),x=this.center?B(this.beta.read(),u):null,S=this.scale?B(this.gamma.read(),u):null;return Xa(r,b,v,x,S,this.epsilon)}else return Xa(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,m]=kP(r,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,v,x)=>{U(()=>{const S=1-x,k=b.read(),D=P(pe(k,v),S);b.write(pe(k,D))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ct(this.betaInitializer),gammaInitializer:ct(this.gammaInitializer),movingMeanInitializer:ct(this.movingMeanInitializer),movingVarianceInitializer:ct(this.movingVarianceInitializer),betaRegularizer:Je(this.betaRegularizer),gammaRegularizer:Je(this.gammaRegularizer),betaConstraint:Et(this.betaConstraint),gammaConstraint:Et(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Gy.className="BatchNormalization";ie(Gy);class Hy extends De{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=st(e.betaInitializer||"zeros"),this.gammaInitializer=st(e.gammaInitializer||"ones"),this.betaRegularizer=rt(e.betaRegularizer),this.gammaRegularizer=rt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ve(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=t);for(const o of this.axis)if(o<0||o>=t)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==pr(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=$e(e),r=s.shape,o=r.length;return U(()=>{let{mean:a,variance:l}=gu(s,this.axis,!0);const u=uo(1,o);for(const m of this.axis)u[m]=r[m];const c=m=>m!=null&&m.shape.length!==o?B(m,u):m;let h=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const p=[],f=[];for(let m=0;m<o;++m)this.axis.indexOf(m)!==-1?(p.push(r[m]),f.push(1)):(p.push(1),f.push(r[m]));return a=On(a,p),l=On(l,p),h!=null&&(h=On(h,f)),d!=null&&(d=On(d,f)),Xa(s,a,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ct(this.betaInitializer),gammaInitializer:ct(this.gammaInitializer),betaRegularizer:Je(this.betaRegularizer),gammaRegularizer:Je(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Hy.className="LayerNormalization";ie(Hy);function TP(n,e,t){return U(()=>{if(n.rank!==4)throw new M(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new M("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=cs()),t!=="channelsLast"&&t!=="channelsFirst")throw new M(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],tr(n,s)})}class jy extends De{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?cs():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new M(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new M(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new M(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new $t({ndim:4})]}computeOutputShape(e){e=Ve(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return U(()=>TP($e(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}jy.className="ZeroPadding2D";ie(jy);function fp(n,e,t,s,r,o){return U(()=>{xt(r),Nv(o),Un(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=cs()),o==null&&(o="max"),n=fy(n,r);let i;const a=s==="same"?"same":"valid";return o==="max"?i=mu(n,e,t,a):i=au(n,e,t,a),r==="channelsFirst"&&(i=Oe(i,[0,3,1,2])),i})}function vI(n,e,t,s,r,o){return U(()=>{xt(r),Nv(o),Un(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=cs()),o==null&&(o="max"),n=gI(n,r);let i;const a=s==="same"?"same":"valid";return o==="max"?i=Om(n,e,t,a):i=um(n,e,t,a),r==="channelsFirst"&&(i=Oe(i,[0,4,1,2,3])),i})}class II extends De{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new M(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ft(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new M(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ft(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Un(this.padding),this.inputSpec=[new $t({ndim:3})]}computeOutputShape(e){e=Ve(e);const t=ls(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return U(()=>{this.invokeCallHook(e,t),e=Tu($e(e),2);const s=this.poolingFunction($e(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Dr(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class qy extends II{constructor(e){super(e)}poolingFunction(e,t,s,r,o){return xt(o),Un(r),fp(e,t,s,r,o,"max")}}qy.className="MaxPooling1D";ie(qy);class Ky extends II{constructor(e){super(e)}poolingFunction(e,t,s,r,o){return xt(o),Un(r),fp(e,t,s,r,o,"avg")}}Ky.className="AveragePooling1D";ie(Ky);class $I extends De{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new M(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ft(this.poolSize,"poolSize"),Ft(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xt(this.dataFormat),Un(this.padding),this.inputSpec=[new $t({ndim:4})]}computeOutputShape(e){e=Ve(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=ls(t,this.poolSize[0],this.padding,this.strides[0]),s=ls(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return U(()=>(this.invokeCallHook(e,t),this.poolingFunction($e(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Xy extends $I{constructor(e){super(e)}poolingFunction(e,t,s,r,o){return xt(o),Un(r),fp(e,t,s,r,o,"max")}}Xy.className="MaxPooling2D";ie(Xy);class Yy extends $I{constructor(e){super(e)}poolingFunction(e,t,s,r,o){return xt(o),Un(r),fp(e,t,s,r,o,"avg")}}Yy.className="AveragePooling2D";ie(Yy);class SI extends De{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new M(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ft(this.poolSize,"poolSize"),Ft(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xt(this.dataFormat),Un(this.padding),this.inputSpec=[new $t({ndim:5})]}computeOutputShape(e){e=Ve(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=ls(t,this.poolSize[0],this.padding,this.strides[0]),s=ls(s,this.poolSize[1],this.padding,this.strides[1]),r=ls(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return U(()=>(this.invokeCallHook(e,t),this.poolingFunction($e(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Jy extends SI{constructor(e){super(e)}poolingFunction(e,t,s,r,o){return xt(o),Un(r),vI(e,t,s,r,o,"max")}}Jy.className="MaxPooling3D";ie(Jy);class Zy extends SI{constructor(e){super(e)}poolingFunction(e,t,s,r,o){return xt(o),Un(r),vI(e,t,s,r,o,"avg")}}Zy.className="AveragePooling3D";ie(Zy);class NI extends De{constructor(e){super(e),this.inputSpec=[new $t({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Te}}class Qy extends NI{constructor(e){super(e||{})}call(e,t){return U(()=>{const s=$e(e);return ut(s,1)})}}Qy.className="GlobalAveragePooling1D";ie(Qy);class eb extends NI{constructor(e){super(e||{})}call(e,t){return U(()=>{const s=$e(e);return Mn(s,1)})}}eb.className="GlobalMaxPooling1D";ie(eb);class CI extends De{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xt(this.dataFormat),this.inputSpec=[new $t({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Te}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class tb extends CI{call(e,t){return U(()=>{const s=$e(e);return this.dataFormat==="channelsLast"?ut(s,[1,2]):ut(s,[2,3])})}}tb.className="GlobalAveragePooling2D";ie(tb);class nb extends CI{call(e,t){return U(()=>{const s=$e(e);return this.dataFormat==="channelsLast"?Mn(s,[1,2]):Mn(s,[2,3])})}}nb.className="GlobalMaxPooling2D";ie(nb);class kI extends De{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,o=as(r,s);delete t.layer;const i={layer:o};return Object.assign(i,t),new e(i)}}class sb extends kI{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ve(e),e.length<3)throw new M(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ve(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return U(()=>(e=$e(e),xI((i,a)=>[$e(this.layer.call(i,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}sb.className="TimeDistributed";ie(sb);function EP(n){Co(EO,"BidirectionalMergeMode",n)}const AP="concat";class rb extends kI{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=as(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=as(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?AP:e.mergeMode,EP(this.mergeMode),e.weights)throw new Te("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,o;return this.returnState&&(o=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):cn(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const o=bI(e,s,r,this.numConstants);if(e=o.inputs,s=o.initialState,r=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const i=[],a=[];if(s!=null){const u=s.length;if(u%2>0)throw new M("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,i.push(...s);const c=s.map(h=>new $t({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(r!=null)throw new Te("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof hs;for(const u of i)if(u instanceof hs!==l)throw new M("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(i),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return U(()=>{const s=t.initialState;let r,o;if(s==null)r=this.forwardLayer.call(e,t),o=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),o=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(o.slice(1))),r=r[0],o=o[0]),this.returnSequences&&(o=Vn(o,1));let a;return this.mergeMode==="concat"?a=Wg([r,o]):this.mergeMode==="sum"?a=re(r,o):this.mergeMode==="ave"?a=P(.5,re(r,o)):this.mergeMode==="mul"?a=P(r,o):this.mergeMode==null&&(a=[r,o]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Jr(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Jr(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(i=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=as(t.layer);if(delete t.layer,t.numConstants!=null)throw new Te("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}rb.className="Bidirectional";ie(rb);class ob extends De{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return U(()=>(e=$e(e),e.dtype!=="float32"&&(e=Cs(e,"float32")),re(P(e,this.scale),this.offset)))}}ob.className="Rescaling";ie(ob);const{resizeBilinear:RP,cropAndResize:DP}=Ln;class ib extends De{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,o,i,a,l){return U(()=>{let u,c=!1;const h=t/i,d=s/a,p=(r+t)/i,f=(o+s)/a,m=[h,d,p,f],g=[];e.rank===3?(c=!0,u=rn([e])):u=e;for(let S=0;S<u.shape[0];S++)g.push(m);const y=Sn(g,[g.length,4]),b=ao(0,g.length,1,"int32"),x=DP(u,y,b,[r,o],"nearest");return Cs(c?$e(Wn(x)):x,l)})}upsize(e,t,s,r){return U(()=>{const o=RP(e,[t,s]);return Cs(o,r)})}call(e,t){return U(()=>{const s=$e(e),r=s.dtype,o=s.shape,i=o[o.length-3],a=o[o.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,i,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ve(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}ib.className="CenterCrop";ie(ib);function FP(n,e,t,s){let r=$e(n);if(r.dtype!=="int32"&&(r=Cs(r,"int32")),e==="int")return r;const o=r.shape;if(r.rank===0&&(r=Wt(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Wt(r,-1)),r.rank>2)throw new M(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${o} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(e),a=r;let l;if(typeof s<"u"&&e==="count"?l=Ec(a,s,t,i):l=Ec(a,[],t,i),e!=="tfIdf")return l;if(s)return P(l,s);throw new M("When outputMode is 'tfIdf', weights must be provided.")}class ab extends De{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Ve(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return U(()=>{e=$e(e),e.dtype!=="int32"&&(e=Cs(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new M(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=$e(t.countWeights)}const r=Mn(e),o=Uo(e),i=ln(this.numTokens,r).bufferSync().get(0),a=er(o,0).bufferSync().get(0);if(!(i&&a))throw new M(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return FP(e,this.outputMode,this.numTokens,s)})}}ab.className="CategoryEncoding";ie(ab);const _P=["bilinear","nearest"],Wx=new Set(_P);class lb extends De{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(Wx.has(e.interpolation))this.interpolation=e.interpolation;else throw new M(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Ve(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return U(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Ln.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ln.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Wx]} are supported`)})}}lb.className="Resizing";ie(lb);class TI{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}TI.className="RandomSeed";class EI extends De{constructor(e){super(e),this.randomGenerator=new TI(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}EI.className="BaseRandomLayer";const OP=["bilinear","nearest"],Ux=new Set(OP);class ub extends EI{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new M(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new M(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new M(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(Ux.has(s))this.interpolation=s;else throw new M(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ve(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return U(()=>{const s=$e(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Rr([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*r;o=Math.round(o);const i=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Ln.resizeBilinear(e,i);case"nearest":return Ln.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Ux]} are supported`)}})}}ub.className="RandomWidth";ie(ub);function LP(n){return new ra(n)}function PP(n){return new hy(n)}function zP(n){return new ly(n)}function BP(n){return new uy(n)}function MP(n){return new cy(n)}function VP(n){return new py(n)}function WP(n){return new dy(n)}function UP(n){return new Fu(n)}function GP(n){return new aa(n)}function HP(n){return new my(n)}function jP(n){return new la(n)}function qP(n){return new gy(n)}function KP(n){return new yy(n)}function XP(n){return new by(n)}function YP(n){return new xy(n)}function JP(n){return new wy(n)}function ZP(n){return new Ty(n)}function QP(n){return new Cy(n)}function e3(n){return new pp(n)}function t3(n){return new Ny(n)}function n3(n){return new ky(n)}function s3(n){return new Ey(n)}function r3(n){return new Ay(n)}function o3(n){return new Ry(n)}function i3(n){return new Fy(n)}function a3(n){return new _y(n)}function l3(n){return new Ly(n)}function u3(n){return new By(n)}function c3(n){return new Py(n)}function h3(n){return new zy(n)}function d3(n){return new Oy(n)}function p3(n){return new My(n)}function f3(n){return new Gy(n)}function m3(n){return new Hy(n)}function g3(n){return new jy(n)}function cb(n){return new Ky(n)}function y3(n){return cb(n)}function b3(n){return cb(n)}function hb(n){return new Yy(n)}function x3(n){return hb(n)}function w3(n){return hb(n)}function db(n){return new Zy(n)}function v3(n){return db(n)}function I3(n){return db(n)}function $3(n){return new Qy(n)}function S3(n){return new tb(n)}function AI(n){return new eb(n)}function RI(n){return new nb(n)}function DI(n){return new qy(n)}function FI(n){return new Xy(n)}function N3(n){return new Jy(n)}function C3(n){return new Iy(n)}function k3(n){return new cp(n)}function T3(n){return new $y(n)}function E3(n){return new Ou(n)}function A3(n){return new vy(n)}function R3(n){return new up(n)}function D3(n){return new Sy(n)}function F3(n){return new dp(n)}function _3(n){return new gs(n)}function O3(n){return new hp(n)}function L3(n){return new rb(n)}function P3(n){return new sb(n)}const z3=AI,B3=RI,M3=DI,V3=FI;function W3(n){return new Vy(n)}function U3(n){return new Wy(n)}function G3(n){return new Uy(n)}function H3(n){return new Dy(n)}function j3(n){return new ob(n)}function q3(n){return new ib(n)}function K3(n){return new lb(n)}function X3(n){return new ab(n)}function Y3(n){return new ub(n)}const J3=Object.freeze(Object.defineProperty({__proto__:null,Layer:De,RNN:gs,RNNCell:_u,activation:ZP,add:a3,alphaDropout:G3,average:l3,averagePooling1d:cb,averagePooling2d:hb,averagePooling3d:db,avgPool1d:y3,avgPool2d:x3,avgPool3d:v3,avgPooling1d:b3,avgPooling2d:w3,avgPooling3d:I3,batchNormalization:f3,bidirectional:L3,categoryEncoding:X3,centerCrop:q3,concatenate:u3,conv1d:UP,conv2d:GP,conv2dTranspose:HP,conv3d:jP,conv3dTranspose:qP,convLstm2d:D3,convLstm2dCell:F3,cropping2D:XP,dense:QP,depthwiseConv2d:JP,dot:p3,dropout:e3,elu:PP,embedding:i3,flatten:n3,gaussianDropout:U3,gaussianNoise:W3,globalAveragePooling1d:$3,globalAveragePooling2d:S3,globalMaxPool1d:z3,globalMaxPool2d:B3,globalMaxPooling1d:AI,globalMaxPooling2d:RI,gru:C3,gruCell:k3,input:Qv,inputLayer:LP,layerNormalization:m3,leakyReLU:BP,lstm:T3,lstmCell:E3,masking:H3,maxPool1d:M3,maxPool2d:V3,maxPooling1d:DI,maxPooling2d:FI,maxPooling3d:N3,maximum:c3,minimum:h3,multiply:d3,permute:o3,prelu:MP,randomWidth:Y3,reLU:zP,repeatVector:s3,rescaling:j3,reshape:r3,resizing:K3,rnn:_3,separableConv2d:KP,simpleRNN:A3,simpleRNNCell:R3,softmax:VP,spatialDropout1d:t3,stackedRNNCells:O3,thresholdedReLU:WP,timeDistributed:P3,upSampling2d:YP,zeroPadding2d:g3},Symbol.toStringTag,{value:"Module"}));function Z3(n,e){return sy(n,e)}function Q3(n,e){return Wv(n,e)}function ez(n,e){return Uv(n,e)}function tz(n,e){return ry(n,e)}function nz(n,e){return oy(n,e)}function sz(n,e){return Vv(n,e)}function rz(n,e){return PL(n,e)}function oz(n,e){return ny(n,e)}function iz(n,e){return op(n,e)}function az(n,e){return oa(n,e)}function lz(n,e){return oa(n,e)}function uz(n,e){return oa(n,e)}function cz(n,e){return ko(n,e)}function hz(n,e){return ko(n,e)}function dz(n,e){return ko(n,e)}function pz(n,e){return zL(n,e)}const fz=Object.freeze(Object.defineProperty({__proto__:null,MAPE:lz,MSE:hz,binaryAccuracy:Z3,binaryCrossentropy:Q3,categoricalAccuracy:tz,categoricalCrossentropy:nz,cosineProximity:oz,mape:uz,meanAbsoluteError:iz,meanAbsolutePercentageError:az,meanSquaredError:cz,mse:dz,precision:sz,r2Score:pz,recall:rz,sparseCategoricalAccuracy:ez},Symbol.toStringTag,{value:"Module"}));const mz=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:pP},Symbol.toStringTag,{value:"Module"}));function gz(n){return new Du(n)}function yz(n){return bP(n)}function bz(n){return xP(n)}const xz=Object.freeze(Object.defineProperty({__proto__:null,l1:yz,l1l2:gz,l2:bz},Symbol.toStringTag,{value:"Module"}));class _I extends Yo{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Ms))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function Xu(n,e){return n<e}function Gx(n,e){return n>e}class OI extends _I{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Te("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Xu:this.mode==="max"?this.monitorFunc=Gx:this.monitor.indexOf("acc")!==-1?this.monitorFunc=Gx:this.monitorFunc=Xu,this.monitorFunc===Xu&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Xu?1/0:-1/0}async onEpochEnd(e,t){await or(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function wz(n){return new OI(n)}const vz={earlyStopping:wz};const Iz=H();Iz.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var wn;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(wn||(wn={}));var Hx;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(Hx||(Hx={}));const pb={};function $z(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};pb[n]=t}function LI(n){return pb[n]}function Sz(n){delete pb[n]}function I(n,e,t,s,r){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,u=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return Ut(e.inputNames[u],t,s,r);if(o.type==="tensors"){const d=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((f,m)=>{var g;return((g=d[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(f=>Ut(f,t,s,r))}const c=Ut(e.inputNames[u],t,s,r),h=c.dataSync();return o.type==="number"?h[0]:Bn(c.shape,h)}const i=e.attrParams[n];return i&&i.value}function Ut(n,e,t,s){const[r,o]=In(n,t);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const i=t.currentContextIds.find(a=>!!e[Mc(r,a)]);return i!==void 0?e[Mc(r,i)][o]:void 0}function jx(n,e,t){return e[Mc(n,t.currentContextId)]}function Ls(n,e){const[t,s,r]=In(n,e);return[Mc(t,e&&e.currentContextId),s,r]}function Mc(n,e){return e?`${n}-${e}`:n}function In(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const o=s[0],i=s.length===3?s[1]:void 0,a=Number(s[s.length-1]);r=[o,a,i]}return t&&e.parseNodeNameCache.set(n,r),r}function fc(n,e,t){let s=I("pad",n,e,t);if(s==="explicit"){s=I("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function Ps(n){return n.kept?n:Ss(n)}const Nz=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Cz=Object.freeze(Object.defineProperty({__proto__:null,json:Nz},Symbol.toStringTag,{value:"Module"}));const kz=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Tz=Object.freeze(Object.defineProperty({__proto__:null,json:kz},Symbol.toStringTag,{value:"Module"}));const Ez=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Az=Object.freeze(Object.defineProperty({__proto__:null,json:Ez},Symbol.toStringTag,{value:"Module"}));const Rz=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Dz=Object.freeze(Object.defineProperty({__proto__:null,json:Rz},Symbol.toStringTag,{value:"Module"}));const Fz=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],_z=Object.freeze(Object.defineProperty({__proto__:null,json:Fz},Symbol.toStringTag,{value:"Module"}));const Oz=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Lz=Object.freeze(Object.defineProperty({__proto__:null,json:Oz},Symbol.toStringTag,{value:"Module"}));const Pz=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],zz=Object.freeze(Object.defineProperty({__proto__:null,json:Pz},Symbol.toStringTag,{value:"Module"}));const Bz=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Mz=Object.freeze(Object.defineProperty({__proto__:null,json:Bz},Symbol.toStringTag,{value:"Module"}));const Vz=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Wz=Object.freeze(Object.defineProperty({__proto__:null,json:Vz},Symbol.toStringTag,{value:"Module"}));const Uz=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Gz=Object.freeze(Object.defineProperty({__proto__:null,json:Uz},Symbol.toStringTag,{value:"Module"}));const Hz=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],jz=Object.freeze(Object.defineProperty({__proto__:null,json:Hz},Symbol.toStringTag,{value:"Module"}));const qz=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Kz=Object.freeze(Object.defineProperty({__proto__:null,json:qz},Symbol.toStringTag,{value:"Module"}));const Xz=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Yz=Object.freeze(Object.defineProperty({__proto__:null,json:Xz},Symbol.toStringTag,{value:"Module"}));const Jz=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Zz=Object.freeze(Object.defineProperty({__proto__:null,json:Jz},Symbol.toStringTag,{value:"Module"}));const Qz=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],eB=Object.freeze(Object.defineProperty({__proto__:null,json:Qz},Symbol.toStringTag,{value:"Module"}));const tB=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],nB=Object.freeze(Object.defineProperty({__proto__:null,json:tB},Symbol.toStringTag,{value:"Module"}));const sB=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],rB=Object.freeze(Object.defineProperty({__proto__:null,json:sB},Symbol.toStringTag,{value:"Module"}));const oB=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],iB=Object.freeze(Object.defineProperty({__proto__:null,json:oB},Symbol.toStringTag,{value:"Module"}));const aB=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],lB=Object.freeze(Object.defineProperty({__proto__:null,json:aB},Symbol.toStringTag,{value:"Module"}));class qx{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Cz,Tz,Az,Dz,_z,Lz,zz,Mz,Wz,Gz,jz,Kz,Yz,Zz,eB,nB,rB,iB,lB],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],o=[],i=[],a=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?o.push(m[g.name]):(g.input==null||g.input.length===0)&&i.push(m[g.name]),m),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[v,,x]=Ls(y),S=a[v];if(S.outputs!=null){const k=S.outputs.indexOf(x);if(k!==-1){const D=`${v}:${k}`;g.inputNames[b]=D}}g.inputs.push(S),S.children.push(g)})}),Object.keys(h).length===0?d.forEach(m=>{const g=a[m];g.children.length===0&&u.push(g)}):Object.keys(h).forEach(m=>{const[g]=Ls(m),y=a[g];y!=null&&(y.signatureKey=h[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=Ls(m),y=a[g];y&&(y.signatureKey=c[m],l.push(y))}):l=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:a,inputs:l,outputs:u,weights:o,placeholders:r,signature:t,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=LI(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,o)=>{const i=o.type;let a;switch(o.type){case"string":a=gf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=gf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=$f(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=$f(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=bf(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=bf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=If(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=If(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=yf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=yf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Nf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Nf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=vf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=vf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Sf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Sf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=xf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=xf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=wf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=wf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=Kx(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Kx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:a,type:i},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let o={};t!=null&&(o=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const i=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=Ls(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:fb(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,i.push(p),o[d]=p}),Object.keys(o).forEach(h=>{const d=o[h];d.inputNames.forEach((p,f)=>{const[m,,g]=Ls(p),y=o[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const v=`${m}:${b}`;d.inputNames[f]=v}}d.inputs.push(y),y.children.push(d)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=Ls(u[h.name]),f=o[d];f!=null&&(f.defaultOutput=p,a.push(f))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function uB(n){const e=H().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function PI(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):uB(n);return e?t:t.toLowerCase()}function gf(n,e,t,s=!1){const r=n[e];return r!=null?PI(r.s,s):t}function yf(n,e,t){const s=n[e];return s?s.b:t}function bf(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function fb(n){switch(typeof n=="string"&&(n=wn[n]),n){case wn.DT_FLOAT:case wn.DT_HALF:return"float32";case wn.DT_INT32:case wn.DT_INT64:case wn.DT_INT8:case wn.DT_UINT8:return"int32";case wn.DT_BOOL:return"bool";case wn.DT_DOUBLE:return"float32";case wn.DT_STRING:return"string";case wn.DT_COMPLEX64:case wn.DT_COMPLEX128:return"complex64";default:return null}}function Kx(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function xf(n,e,t){const s=n[e];return s&&s.type?fb(s.type):t}function wf(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>fb(r)):t}function zI(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function vf(n,e,t){const s=n[e];return s&&s.shape?zI(s.shape):t}function If(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function $f(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(o=>PI(o,s)):t}function Sf(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>zI(r)):t}function Nf(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class cB{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return Ut(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Ut(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return bf(this.node.rawAttrs,e,t);if(s.s!=null)return gf(this.node.rawAttrs,e,t);if(s.b!=null)return yf(this.node.rawAttrs,e,t);if(s.shape!=null)return vf(this.node.rawAttrs,e,t);if(s.type!=null)return xf(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return If(this.node.rawAttrs,e,t);if(s.list.s!=null)return $f(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Sf(this.node.rawAttrs,e,t);if(s.list.b!=null)return Nf(this.node.rawAttrs,e,t);if(s.list.type!=null)return wf(this.node.rawAttrs,e,t)}return t}}const Yt=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:jf,abs:It,acos:em,acosh:tm,add:re,addN:Sw,all:ud,any:Ua,argMax:so,argMin:nm,asin:sm,asinh:rm,atan:om,atan2:im,atanh:am,avgPool:au,avgPool3d:um,basicLSTMCell:Nw,batchNorm:Yi,batchNorm2d:cm,batchNorm3d:hm,batchNorm4d:dm,batchToSpaceND:lu,bincount:pm,bitwiseAnd:Cw,booleanMaskAsync:c1,broadcastArgs:kw,broadcastTo:Yr,buffer:Ee,cast:le,ceil:fm,clipByValue:mn,clone:Ss,complex:Gs,concat:gt,concat1d:mm,concat2d:gm,concat3d:ym,concat4d:bm,conv1d:cd,conv2d:Hs,conv2dTranspose:hd,conv3d:wm,conv3dTranspose:vm,cos:uu,cosh:dd,cosineWindow:Od,cumprod:ja,cumsum:pd,denseBincount:Ec,depthToSpace:Im,depthwiseConv2d:Ji,diag:Ew,dilation2d:$m,div:ge,divNoNan:Sm,dot:Nm,dropout:Qm,einsum:Wr,elu:Zi,enclosingPowerOfTwo:eg,ensureShape:Aw,equal:Nn,erf:fd,euclideanNorm:km,exp:gn,expandDims:Wt,expm1:Tm,eye:md,fft:Iu,fill:Io,floor:ea,floorDiv:ld,fused:x1,gather:ta,gatherND:f1,greater:ln,greaterEqual:er,ifft:Ko,imag:cu,image:Ln,inTopKAsync:m1,irfft:Ed,isFinite:Em,isInf:Am,isNaN:Rm,leakyRelu:hu,less:Go,lessEqual:Ar,linalg:sg,linspace:Fw,localResponseNormalization:Dm,log:Cn,log1p:du,logSigmoid:Fm,logSoftmax:yd,logSumExp:pu,logicalAnd:Kn,logicalNot:fu,logicalOr:bd,logicalXor:_m,losses:C1,lowerBound:Ow,matMul:Ae,max:Mn,maxPool:mu,maxPool3d:Om,maxPoolWithArgmax:Lw,maximum:Fs,mean:ut,meshgrid:Pw,min:Uo,minimum:wr,mirrorPad:Lm,mod:Pm,moments:gu,movingAverage:h1,mul:P,multiRNNCell:zw,multinomial:Bw,neg:tt,norm:Qi,notEqual:io,oneHot:Ho,ones:hn,onesLike:kn,op:L,outerProduct:Mw,pad:tr,pad1d:Vw,pad2d:Ww,pad3d:Uw,pad4d:Gw,pool:zm,pow:As,prelu:bu,print:Qf,prod:Bm,raggedGather:Hw,raggedRange:jw,raggedTensorToTensor:qw,rand:Kw,randomGamma:Jw,randomNormal:wd,randomStandardNormal:Zw,randomUniform:Rr,randomUniformInt:Qw,range:ao,real:jo,reciprocal:Um,relu:fs,relu6:vd,reshape:B,reverse:Vn,reverse1d:e1,reverse2d:t1,reverse3d:n1,reverse4d:s1,rfft:$u,round:Id,rsqrt:$d,scalar:xe,scatterND:d1,searchSorted:xd,selu:Sd,separableConv2d:Nd,setdiff1dAsync:r1,sigmoid:is,sign:Gm,signal:N1,sin:Cd,sinh:kd,slice:Le,slice1d:xu,slice2d:Td,slice3d:wu,slice4d:qo,softmax:vu,softplus:$o,spaceToBatchND:yu,sparse:k1,sparseToDense:p1,spectral:S1,split:dn,sqrt:Lt,square:Ke,squaredDifference:Ad,squeeze:Dr,stack:rn,step:So,stridedSlice:Hm,string:T1,sub:pe,sum:fe,tan:jm,tanh:xr,tensor:Sn,tensor1d:Ht,tensor2d:dr,tensor3d:qm,tensor4d:o1,tensor5d:i1,tensor6d:a1,tensorScatterUpdate:l1,tile:On,topk:Xm,transpose:Oe,truncatedNormal:Dd,unique:Ym,unsortedSegmentSum:Fd,unstack:Wn,upperBound:u1,variable:Jm,where:_t,whereAsync:Zm,zeros:mt,zerosLike:Pe},Symbol.toStringTag,{value:"Module"}));const hB=(n,e,t,s=Yt)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(I("a",n,e,t),I("b",n,e,t))];case"AddN":return[s.addN(I("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(I("a",n,e,t),I("b",n,e,t))];case"Mul":return[s.mul(I("a",n,e,t),I("b",n,e,t))];case"RealDiv":case"Div":return[s.div(I("a",n,e,t),I("b",n,e,t))];case"DivNoNan":return[s.divNoNan(I("a",n,e,t),I("b",n,e,t))];case"FloorDiv":return[s.floorDiv(I("a",n,e,t),I("b",n,e,t))];case"Sub":return[s.sub(I("a",n,e,t),I("b",n,e,t))];case"Minimum":return[s.minimum(I("a",n,e,t),I("b",n,e,t))];case"Maximum":return[s.maximum(I("a",n,e,t),I("b",n,e,t))];case"Pow":return[s.pow(I("a",n,e,t),I("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(I("a",n,e,t),I("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const dB=(n,e,t,s=Yt)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(I("x",n,e,t))];case"Acos":return[s.acos(I("x",n,e,t))];case"Acosh":return[s.acosh(I("x",n,e,t))];case"Asin":return[s.asin(I("x",n,e,t))];case"Asinh":return[s.asinh(I("x",n,e,t))];case"Atan":return[s.atan(I("x",n,e,t))];case"Atan2":return[s.atan2(I("x",n,e,t),I("y",n,e,t))];case"Atanh":return[s.atanh(I("x",n,e,t))];case"Ceil":return[s.ceil(I("x",n,e,t))];case"Complex":return[s.complex(I("real",n,e,t),I("imag",n,e,t))];case"Cos":return[s.cos(I("x",n,e,t))];case"Cosh":return[s.cosh(I("x",n,e,t))];case"Elu":return[s.elu(I("x",n,e,t))];case"Erf":return[s.erf(I("x",n,e,t))];case"Exp":return[s.exp(I("x",n,e,t))];case"Expm1":return[s.expm1(I("x",n,e,t))];case"Floor":return[s.floor(I("x",n,e,t))];case"Log":return[s.log(I("x",n,e,t))];case"Log1p":return[s.log1p(I("x",n,e,t))];case"Imag":return[s.imag(I("x",n,e,t))];case"Neg":return[s.neg(I("x",n,e,t))];case"Reciprocal":return[s.reciprocal(I("x",n,e,t))];case"Real":return[s.real(I("x",n,e,t))];case"Relu":return[s.relu(I("x",n,e,t))];case"Round":return[s.round(I("x",n,e,t))];case"Selu":return[s.selu(I("x",n,e,t))];case"Sigmoid":return[s.sigmoid(I("x",n,e,t))];case"Sin":return[s.sin(I("x",n,e,t))];case"Sign":return[s.sign(I("x",n,e,t))];case"Sinh":return[s.sinh(I("x",n,e,t))];case"Softplus":return[s.softplus(I("x",n,e,t))];case"Sqrt":return[s.sqrt(I("x",n,e,t))];case"Square":return[s.square(I("x",n,e,t))];case"Tanh":return[s.tanh(I("x",n,e,t))];case"Tan":return[s.tan(I("x",n,e,t))];case"ClipByValue":return[s.clipByValue(I("x",n,e,t),I("clipValueMin",n,e,t),I("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(I("x",n,e,t))];case"Rsqrt":return[s.rsqrt(Ut(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(I("x",n,e,t),I("alpha",n,e,t))];case"Prelu":return[s.prelu(I("x",n,e,t),I("alpha",n,e,t))];case"IsNan":return[s.isNaN(Ut(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(Ut(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(Ut(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function jn(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){C(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],o=e[s];C(r<0||o<0||r===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function Xx(n){return!(typeof n=="number"||n.some(e=>e<0))}function Ia(n,e,t){let s=Cf(n,t);const r=!Xx(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=Cf(o.shape,s)}),!Xx(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Cf(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:o}return t}class pB{constructor(e,t,s,r,o,i,a){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=xe(0),kt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),jn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,kt(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Sn([],[0].concat(this.elementShape));const s=this.readMany(e);return jn(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),rn(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Sn([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return jn(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),gt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Wn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:t.size/s,i=[];U(()=>{t=B(t,[1,s,o]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:r[l-1],0],h=[1,e[l],o];i[l]=B(Le(t,c,h),this.elementShape)}return i});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,i)}}class ho{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);jn(t,o.shape,"TensorList shape mismatch: "),kt(o)}),this.idTensor=xe(0),this.maxNumElements=r,kt(this.idTensor)}copy(){return new ho([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);jn(e,this.elementShape,"TensorList shape mismatch: ");const r=Ia(this.elementShape,this.tensors,e);return U(()=>{const o=this.tensors.map(i=>B(i,r));return rn(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Ia(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,jn(r.shape,e,"TensorList shape mismatch: "),B(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(jn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");kt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new ho([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);jn(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Ia(this.elementShape,this.tensors,t);return B(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);jn(this.elementShape,t.shape,"TensorList shape mismatch: "),kt(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);jn(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Ia(this.elementShape,this.tensors,s);return e.length===0?Sn([],[0].concat(r)):U(()=>{const o=e.map(i=>B(this.tensors[i],r));return rn(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);jn(this.elementShape,t,"TensorList shape mismatch: ");const s=Ia(this.elementShape,this.tensors,t);return this.size()===0?Sn([],[0].concat(s)):U(()=>{const r=this.tensors.map(o=>B(o,s));return gt(r,0)})}}function fB(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);jn(r,e,"TensorList shape mismatch: ");const o=Wn(n);return new ho(o,e,s)}function mB(n,e,t,s){return new ho([],n,e,s)}function gB(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new ho([],t,n.dtype,s),i=Wn(n,0);return e.forEach((a,l)=>{o.setItem(a,i[l])}),o}function yB(n,e,t){let s=0;const r=e.map(c=>(s+=c,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),i=Cf(o,t),a=s===0?0:n.size/s,l=U(()=>{const c=[];n=B(n,[1,s,a]);for(let h=0;h<e.length;++h){const p=[0,h===0?0:r[h-1],0],f=[1,e[h],a];c[h]=B(Le(n,p,f),i)}return n.dispose(),c}),u=new ho([],t,n.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}const bB=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=I("thenBranch",n,e,t),r=I("elseBranch",n,e,t),o=I("cond",n,e,t),i=I("args",n,e,t);return(await o.data())[0]?t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=I("body",n,e,t),r=I("cond",n,e,t),o=I("args",n,e,t),i=await t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),a=o.map(c=>c.id);let l=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){const c=u;u=await t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const s=I("pred",n,e,t);return[Ps(s)]}case"Switch":{const s=I("pred",n,e,t);let r=I("data",n,e,t);return r.kept||(r=Ps(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>Ut(r,e,t)!==void 0);if(s){const r=Ut(s,e,t);return[Ps(r)]}return}case"Enter":{const s=I("frameName",n,e,t),r=I("tensor",n,e,t);return t.enterFrame(s),[Ps(r)]}case"Exit":{const s=I("tensor",n,e,t);return t.exitFrame(),[Ps(s)]}case"NextIteration":{const s=I("tensor",n,e,t);return t.nextIteration(),[Ps(s)]}case"TensorArrayV3":{const s=I("size",n,e,t),r=I("dtype",n,e,t),o=I("elementShape",n,e,t),i=I("dynamicSize",n,e,t),a=I("clearAfterRead",n,e,t),l=I("identicalElementShapes",n,e,t),u=I("name",n,e,t),c=new pB(u,r,s,o,l,i,a);return t.addTensorArray(c),[c.idTensor,xe(1)]}case"TensorArrayWriteV3":{const s=I("tensorArrayId",n,e,t),r=I("index",n,e,t),o=I("tensor",n,e,t),i=t.getTensorArray(s.id);return i.write(r,o),[i.idTensor]}case"TensorArrayReadV3":{const s=I("tensorArrayId",n,e,t),r=I("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=I("tensorArrayId",n,e,t),r=I("indices",n,e,t),o=I("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=I("tensorArrayId",n,e,t),r=I("indices",n,e,t),o=I("tensor",n,e,t),i=t.getTensorArray(s.id);return i.scatter(r,o),[i.idTensor]}case"TensorArrayConcatV3":{const s=I("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),o=I("dtype",n,e,t);return[r.concat(o)]}case"TensorArraySplitV3":{const s=I("tensorArrayId",n,e,t),r=I("tensor",n,e,t),o=I("lengths",n,e,t),i=t.getTensorArray(s.id);return i.split(o,r),[i.idTensor]}case"TensorArraySizeV3":{const s=I("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[xe(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=I("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=I("tensorListId",n,e,t),r=I("index",n,e,t),o=I("tensor",n,e,t),i=t.getTensorList(s.id);return i.setItem(r,o),[i.idTensor]}case"TensorListGetItem":{const s=I("tensorListId",n,e,t),r=I("index",n,e,t),o=I("elementShape",n,e,t),i=I("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=I("indices",n,e,t),r=I("tensor",n,e,t),o=I("elementShape",n,e,t),i=I("numElements",n,e,t),a=gB(r,s,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=I("elementShape",n,e,t),r=I("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=I(o,n,e,t),a=n.op==="TensorListReserve"?-1:i,l=mB(s,r,i,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=I("tensorListId",n,e,t),r=I("indices",n,e,t),o=I("elementShape",n,e,t),i=I("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,i,o)]}case"TensorListStack":{const s=I("tensorListId",n,e,t),r=I("elementShape",n,e,t),o=I("elementDType",n,e,t),i=I("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,o,i)]}case"TensorListFromTensor":{const s=I("tensor",n,e,t),r=I("elementShape",n,e,t),o=I("elementDType",n,e,t),i=fB(s,r,o);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=I("tensorListId",n,e,t),r=t.getTensorList(s.id),o=I("dtype",n,e,t),i=I("elementShape",n,e,t);return[r.concat(o,i)]}case"TensorListPushBack":{const s=I("tensorListId",n,e,t),r=I("tensor",n,e,t),o=t.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=I("tensorListId",n,e,t),r=I("elementShape",n,e,t),o=I("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=I("tensor",n,e,t),r=I("elementShape",n,e,t),o=I("lengths",n,e,t),i=yB(s,o,r);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=I("tensorListId",n,e,t),r=t.getTensorList(s.id);return[xe(r.size(),"int32")]}case"TensorListResize":{const s=I("tensorListId",n,e,t),r=I("size",n,e,t),i=t.getTensorList(s.id).resize(r);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Yx(n,e,t){const[s,r]=I("fusedOps",n,e,t),o=s==="biasadd",i=!o,a=r==="prelu",l=s==="fusedbatchnorm",u=I("numArgs",n,e,t);if(o){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=I("strides",n,e,t),h=fc(n,e,t),d=I("dataFormat",n,e,t).toUpperCase(),p=I("dilations",n,e,t);let[f,m]=I("args",n,e,t);i&&(m=f,f=void 0);const g=I("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const xB=(n,e,t,s=Yt)=>{switch(n.op){case"Conv1D":{const r=I("stride",n,e,t),o=I("pad",n,e,t),i=I("dataFormat",n,e,t).toUpperCase(),a=I("dilation",n,e,t);return[s.conv1d(I("x",n,e,t),I("filter",n,e,t),r,o,i,a)]}case"Conv2D":{const r=I("strides",n,e,t),o=fc(n,e,t),i=I("dataFormat",n,e,t).toUpperCase(),a=I("dilations",n,e,t);return[s.conv2d(I("x",n,e,t),I("filter",n,e,t),[r[1],r[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Yx(n,e,t);return[s.fused.conv2d({x:I("x",n,e,t),filter:I("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Yx(n,e,t);return[s.fused.depthwiseConv2d({x:I("x",n,e,t),filter:I("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=I("outputShape",n,e,t),o=I("strides",n,e,t),i=fc(n,e,t);return[s.conv2dTranspose(I("x",n,e,t),I("filter",n,e,t),r,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=I("strides",n,e,t),o=fc(n,e,t),i=I("dilations",n,e,t),a=I("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(I("input",n,e,t),I("filter",n,e,t),[r[1],r[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("dataFormat",n,e,t).toUpperCase(),a=I("dilations",n,e,t);return[s.conv3d(I("x",n,e,t),I("filter",n,e,t),[r[1],r[2],r[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("kernelSize",n,e,t);return[s.avgPool(I("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("kernelSize",n,e,t);return[s.maxPool(I("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("kernelSize",n,e,t),a=I("includeBatchInIndex",n,e,t),{result:l,indexes:u}=s.maxPoolWithArgmax(I("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o,a);return[l,u]}case"AvgPool3D":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("kernelSize",n,e,t);return[s.avgPool3d(I("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("kernelSize",n,e,t);return[s.maxPool3d(I("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=I("strides",n,e,t),o=I("pad",n,e,t),i=I("dilations",n,e,t),a=r[1],l=r[2],u=i[1],c=i[2];return[s.dilation2d(I("x",n,e,t),I("filter",n,e,t),[a,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const wB=(n,e,t,s=Yt)=>{switch(n.op){case"Fill":{const r=I("shape",n,e,t),o=I("dtype",n,e,t),i=I("value",n,e,t);return[s.fill(r,i,o)]}case"LinSpace":{const r=I("start",n,e,t),o=I("stop",n,e,t),i=I("num",n,e,t);return[s.linspace(r,o,i)]}case"Multinomial":{const r=I("logits",n,e,t),o=I("numSamples",n,e,t),i=I("seed",n,e,t);return[s.multinomial(r,o,i)]}case"OneHot":{const r=I("indices",n,e,t),o=I("depth",n,e,t),i=I("onValue",n,e,t),a=I("offValue",n,e,t),l=I("dtype",n,e,t);return[s.oneHot(r,o,i,a,l)]}case"Ones":return[s.ones(I("shape",n,e,t),I("dtype",n,e,t))];case"OnesLike":return[s.onesLike(I("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(I("shape",n,e,t),I("dtype",n,e,t),I("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(I("shape",n,e,t),I("minval",n,e,t),I("maxval",n,e,t),I("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(I("shape",n,e,t),I("minval",n,e,t),I("maxval",n,e,t),I("seed",n,e,t))];case"Range":{const r=I("start",n,e,t),o=I("stop",n,e,t),i=I("step",n,e,t);return[s.range(r,o,i,I("dtype",n,e,t))]}case"TruncatedNormal":{const r=I("shape",n,e,t),o=I("mean",n,e,t),i=I("stdDev",n,e,t),a=I("seed",n,e,t);return[s.truncatedNormal(r,o,i,I("dtype",n,e,t),a)]}case"Zeros":return[s.zeros(I("shape",n,e,t),I("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(I("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Op(n,e,t){const s=I("boxes",n,e,t),r=I("scores",n,e,t),o=I("maxOutputSize",n,e,t),i=I("iouThreshold",n,e,t),a=I("scoreThreshold",n,e,t),l=I("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}const vB=async(n,e,t,s,r=Yt)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=Op(n,e,t),h=await r.image.nonMaxSuppressionWithScoreAsync(o,i,a,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=Op(n,e,t),c=I("padToMaxOutputSize",n,e,t),h=await r.image.nonMaxSuppressionPaddedAsync(o,i,a,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=Op(n,e,t);return[await r.image.nonMaxSuppressionAsync(o,i,a,l,u)]}case"Where":{const o=r.cast(I("condition",n,e,t),"bool"),i=[await r.whereAsync(o)];return o.dispose(),i}case"ListDiff":return r.setdiff1dAsync(I("x",n,e,t),I("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const IB=(n,e,t,s=Yt)=>{switch(n.op){case"LowerBound":{const r=I("sortedSequence",n,e,t),o=I("values",n,e,t);return[s.lowerBound(r,o)]}case"TopKV2":{const r=I("x",n,e,t),o=I("k",n,e,t),i=I("sorted",n,e,t),a=s.topk(r,o,i);return[a.values,a.indices]}case"UpperBound":{const r=I("sortedSequence",n,e,t),o=I("values",n,e,t);return[s.upperBound(r,o)]}case"Unique":{const r=I("x",n,e,t),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=I("x",n,e,t),o=I("axis",n,e,t),i=s.unique(r,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const $B=(n,e,t,s=Yt)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=I("default",n,e,t);return[Ut(n.name,e,t)||r];case"Placeholder":return[Ut(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=I("x",n,e,t);return[Ps(c)]}case"IdentityN":return I("x",n,e,t).map(c=>Ps(c));case"Snapshot":const o=I("x",n,e,t);return[Ps(o)];case"Shape":return[s.tensor1d(I("x",n,e,t).shape,"int32")];case"ShapeN":return I("x",n,e,t).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(I("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(I("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=I("x",n,e,t),a=I("data",n,e,t),l=I("message",n,e,t),u=I("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class SB{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=xe(0),this.tensorMap=new Map,kt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),U(()=>{const r=Wn(t),o=s.length,i=r.length;C(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const l=s[a],u=r[a];kt(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return U(()=>{const r=[];for(let o=0;o<s.length;o++){const i=s[o],a=this.findWithDefault(i,t);r.push(a)}return rn(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const NB=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const o=I("keyDType",n,e,t),i=I("valueDType",n,e,t),a=new SB(o,i);return s.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=I("tableHandle",n,e,t,s),o=I("keys",n,e,t),i=I("values",n,e,t);return[await s.getHashTableById(r.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=I("tableHandle",n,e,t,s),o=I("keys",n,e,t),i=I("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=I("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const CB=(n,e,t,s=Yt)=>{switch(n.op){case"ResizeBilinear":{const r=I("images",n,e,t),o=I("size",n,e,t),i=I("alignCorners",n,e,t),a=I("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const r=I("images",n,e,t),o=I("size",n,e,t),i=I("alignCorners",n,e,t),a=I("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],i,a)]}case"CropAndResize":{const r=I("image",n,e,t),o=I("boxes",n,e,t),i=I("boxInd",n,e,t),a=I("cropSize",n,e,t),l=I("method",n,e,t),u=I("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,o,i,a,l,u)]}case"ImageProjectiveTransformV3":{const r=I("images",n,e,t),o=I("transforms",n,e,t),i=I("outputShape",n,e,t),a=I("fillValue",n,e,t),l=I("interpolation",n,e,t),u=I("fillMode",n,e,t);return[s.image.transform(r,o,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const kB=(n,e,t,s=Yt)=>{switch(n.op){case"Equal":return[s.equal(I("a",n,e,t),I("b",n,e,t))];case"NotEqual":return[s.notEqual(I("a",n,e,t),I("b",n,e,t))];case"Greater":return[s.greater(I("a",n,e,t),I("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(I("a",n,e,t),I("b",n,e,t))];case"Less":return[s.less(I("a",n,e,t),I("b",n,e,t))];case"LessEqual":return[s.lessEqual(I("a",n,e,t),I("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(I("a",n,e,t),I("b",n,e,t))];case"LogicalNot":return[s.logicalNot(I("a",n,e,t))];case"LogicalOr":return[s.logicalOr(I("a",n,e,t),I("b",n,e,t))];case"Select":case"SelectV2":return[s.where(I("condition",n,e,t),I("a",n,e,t),I("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(I("a",n,e,t),I("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const TB=(n,e,t,s=Yt)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(I("a",n,e,t),I("b",n,e,t),I("transposeA",n,e,t),I("transposeB",n,e,t))];case"Einsum":return[s.einsum(I("equation",n,e,t),...I("tensors",n,e,t))];case"Transpose":return[s.transpose(I("x",n,e,t),I("perm",n,e,t))];case"_FusedMatMul":const[r,o]=I("fusedOps",n,e,t),i=r==="biasadd",a=o==="prelu",l=I("numArgs",n,e,t),u=I("leakyreluAlpha",n,e,t);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=I("args",n,e,t);return[s.fused.matMul({a:I("a",n,e,t),b:I("b",n,e,t),transposeA:I("transposeA",n,e,t),transposeB:I("transposeB",n,e,t),bias:c,activation:o,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[s.linalg.bandPart(I("a",n,e,t),I("numLower",n,e,t),I("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const EB=(n,e,t,s=Yt)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(I("x",n,e,t),I("axis",n,e,t),I("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(I("x",n,e,t),I("mean",n,e,t),I("variance",n,e,t),I("offset",n,e,t),I("scale",n,e,t),I("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(I("x",n,e,t),I("mean",n,e,t),I("variance",n,e,t),I("offset",n,e,t),I("scale",n,e,t),I("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(I("x",n,e,t),I("radius",n,e,t),I("bias",n,e,t),I("alpha",n,e,t),I("beta",n,e,t))];case"Softmax":return[s.softmax(I("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(I("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const AB=(n,e,t,s=Yt)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(I("paramsNestedSplits",n,e,t),I("paramsDenseValues",n,e,t),I("indices",n,e,t),I("outputRaggedRank",n,e,t));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(I("starts",n,e,t),I("limits",n,e,t),I("splits",n,e,t));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(I("shape",n,e,t),I("values",n,e,t),I("defaultValue",n,e,t),I("rowPartitionTensors",n,e,t),I("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const RB=(n,e,t,s=Yt)=>{switch(n.op){case"Max":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.max(I("x",n,e,t),a,l)]}case"Mean":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.mean(I("x",n,e,t),a,l)]}case"Min":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.min(I("x",n,e,t),a,l)]}case"Sum":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.sum(I("x",n,e,t),a,l)]}case"All":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.all(I("x",n,e,t),a,l)]}case"Any":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.any(I("x",n,e,t),a,l)]}case"ArgMax":{const a=I("axis",n,e,t);return[s.argMax(I("x",n,e,t),a)]}case"ArgMin":{const a=I("axis",n,e,t);return[s.argMin(I("x",n,e,t),a)]}case"Prod":{const a=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.prod(I("x",n,e,t),a,l)]}case"Cumprod":{const a=I("axis",n,e,t),l=I("exclusive",n,e,t),u=I("reverse",n,e,t);return[s.cumprod(I("x",n,e,t),a,l,u)]}case"Cumsum":{const a=I("axis",n,e,t),l=I("exclusive",n,e,t),u=I("reverse",n,e,t);return[s.cumsum(I("x",n,e,t),a,l,u)]}case"Bincount":const r=I("x",n,e,t),o=I("weights",n,e,t),i=I("size",n,e,t);return[s.bincount(r,o,i)];case"DenseBincount":{const a=I("x",n,e,t),l=I("weights",n,e,t),u=I("size",n,e,t),c=I("binaryOutput",n,e,t);return[s.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const DB=(n,e,t,s=Yt)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=I("n",n,e,t),o=I("axis",n,e,t);let i=I("tensors",n,e,t);return i=i.slice(0,r),[s.concat(i,o)]}case"Gather":{const r=I("x",n,e,t),o=I("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=I("axis",n,e,t),o=I("batchDims",n,e,t),i=I("x",n,e,t),a=I("indices",n,e,t);return[s.gather(i,s.cast(a,"int32"),r,o)]}case"Reverse":{const r=I("dims",n,e,t),o=[];for(let a=0;a<r.length;a++)r[a]&&o.push(a);const i=I("x",n,e,t);return[s.reverse(i,o)]}case"ReverseV2":{const r=I("axis",n,e,t),o=I("x",n,e,t);return[s.reverse(o,r)]}case"Slice":{const r=I("begin",n,e,t),o=I("size",n,e,t);return[s.slice(I("x",n,e,t),r,o)]}case"StridedSlice":{const r=I("begin",n,e,t),o=I("end",n,e,t),i=I("strides",n,e,t),a=I("beginMask",n,e,t),l=I("endMask",n,e,t),u=I("ellipsisMask",n,e,t),c=I("newAxisMask",n,e,t),h=I("shrinkAxisMask",n,e,t),d=I("x",n,e,t);return[s.stridedSlice(d,r,o,i,a,l,u,c,h)]}case"Pack":return U(()=>{const r=I("axis",n,e,t),o=I("tensors",n,e,t),i=o[0].shape,a=s.squeeze(o[0]).shape,l=o.map(u=>{const c=_e(u.shape,i);if(!c&&!_e(s.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,i)});return[s.stack(l,r)]});case"Unpack":{const r=I("axis",n,e,t),o=I("tensor",n,e,t);return s.unstack(o,r)}case"Tile":{const r=I("reps",n,e,t);return[s.tile(I("x",n,e,t),r)]}case"Split":case"SplitV":{const r=I("axis",n,e,t),o=I("numOrSizeSplits",n,e,t),i=I("x",n,e,t);return s.split(i,o,r)}case"ScatterNd":{const r=I("indices",n,e,t),o=I("values",n,e,t),i=I("shape",n,e,t);return[s.scatterND(r,o,i)]}case"GatherNd":{const r=I("x",n,e,t),o=I("indices",n,e,t);return[s.gatherND(r,o)]}case"SparseToDense":{const r=I("sparseIndices",n,e,t),o=I("outputShape",n,e,t),i=I("sparseValues",n,e,t),a=I("defaultValue",n,e,t);return[s.sparseToDense(r,i,o,i.dtype===a.dtype?a:s.cast(a,i.dtype))]}case"TensorScatterUpdate":{const r=I("indices",n,e,t),o=I("values",n,e,t),i=I("tensor",n,e,t);return[s.tensorScatterUpdate(i,r,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const FB=(n,e,t,s=Yt)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(I("indices",n,e,t),I("values",n,e,t),I("denseShape",n,e,t),I("defaultValue",n,e,t));return[r,o,i,a]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(I("inputIndices",n,e,t),I("inputShape",n,e,t),I("newShape",n,e,t));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(I("data",n,e,t),I("indices",n,e,t),I("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(I("data",n,e,t),I("indices",n,e,t),I("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const _B=(n,e,t,s=Yt)=>{switch(n.op){case"FFT":return[s.fft(I("x",n,e,t))];case"IFFT":return[s.ifft(I("x",n,e,t))];case"RFFT":return[s.rfft(I("x",n,e,t))];case"IRFFT":return[s.irfft(I("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const OB=(n,e,t,s=Yt)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(I("input",n,e,t),I("pattern",n,e,t),I("rewrite",n,e,t),I("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(I("data",n,e,t),I("dataSplits",n,e,t),I("separator",n,e,t),I("nGramWidths",n,e,t),I("leftPad",n,e,t),I("rightPad",n,e,t),I("padWidth",n,e,t),I("preserveShortSequences",n,e,t));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:i}=s.string.stringSplit(I("input",n,e,t),I("delimiter",n,e,t),I("skipEmpty",n,e,t));return[r,o,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(I("input",n,e,t),I("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const LB=(n,e,t,s=Yt)=>{switch(n.op){case"Cast":return[s.cast(I("x",n,e,t),I("dtype",n,e,t))];case"ExpandDims":{const r=I("axis",n,e,t);return[s.expandDims(I("x",n,e,t),r)]}case"Squeeze":{const r=I("axis",n,e,t);return[s.squeeze(I("x",n,e,t),r)]}case"Reshape":return[s.reshape(I("x",n,e,t),I("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(I("x",n,e,t),I("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(I("x",n,e,t),I("padding",n,e,t),I("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(I("x",n,e,t),I("padding",n,e,t),I("constantValue",n,e,t))];case"SpaceToBatchND":{const r=I("blockShape",n,e,t),o=I("paddings",n,e,t);return[s.spaceToBatchND(I("x",n,e,t),r,o)]}case"BatchToSpaceND":{const r=I("blockShape",n,e,t),o=I("crops",n,e,t);return[s.batchToSpaceND(I("x",n,e,t),r,o)]}case"DepthToSpace":{const r=I("blockSize",n,e,t),o=I("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(I("x",n,e,t),r,o)]}case"BroadcastTo":return[s.broadcastTo(I("x",n,e,t),I("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(I("s0",n,e,t),I("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Jx(n,e,t,s,r=U){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return r(()=>hB(i,a,l));case"basic_math":return r(()=>dB(i,a,l));case"control":return bB(i,a,l);case"convolution":return r(()=>xB(i,a,l));case"creation":return r(()=>wB(i,a,l));case"dynamic":return vB(i,a,l);case"evaluation":return r(()=>IB(i,a,l));case"image":return r(()=>CB(i,a,l));case"graph":return r(()=>$B(i,a,l));case"logical":return r(()=>kB(i,a,l));case"matrices":return r(()=>TB(i,a,l));case"normalization":return r(()=>EB(i,a,l));case"ragged":return r(()=>AB(i,a,l));case"reduction":return r(()=>RB(i,a,l));case"slice_join":return r(()=>DB(i,a,l));case"sparse":return r(()=>FB(i,a,l));case"spectral":return r(()=>_B(i,a,l));case"string":return r(()=>OB(i,a,l));case"transformation":return r(()=>LB(i,a,l));case"hash_table":return NB(i,a,l,s);case"custom":const u=LI(i.op);if(u&&u.customExecutor)return u.customExecutor(new cB(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Vs(o)?o.then(i=>[].concat(i)):[].concat(o)}class Zx{constructor(e={},t={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Qx(n,e,t,s){const r=new Set,o=[];let i=null,a=null;const l=new Set,u=new Set(Object.keys(n).map(d=>In(d)[0]));s=s||[];const c=new Set(s.map(d=>In(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((Gr(d)||GB(d)||HB(d))&&i==null&&(i=d,a=i.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),t[d.name]==null&&!u.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:i,syncInputs:a}}function PB(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(g=>In(g)[0]).map(g=>n.nodes[g]),o=n.initNodes||[],i=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...r,...n.weights,...o]).filter(i),u=a([...l,...Object.values(n.nodes)]).filter(i),c=new Map(u.map(g=>[g.name,g])),h={};for(const g of u){h[g.name]=h[g.name]||0;for(const y of g.children)i(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const d=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),p=[...d];for(;d.length>0;){const g=d.pop(),y=c.get(g);for(const b of y.children.filter(i))--h[b.name]===0&&(p.push(b.name),d.push(b.name))}const f=p.map(g=>c.get(g)),m=zB(f,l);return BB(m,l),m}function zB(n,e){const t=new Map(n.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),a=t.get(i);for(const l of a.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(i=>r.has(i.name))}class Yu extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function BB(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),s=new Set(e.map(a=>a.name)),r=a=>s.has(typeof a=="string"?a:a.name),o=new Set(n.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(i)){if(!t.has(l.name))throw new Yu(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new Yu(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!r(a))for(const l of a.inputs){if(!t.has(l.name))throw new Yu(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new Yu(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function MB(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((a,l)=>Gr(a)?t:l),r=a=>{const l=s[e.get(a.name)];return l??-1},o=n.map((a,l)=>a.children.map(r).reduce((u,c)=>Math.max(u,c),s[l])),i=new Map;for(let a=0;a<n.length;++a){const l=o[a];if(l===t)continue;const u=n[a],c=n[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}const VB=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),WB=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),UB=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Gr(n){return VB.has(n.op)}function GB(n){return WB.has(n.op)}function HB(n){return UB.has(n.op)}class Vc{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Vc(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(o=>o.name).sort(),r=t.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=Qx(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:i}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const u=t.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const a=PB(this.graph,s),l=MB(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return kt(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(d=>this.graph.nodes[In(d)[0]]),o=t.map(d=>In(d)[0]),i=new Set(o);let a=o.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(r,a);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=H().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},h={};return U(()=>{const d=new Zx(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,v]=In(y,d),x=[];x[v]=e[y],p[b]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(x))});const f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=u;for(const y of m){if(p[y.name])continue;const b=Jx(y,p,d,this._resourceManager);if(Vs(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,d,f,i,g.get(y.name))}return this.parent==null&&d.dispose(f),t.map(y=>Ut(y,p,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,o,i,a){if(!(Gr(t)||i.has(e))){for(const l of s[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(Gr(l))continue;const u=jx(l.name,s,r);if(u!=null)for(const c of u){if(!c||c.kept||o.has(c.id))continue;const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,o,i){function a(l){return Gr(l)||o.has(l.name)}if(!(Gr(e)||i==null))for(const l of i){if(a(l))continue;const u=jx(l.name,t,s);for(const c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=H().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const i=new Zx(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,t,s),l=t.map(d=>Ut(d,a,i)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(e,t,s){const r=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const o=Object.keys(e),i=o.map(x=>this.graph.nodes[In(x)[0]]),a=s.map(x=>In(x)[0]),l=new Set(a);let u=a.map(x=>this.graph.nodes[x]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:d,syncInputs:p}=Qx(e,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[S,k]=In(x),D=[];D[k]=e[x],m[S]=D});const g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){const x=this.processStack(i,f,t,m,b,y,l,g,c);await Promise.all(x)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=u.filter(x=>!Gr(x)&&!Ut(x.name,m,t)).map(x=>x.name);if(v.length>0){let x="";throw d!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${x}`)}return m}processStack(e,t,s,r,o,i,a,l,u){const c=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&I("isConstant",h.node,r,s)&&([d]=Ls(h.node.name,s)),r[h.node.name]==null){const p=Jx(h.node,r,s,this._resourceManager);d||([d]=Ls(h.node.name,s));const f=s.currentContext;Vs(p)?c.push(p.then(m=>(r[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),s.currentContext=f,this.checkTensorForDisposal(d,h.node,r,s,i,a,l),this.processChildNodes(h.node,t,s,r,o,u),m))):(r[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,r,s,i,a,l),this.processChildNodes(h.node,t,s,r,o,u))}else this.processChildNodes(h.node,t,s,r,o,u)}return c}processChildNodes(e,t,s,r,o,i){e.children.forEach(a=>{const[l]=Ls(a.name,s);o[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!Ut(u,r,s))&&(o[l]=!0,t.push({contexts:s.currentContext,node:a})):a.inputNames.every(u=>!!Ut(u,r,s))&&(o[l]=!0,t.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=In(t),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===s.shape.length&&s.shape.every((l,u)=>i[u]===-1||i[u]===l);C(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&C(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const o in e){const i=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[o];i!=null?r[i.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=In(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=In(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class jB{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const qB="?tfjs-format=file",KB="model.json";class mb{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=dg){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new jB}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Vs(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await dw(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Vc(qx.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=qx.Instance.transformGraph(e.modelInitializer);this.initializer=new Vc(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof ze?[e]:e,s={};return t.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof ze)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,i)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?o[i]=this.resourceIdToCapturedInput[c]:o[i]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r],i=t[o];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Se(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function BI(n,e={},t=dg){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=YB(n));const s=new mb(n,e,t);return await s.load(),s}function XB(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,r]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const o=Tc(s.weightsManifest),i=Jf(s,o,r);e=Ac(i)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=Ac(n);else throw new Error("Unknown model format");const t=new mb(e);return t.load(),t}function YB(n){return n.endsWith("/")||(n=n+"/"),`${n}${KB}${qB}`}const MI="4.22.0";function JB(n,e){return Wc(n,e)}function Wc(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(Jo(n)){const o=Array.isArray(n)?[]:{};s.add(n);for(const i in n){const a=n[i],l=Wc(a,e,t,s);o[i]=l}return s.delete(n),n.__proto__&&(o.__proto__=n.__proto__),o}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function ZB(n,e=WI){return VI(n,e)}function VI(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(Jo(s)){const o=Array.isArray(s)?[]:{};t.add(s);for(const i in s){const a=n.map(u=>u[i]),l=VI(a,e,t);o[i]=l}return t.delete(s),o}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function WI(n){return n===null?null:Jo(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function UI(n,e){const t=new Map;Wc(n,e,t);for(const r of Array.from(t.keys())){const o=t.get(r);if(Vs(o)){const i=await o;t.set(r,i)}}return Wc(n,e,t)}function Jo(n){let e=!1;if(H().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof ze)&&!(n instanceof Promise)&&!e)}function QB(n){return n==null||eM(n)||Array.isArray(n)||typeof n=="object"&&n instanceof ze||Ct(n)}function eM(n){return n===null||typeof n!="object"&&typeof n!="function"}function tM(n){return JB(n,nM)}function nM(n){return n instanceof ze?{value:n.clone(),recurse:!1}:Jo(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class GI{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}class mp extends GI{constructor(){super(mp.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let r=0;r<s;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}mp.INITIAL_CAPACITY=32;function HI(n){return new oM(n)}function gb(n){return new iM(n)}function sM(n,e){return new jI(n,e)}function rM(n,e=ur.FAIL){return new mM(n,e)}class Pt{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new pM(this,e)}filter(e){return new hM(this,e)}map(e){return new dM(this,e)}mapAsync(e){return new e0(this,e)}serialMapAsync(e){return new e0(this,e).serial()}flatmap(e){return new fM(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new cM(this,e,t)}columnMajorBatch(e,t=!0,s=WI){return this.rowMajorBatch(e,t).map(o=>ZB(o,s))}concatenate(e,t){return new jI(HI([this,e]),t)}take(e){return e<0||e==null?this:new uM(this,e)}skip(e){return e<0||e==null?this:new lM(this,e)}prefetch(e){return new qI(this,e)}shuffle(e,t){return new gM(this,e,t)}serial(){return new aM(this)}}class oM extends Pt{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:tM(e),done:!1}}}class iM extends Pt{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class aM extends Pt{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class lM extends Pt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Se(e.value)}return this.upstream.next()}}class uM extends Pt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class cM extends Pt{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class hM extends Pt{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Se(e.value)}}}class dM extends Pt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Us(e.value),s=this.transform(e.value),r=Us(s);for(const o of t)ad(o,r)||o.dispose();return{value:s,done:!1}}}class pM extends Pt{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class e0 extends Pt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Us(e.value),s=await this.transform(e.value),r=Us(s);for(const o of t)ad(o,r)||o.dispose();return{value:s,done:!1}}}class yb extends Pt{constructor(){super(),this.outputQueue=new mp,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class fM extends yb{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Us(e.value),s=this.transform(e.value),r=Us(s);this.outputQueue.pushAll(s);for(const o of t)ad(o,r)||o.dispose();return!0}}class jI extends Pt{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var ur;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(ur||(ur={}));class mM extends Pt{constructor(e,t=ur.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function r(i){return i instanceof Pt?{value:i.next().then(l=>(t++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const o=await UI(this.iterators,r);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case ur.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ur.SHORTEST:return{value:null,done:!0};case ur.LONGEST:}return this.count++,{value:o,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class qI extends Pt{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new GI(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class gM extends qI{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=na.alea(s||Vt().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}class ua{constructor(){this.size=null}batch(e,t=!0){const s=this;C(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),vn(async()=>(await s.iterator()).columnMajorBatch(e,t,xM),r)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,vn(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,vn(async()=>(await t.iterator()).filter(r=>U(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return vn(async()=>(await t.iterator()).map(s=>U(()=>e(s))),this.size)}mapAsync(e){const t=this;return vn(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return vn(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,vn(async()=>{const r=gb(async()=>({value:await t.iterator(),done:!1}));return sM(r.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,vn(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,o=na.alea(t||Vt().toString());return vn(async()=>{let i=o.int32();return s&&(i+=o.int32()),(await r.iterator()).shuffle(e,i.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,vn(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}ua.MAX_BUFFER_SIZE=1e4;function vn(n,e=null){return new class extends ua{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function yM(n){return vn(async()=>HI(n),n.length)}function bM(n){if(!Jo(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return vn(async()=>{const t=await UI(n,s=>{if(s instanceof ua)return{value:s.iterator(),recurse:!1};if(Jo(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return rM(t,ur.SHORTEST)},e)}function xM(n){if(n===null)return null;const e=n[0];return QB(e)?{value:wM(n),recurse:!1}:{value:null,recurse:!0}}function wM(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof ze?rn(n):Sn(n)}class KI extends ua{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}const Ju='"',$a=Symbol("out"),t0=Symbol("field"),Zu=Symbol("quote"),Lp=Symbol("quoteafterquote"),n0=Symbol("quoteinquote");class XI extends ua{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&C(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,o)=>(r[o]=r[o]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(C(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new KI(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(C(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let o=0;o<this.fullColumnNames.length;o++){const i=this.fullColumnNames[o],a=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!a)){const l=t[o];let u=null;if(l==="")if(a&&a.default!==void 0)u=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);u=void 0}else{const c=Number(l);if(isNaN(c))a&&a.dtype==="bool"?u=this.getBoolean(l):u=l;else if(!a||!a.dtype)u=c;else switch(a.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(l);break;default:u=c}}a&&a.isLabel?r[i]=u:s[i]=u}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const o=e.length;let i=$a;for(let a=0;a<o;a++)switch(i){case $a:switch(e.charAt(a)){case Ju:r=a+1,i=Zu;break;case this.delimiter:if(r=a+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),i=$a;break;default:i=t0,r=a;break}break;case t0:switch(e.charAt(a)){case this.delimiter:s.push(e.substring(r,a)),i=$a,r=a+1;break}break;case Zu:switch(e.charAt(a)){case Ju:i=Lp;break}break;case Lp:switch(e.charAt(a)){case this.delimiter:s.push(e.substring(r,a-1)),i=$a,r=a+1;break;case Ju:i=Zu;break;default:i=n0;break}break;case n0:switch(e.charAt(a)){case Ju:i=Zu;break}break}if(i===Lp?s.push(e.substring(r,o-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class bb extends Pt{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!H().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new bb(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const o=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(o),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,o)=>s.set(r,o*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(X(t));return s.set(e,s.length-e.length),Sn(s,t)}}class xb extends Pt{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ht([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,o=(1-s)/2,i=(1-r)/2,a=o+s,l=r+i;this.cropBox=dr([i,o,l,a],[1,4])}else this.cropBox=dr([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!H().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new xb(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&C(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=pg(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return U(()=>{const t=Wt(le(e,"float32"),0);let s;s=Ln.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return B(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class YI{}class JI extends Pt{split(e){return new vM(this,e)}}class vM extends JI{constructor(e,t){super(),this.upstream=e,this.impl=new IM(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class IM extends yb{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}class $M extends Pt{decodeUTF8(){return new SM(this)}}class SM extends JI{constructor(e){super(),this.upstream=e,this.impl=new NM(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class NM extends yb{constructor(e){if(super(),this.upstream=e,H().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return H().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}class ZI extends $M{constructor(e,t={}){super(),this.file=e,this.options=t,C(e instanceof Uint8Array||(H().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const o=new FileReader;o.onload=a=>{let l=o.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(l)},o.onabort=a=>s(new Error("Aborted")),o.onerror=a=>s(new Error(a.type));const i=this.file.slice(this.offset,r);o.readAsArrayBuffer(i)}this.offset=r}),done:!1}}}async function CM(n,e={},t){let s,r;typeof n=="string"?s=n:(s=n.url,r=kM(n));const o=await nw(s,r);if(o.ok){const i=new Uint8Array(await o.arrayBuffer());return new ZI(i,e)}else throw new Error(o.statusText)}const kM=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function QI(n){return typeof n=="string"&&n.slice(0,7)==="file://"}class e$ extends YI{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(QI(this.input)&&H().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new ZI(this.input,this.options)}}class t$ extends YI{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return QI(this.url)?new e$(this.url,this.fileOptions).iterator():CM(this.url,this.fileOptions)}}function TM(n,e={}){return new XI(new t$(n),e)}function EM(n){const e=gb(n);return vn(async()=>e)}function AM(n){return vn(async()=>{const e=await n();return gb(()=>e.next())})}async function RM(n,e){return xb.create(n,e)}async function DM(n){return bb.create(n)}const n$="4.22.0";const FM=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:XI,Dataset:ua,FileDataSource:e$,TextLineDataset:KI,URLDataSource:t$,array:yM,csv:TM,func:EM,generator:AM,microphone:DM,version_data:n$,webcam:RM,zip:bM},Symbol.toStringTag,{value:"Module"}));function me(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&C(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const _M=_d;class Lu extends Jc{nextDataId(){return Lu.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Lf(this,ns())}write(e,t,s){this.firstUse&&(this.firstUse=!1,H().get("IS_NODE")&&Fn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&vs(s[0])){const o=s.map(i=>$s(i));r=this.write(o,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,o){this.data.set(e,{values:t,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return js(r,o)}return G0(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ws(r));return Ee(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ee(e.shape,e.dtype,t)}makeOutput(e,t,s){return ns().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Vt();return e(),{kernelMs:Vt()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){me([e],"where");const t=this.readSync(e.dataId);return _M(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Lu.nextDataId=0;function s$(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const OM=n=>{const{x:e}=n.inputs,t=n.backend;me(e,"abs");let s=new Float32Array(X(e.shape));const r=t.data.get(e.dataId).values;return s=s$(r),t.makeOutput(s,e.shape,e.dtype)},LM={kernelName:tl,backendName:"cpu",kernelFunc:OM};function wt(n){return(e,t,s,r,o)=>{const i=Ne(e,t),a=i.length,l=we(i),u=X(i),c=Ot(o,u),h=e.length,d=t.length,p=we(e),f=we(t),m=oo(e,i),g=oo(t,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<c.length;++y){const b=wo(y,a,l),v=b.slice(-h);m.forEach(D=>v[D]=0);const x=os(v,h,p),S=b.slice(-d);g.forEach(D=>S[D]=0);const k=os(S,d,f);c[y]=n(s[x],r[k])}return[c,i]}}function $n(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",o),imag:t.makeTensorInfo(r.shape,"float32",i)},a}const PM={kernelName:ih,backendName:"cpu",kernelFunc:$n};function Uc(n,e,t="float32"){if(t==="complex64"){const r=Uc(n,e,"float32"),o=Uc(n,e,"float32");return $n({inputs:{real:r,imag:o},backend:n})}const s=jt(X(e),t);return n.makeTensorInfo(e,t,s)}function Ds(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const zM={kernelName:vi,backendName:"cpu",kernelFunc:Ds};function po(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const BM={kernelName:Bh,backendName:"cpu",kernelFunc:po};function r$(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Cr([0],t),[o,i]=wt((a,l)=>a!==l?1:0)(e,[],n,r,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Nr(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Ds({inputs:{x:r},backend:t});const c=Uc(t,r.shape,r.dtype),h=Nr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),d=$n({inputs:{real:h,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const c=po({inputs:{input:r},backend:t}),h=Nr({inputs:{x:c},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(c),h}if(!Bf(r.dtype,o)){const c=Ds({inputs:{x:r},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=t.data.get(r.dataId).values,[a,l,u]=r$(i,r.shape,r.dtype,o);return t.makeTensorInfo(a,l,u)}const MM={kernelName:li,backendName:"cpu",kernelFunc:Nr};function Rt(n,e,t,s){return t==null?({inputs:r,backend:o})=>{const{a:i,b:a}=r,l=o;me([i,a],n);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,h=i.dtype==="string"?qs(u):u,d=i.dtype==="string"?qs(c):c,p=s||i.dtype,[f,m]=e(i.shape,a.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:r,backend:o})=>{const{a:i,b:a}=r,l=o;if(i.dtype==="complex64"||a.dtype==="complex64"){const u=Nr({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=Nr({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,v=l.data.get(y.dataId).values,x=l.data.get(b.dataId).values,[S,k,D]=t(i.shape,a.shape,p,f,v,x),F=l.makeTensorInfo(D,"float32",S),A=l.makeTensorInfo(D,"float32",k),R=$n({inputs:{real:F,imag:A},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(F),l.disposeIntermediateTensorInfo(A),R}else{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,h=s||i.dtype,[d,p]=e(i.shape,a.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function wb(n){return(e,t,s,r,o,i)=>{const a=Ne(e,t),l=X(a),u=a.length,c=we(a),h=Ot("float32",l),d=Ot("float32",l),p=oo(e,a),f=oo(t,a),m=js(s,r),g=js(o,i),y=e.length,b=we(e),v=t.length,x=we(t);if(p.length+f.length===0)for(let S=0;S<h.length;S++){const k=S%m.length,D=S%g.length,F=n(m[k*2],m[k*2+1],g[D*2],g[D*2+1]);h[S]=F.real,d[S]=F.imag}else for(let S=0;S<h.length;S++){const k=wo(S,u,c),D=k.slice(-y);p.forEach(z=>D[z]=0);const F=os(D,y,b),A=k.slice(-v);f.forEach(z=>A[z]=0);const R=os(A,v,x),N=n(m[F*2],m[F*2+1],g[R*2],g[R*2+1]);h[S]=N.real,d[S]=N.imag}return[h,d,a]}}const o$=wt((n,e)=>n+e),VM=wb((n,e,t,s)=>({real:n+t,imag:e+s})),Zo=Rt(vo,o$,VM),WM={kernelName:vo,backendName:"cpu",kernelFunc:Zo};function vb(n,e,t,s,r){const o=X(s),i=jt(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o>0?i[l]+=e[a]:i[l]+=1)}return i}function i$(n,e,t,s=!1){const r=n.shape[0],o=n.shape[1],i=Ee([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<o;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(s?i.set(1,a,u):e.size>0?i.set(i.get(a,u)+e.get(a,l),a,u):i.set(i.get(a,u)+1,a,u))}return i}const a$=wt((n,e)=>n&e),UM=Rt(ul,a$),GM={kernelName:ul,backendName:"cpu",kernelFunc:UM};function _s(n){return(e,t,s)=>{const r=pt(t,e.length);for(let o=0;o<e.length;++o)r[o]=n(e[o],s);return r}}function He(n,e,t){const s=_s(e);return _r(n,s,t)}function _r(n,e,t){return({inputs:s,attrs:r,backend:o})=>{const{x:i}=s;me(i,n);const a=o,l=a.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=qs(l)}else u=l;const c=t||i.dtype,h=e(u,c,r);return a.makeTensorInfo(i.shape,c,h)}}const l$=_s(n=>Math.ceil(n)),HM=_r(ui,l$),jM={kernelName:ui,backendName:"cpu",kernelFunc:HM};function u$(n,e,t,s){const r=pt(t,X(e));if(s&&t!=="string"){let o=0;n.forEach(i=>{const a=X(i.shape);r.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a=t==="string"?qs(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*e[1]+o;for(let h=0;h<i.shape[1];++h)r[c+h]=a[l++]}o+=i.shape[1]})}return r}const c$=wt((n,e)=>n===e?1:0),h$=Rt(bl,c$,null,"bool"),qM={kernelName:bl,backendName:"cpu",kernelFunc:h$};const d$=_s(n=>Math.exp(n)),p$=_r(gi,d$,"float32"),KM={kernelName:gi,backendName:"cpu",kernelFunc:p$};const f$=_s(n=>Math.expm1(n)),XM=_r(yi,f$),YM={kernelName:yi,backendName:"cpu",kernelFunc:XM};const m$=_s(n=>Math.floor(n)),JM=_r(bi,m$),ZM={kernelName:bi,backendName:"cpu",kernelFunc:JM};const g$=wt((n,e)=>Math.floor(n/e)),QM=Rt(xi,g$,null,"int32"),eV={kernelName:xi,backendName:"cpu",kernelFunc:QM};function y$(n,e,t,s,r,o,i,a,l){const u=Ee([s,o],t);for(let c=0;c<s;c++){const h=[];let d=0;for(let p=0;p<r;p++){const f=n[c*r+p];d+=f*i[p],h.push(f)}if(d<0||d>=l/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<o;p++)u.values[c*o+p]=e.get(...e.indexToLoc(d*o+p))}return u}function b$(n,e,t){const s=Ee(t,n.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),a=i[0],l=i[2],u=e.locToIndex([a,l]);i[2]=e.values[u];const c=n.locToIndex(i);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}const x$=wt((n,e)=>n>e?1:0),tV=Rt(Il,x$,null,"bool"),nV={kernelName:Il,backendName:"cpu",kernelFunc:tV};const w$=wt((n,e)=>n>=e?1:0),sV=Rt(wi,w$,null,"bool"),rV={kernelName:wi,backendName:"cpu",kernelFunc:sV};const v$=wt((n,e)=>n<e?1:0),oV=Rt(Sl,v$,null,"bool"),iV={kernelName:Sl,backendName:"cpu",kernelFunc:oV};const I$=wt((n,e)=>n<=e?1:0),aV=Rt(Nl,I$,null,"bool"),lV={kernelName:Nl,backendName:"cpu",kernelFunc:aV};function $$(n,e,t){const s=(e-n)/(t-1),r=jt(t,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}const S$=_s(n=>Math.log(n)),uV=_r(Ni,S$),cV={kernelName:Ni,backendName:"cpu",kernelFunc:uV};function N$(n,e,t,s){const r=Ot(s,X(t));for(let o=0;o<r.length;++o){const i=o*e;let a=n[i];for(let l=0;l<e;++l){const u=n[i+l];(Number.isNaN(u)||u>a)&&(a=u)}r[o]=a}return r}const C$=wt((n,e)=>Math.max(n,e)),hV=Rt(ki,C$),dV={kernelName:ki,backendName:"cpu",kernelFunc:hV};const k$=wt((n,e)=>Math.min(n,e)),pV=Rt(Ti,k$),fV={kernelName:Ti,backendName:"cpu",kernelFunc:pV};const Ib=wt((n,e)=>n*e),mV=wb((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),gp=Rt(Ai,Ib,mV),gV={kernelName:Ai,backendName:"cpu",kernelFunc:gp};function T$(n,e,t){const s=Js(-1,t);return Ib([],e,s,n,t)}function yV(n){const{inputs:e,backend:t}=n,{x:s}=e;me(s,"neg");const r=t.data.get(s.dataId).values,[o,i]=T$(r,s.shape,s.dtype);return t.makeTensorInfo(i,s.dtype,o)}const bV={kernelName:Ll,backendName:"cpu",kernelFunc:yV};const E$=wt((n,e)=>n!==e?1:0),xV=Rt(Pl,E$,null,"bool"),wV={kernelName:Pl,backendName:"cpu",kernelFunc:xV};function $b(n,e,t,s,r){const o=e.length,i=X(e),a=we(e),l=we(r),u=Ot(t,X(r));for(let c=0;c<i;++c){const h=wo(c,o,a),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];const p=os(d,o,l);u[p]=n[c]}return u}function bn(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:o}=t;me(r,"transpose");const i=r.shape.length,a=new Array(i);for(let h=0;h<a.length;h++)a[h]=r.shape[o[h]];const l=s.data.get(r.dataId).values,u=$b(l,r.shape,r.dtype,o,a);return{dataId:s.write(u,a,r.dtype),shape:a,dtype:r.dtype}}const vV={kernelName:Xr,backendName:"cpu",kernelFunc:bn};function A$(n,e,t,s){const[r,o]=Bt(n,s),i=pn(e,"int32"),a=jt(X(r),i),l=X(o);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=t[c+d];a[u]=h}return{outVals:a,outShape:r,outDtype:i}}function IV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;me(r,"prod");const a=r.shape.length,l=Re(o,r.shape),u=dt(l,a);let c=l,h=r;const d=[];u!=null&&(h=bn({inputs:{x:r},backend:t,attrs:{perm:u}}),d.push(h),c=bt(c.length,a));const p=t.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=A$(h.shape,h.dtype,p,c);let y=m;return i&&(y=yt(m,l)),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(y,g,f)}const $V={kernelName:Ul,backendName:"cpu",kernelFunc:IV};function SV(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const o=wo(r,e.length,we(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${t})`)}})}function NV(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function CV(n,e,t,s){const r=[];let o=0;const i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);NV(t,s);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<n.length;++u){let c=n[u],h=n[u]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const m=a[f],g=m[m.length-1]-p[c];for(let y=c;y<h;++y)a[f].push(p[y+1]+g)}c=p[c],h=p[h]}h!==c&&(r.push([c,h]),o+=h-c)}return{outSplits:a,valueSlices:r,numValues:o}}function kV(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=pt("int32",s);e.push(r),n[t].forEach((o,i)=>r[i]=o)}return e}function s0(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function TV(n,e,t,s,r,o){const i=s0(e,2)[1],a=s0(o,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let h=0;h<s;++h)r[l*a+h]=n[c*i+h];++l}}function EV(n,e,t,s,r){const o=e.slice();o[0]=r;const i=pt(t,X(o)),a=n.length,l=a===0?0:a/e[0];return TV(n,e,s,l,i,o),[i,o]}function R$(n,e,t,s,r,o,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(SV(o,i,l),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:h,numValues:d}=CV(o,i,n,u),p=kV(c),f=EV(t,s,r,h,d);return[p,f[0],f[1]]}const r0=2147483647;function D$(n,e,t,s,r,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=r.length===0,u=i.length===0,c=[];a||c.push(e[0]),l||c.push(r[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=pt("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const y=a?n[0]:n[g],b=l?s[0]:s[g],v=u?o[0]:o[g];if(v===0)throw new Error("Requires delta != 0");let x;if(v>0&&b<y||v<0&&b>y)x=0;else if(x=Math.ceil(Math.abs((b-y)/v)),x>r0)throw new Error(`Requires ((limit - start) / delta) <= ${r0}`);d[g+1]=d[g]+x}const p=d[h],f=pt(t,p);let m=0;for(let g=0;g<h;++g){const y=d[g+1]-d[g];let b=a?n[0]:n[g];const v=u?o[0]:o[g];for(let x=0;x<y;++x)f[m++]=b,b+=v}return[d,f]}var Hn=rs;class Gc{constructor(e,t,s,r,o,i,a,l,u,c){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=X1(c),this.raggedRank=Y1(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Hn.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Hn.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Hn.VALUE_ROWIDS:return Gc.getMaxWidthValueRowID(t);case Hn.ROW_SPLITS:return Gc.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Hn[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],o=0;for(let i=1;i<t;++i){const a=e[i];a!==r&&(r=a,o=Math.max(i-s,o),s=i)}return Math.max(t-s,o)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return i0(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;J1(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=K1(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),o=[];let i=0;for(let a=0;a<r;++a,i+=t)o.push(i);for(let a=r;a<e;++a)o.push(-1);return C(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,s,r){const o=e.length,i=[];for(let a=0;a<o-1;++a){const l=e[a+1]-e[a];let u=Math.min(r,l),c=t[a];c===-1&&(u=0);for(let h=0;h<u;++h)i.push(c),c+=s;for(let h=0;h<l-u;++h)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,s,r){const o=e.length,i=[];if(o===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];i.push(u);for(let c=1;c<o;++c){const h=e[c];if(h===l)u>=0&&(++a,a<r?u+=s:u=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}i.push(u)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,s,r){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Hn.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,s,r);case Hn.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,s,r);default:throw new Error(`Unsupported partition type: ${Hn[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Hn.FIRST_DIM_SIZE:return e[0];case Hn.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Hn.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Hn[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const o=i0(s,!1),i=pt(this.valuesDType,X(o));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(e,t,s,r){if(s.length===0)return;const o=this.values,i=s;let a=r.slice();a=a.slice(e+1);const l=X(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;U(()=>{const m=B(c,f);c=Yr(m,a).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=u;++f){let m=f<u?t[f]:-1;if(m===p){++p;continue}if(d<p){const g=o.subarray(h*l),y=i.subarray(d*l),b=(p-d)*l;o0(y,g,b)}if(f>=u){const g=s.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=i.slice(p*l);o0(g,c,l),++p}m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function o0(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function i0(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function F$(n,e,t,s,r,o,i,a,l,u){return new Gc(n,e,t,s,r,o,i,a,l,u).compute()}function _$(n,e,t,s){const r=n===e,o=n<e&&t<0,i=e<n&&t>1;if(r||o||i)return jt(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=jt(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}const O$=_s(n=>1/Math.sqrt(n)),AV=_r(Li,O$),RV={kernelName:Li,backendName:"cpu",kernelFunc:AV};function qr(n,e,t,s,r,o,i,a,l,u){const c=[s/r,r],h=n.values,d=e.values;if(s===0)return Ee(t,e.dtype);const p=l instanceof St?l:Ee(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<o;f++){const m=[];let g=0;for(let y=0;y<i;y++){const b=h[f*i+y];m.push(b),g+=b*a[y]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<r;y++)u?p.values[g*r+y]+=d[f*r+y]:p.values[g*r+y]=e.rank===0?d[0]:d[f*r+y]}return p}const DV=_s(n=>1/(1+Math.exp(-n))),L$=He(Vi,n=>1/(1+Math.exp(-n))),FV={kernelName:Vi,backendName:"cpu",kernelFunc:L$};function P$(n,e,t,s,r){const o=gg(s,e,t),i=X(t),a=we(s);if(o){const h=yg(e,a);return r==="string"?n.slice(h,h+i):n.subarray(h,h+i)}const l=r==="string"?qs(n):n,u=Ee(s,r,l),c=Ee(t,r);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),p=d.map((f,m)=>f+e[m]);c.set(u.get(...p),...d)}return r==="string"?yv(c.values):c.values}function fo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:i}=s;me(r,"slice");const[a,l]=Hd(r,o,i);fg(r,a,l);const u=t.data.get(r.dataId).values,c=P$(u,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,c)}const _V={kernelName:Xl,backendName:"cpu",kernelFunc:fo};function z$(n,e,t,s,r,o,i){const a=e[0],l=o[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(rv(a));const g=pt(t,0),y=pt(r,0);return[g,[0,h],y,u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*h];if(y<0)throw new Error(ov(g,y));if(y>=l)throw new Error(iv(g,y,l));++f[y],d=d&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){const y=f[g]===0;u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const g=n,y=s;for(let b=0;b<a;++b)c[b]=b;return[g,[a,h],y,u,c]}else{const g=f[l-1],y=pt(t,g*h),b=pt(r,g),v=new Array(l).fill(0);for(let x=0;x<a;++x){const S=n[x*h],k=v[S],D=(S===0?0:f[S-1])+k;v[S]++;for(let F=0;F<h;++F)y[D*h+F]=n[x*h+F];b[D]=s[x],c[x]=D}for(let x=0;x<l;++x)if(v[x]===0){const k=x===0?0:f[x-1];y[k*h+0]=x;for(let D=1;D<h;++D)y[k*h+D]=0;b[k]=i}return[y,[g,h],b,u,c]}}function B$(n,e,t,s,r){const o=X(s),i=e[0],a=r.length,l=[];let u=1,c=-1;for(let g=0;g<a;++g){const y=r[g];if(y===-1){if(c!==-1)throw new Error(av(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(lv(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(uv());const g=Math.trunc(o/u);if(u*g!==o)throw new Error(cv(s,l));l[c]=g}if(X(l)!==o)throw new Error(hv(s,l));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let g=d-2;g>=0;--g)p[g]=p[g+1]*s[g+1]}const f=[];if(a>0){f[a-1]=1;for(let g=a-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=pt(t,i*a);for(let g=0;g<i;++g){let y=0;for(let b=0;b<d;++b)y+=n[g*d+b]*p[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[i,a],l]}function Sb(n,e,t,s,r,o=!1,i=0){const a=s.length,l=[e[0],n.length/e[0]],u=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(of());const d=e.slice();d[0]=h;const p=d.reduce((v,x)=>v*x,1),f=pt(t,p);if(a===0)return h>0&&f.fill(i),[f,d];if(h<=0)throw new Error(of());let m=0,g=1,y=0,b=r[m];for(;;){let v=0;if(g<a){if(v=r[g],b===v){++g;continue}if(b>=v)throw new Error(dv())}if(b<0||b>=h)throw new Error(pv(b,h));b>y&&f.fill(i,y*u,b*u);for(let x=m;x<g;++x){const S=s[x];if(S<0||S>=l[0])throw new Error(fv(x,s[x],l[0]));for(let k=0;k<u;k++)f[b*u+k]+=n[S*u+k]}if(o)for(let x=0;x<u;x++)f[b*u+x]/=g-m;if(m=g,++g,y=b+1,b=v,g>a)break}return y<h&&f.fill(i,y*u,h*u),[f,d]}const OV=_s(n=>Math.sqrt(n)),LV=He(Ui,n=>Math.sqrt(n)),PV={kernelName:Ui,backendName:"cpu",kernelFunc:LV};const M$=wt((n,e)=>{const t=n-e;return t*t}),zV=Rt(Gi,M$),BV={kernelName:Gi,backendName:"cpu",kernelFunc:zV};const V$=_s((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),MV=_r(eu,V$),VV={kernelName:eu,backendName:"cpu",kernelFunc:MV};function W$(n,e,t,s){const r=Ee(n,e.dtype);for(let o=0;o<r.size;o++){const i=r.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*t[l]+s[l];r.set(e.get(...a),...i)}return r}class WV{constructor(e,t,s,r,o,i){this.separator=$s(e),this.nGramWidths=t,this.leftPad=$s(s),this.rightPad=$s(r),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),h=i-(u+c),d=t+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let b=0;b<h;++b)p+=e[d+b].length;p+=c*this.rightPad.length;const f=u+c+h-1;p+=f*this.separator.length,s[r+a]=new Uint8Array(p);const m=s[r+a];let g=0;const y=b=>b.forEach(v=>m[g++]=v);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(e[d+b]),y(this.separator);if(h>0){y(e[d+h-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=t[u]>=l;if(c=c&&t[u]<=s,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${s}]`);l=t[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const o=r-1,i=pt("int32",r);if(s===0||r===0){const l=new Array(s);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=t[l];let c=i[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,u,a,c,p,h),c+=p}),this.preserveShort&&c===i[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,u,a,c,1,d)}}return[a,i]}}function U$(n,e,t,s,r,o,i,a){return new WV(t,s,r,o,i,a).compute(n,e)}function UV(n,e,t,s){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)s.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=n.indexOf(o);for(;i!==-1;){const a=n.subarray(0,i);(!t||a.length!==0)&&s.push(a),n=n.subarray(i+1),i=n.indexOf(o)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const i=n.subarray(r,o);(!t||i.length!==0)&&s.push(i),r=o+1}}function G$(n,e,t){const s=n.length,r=[];let o=0,i=0;const a=new Array(s);for(let d=0;d<s;++d){const p=r.length;UV(n[d],e,t,r);const f=r.length-p;a[d]=f,o+=f,i=Math.max(i,f)}const l=pt("int32",o*2),u=new Array(o),c=[s,i];let h=0;for(let d=0;d<s;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,u[h]=r[h],++h;return[l,u,c]}function H$(n,e){const t=pt("int32",n.length);for(let s=0;s<n.length;++s)t[s]=tw(n[s]).modulo(e).getLowBitsUnsigned();return t}const j$=wt((n,e)=>n-e),GV=wb((n,e,t,s)=>({real:n-t,imag:e-s})),Nb=Rt(Hi,j$,GV),HV={kernelName:Hi,backendName:"cpu",kernelFunc:Nb};function q$(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=Ee(t,n.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%n.shape[l];const a=n.locToIndex(i);s.values[r]=n.values[a]}return s}const Ta=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function K$(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*c/a+h)),p=Math.min(s,Math.floor(e+(a-l)*c/a+h));K$(n,e,d,p)}const r=n[e];let o=t,i=s;for(zs(n,t,e),Ta(n[s],r)>0&&zs(n,t,s);o<i;){for(zs(n,o,i),o++,i--;Ta(n[o],r)<0;)o=o+1;for(;Ta(n[i],r)>0;)i=i-1}Ta(n[t],r)===0?zs(n,t,i):(i=i+1,zs(n,i,s)),i<=e&&(t=i+1),e<=i&&(s=i-1)}}function X$(n,e,t,s,r){const o=e[e.length-1],[i,a]=[n.length/o,o],l=Ot(t,i*s),u=Ot("int32",i*s);for(let h=0;h<i;h++){const d=h*a,p=n.subarray(d,d+a);let f=new Array(p.length);p.forEach((b,v)=>f[v]={value:b,index:v}),s<f.length&&(K$(f,s),f=f.slice(0,s)),r&&f.sort(Ta);const m=h*s,g=l.subarray(m,m+s),y=u.subarray(m,m+s);for(let b=0;b<s;b++)g[b]=f[b].value,y[b]=f[b].index}const c=e.slice();return c[c.length-1]=s,[Ee(c,t,l),Ee(c,"int32",u)]}function Y$(n,e,t,s){const r=Re(e,t)[0],o=[1,t[0],1];for(let f=0;f<r;f++)o[0]*=t[f];o[1]=t[r];for(let f=r+1;f<t.length;f++)o[2]*=t[f];const i=new Map,a=new Int32Array(t[r]),l=new St(o,s,n),u=[],c=o[0]===1&&o[2]===1;for(let f=0;f<t[r];f++){let m;if(c)m=n[f].toString();else{const y=[];for(let b=0;b<o[0];b++)for(let v=0;v<o[2];v++)y.push(l.get(b,f,v));m=y.join(",")}const g=i.get(m);if(g!=null)a[f]=g;else{const y=i.size;i.set(m,y),a[f]=y,u.push(f)}}const h=o.slice();h[1]=i.size;const d=new St(h,s);u.forEach((f,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)d.set(l.get(g,f,y),g,m,y)});const p=t.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}const J$=Object.freeze(Object.defineProperty({__proto__:null,addImpl:o$,bincountImpl:vb,bincountReduceImpl:i$,bitwiseAndImpl:a$,castImpl:r$,ceilImpl:l$,concatImpl:u$,equalImpl:c$,expImpl:d$,expm1Impl:f$,floorDivImpl:g$,floorImpl:m$,gatherNdImpl:y$,gatherV2Impl:b$,greaterEqualImpl:w$,greaterImpl:x$,lessEqualImpl:I$,lessImpl:v$,linSpaceImpl:$$,logImpl:S$,maxImpl:N$,maximumImpl:C$,minimumImpl:k$,multiplyImpl:Ib,negImpl:T$,notEqualImpl:E$,prodImpl:A$,raggedGatherImpl:R$,raggedRangeImpl:D$,raggedTensorToTensorImpl:F$,rangeImpl:_$,rsqrtImpl:O$,scatterImpl:qr,sigmoidImpl:DV,simpleAbsImpl:s$,sliceImpl:P$,sparseFillEmptyRowsImpl:z$,sparseReshapeImpl:B$,sparseSegmentReductionImpl:Sb,sqrtImpl:OV,squaredDifferenceImpl:M$,staticRegexReplaceImpl:V$,stridedSliceImpl:W$,stringNGramsImpl:U$,stringSplitImpl:G$,stringToHashBucketFastImpl:H$,subImpl:j$,tileImpl:q$,topKImpl:X$,transposeImpl:$b,uniqueImpl:Y$},Symbol.toStringTag,{value:"Module"}));const Z$="4.22.0";qf("cpu",()=>new Lu,1);const Q$=He(fi,n=>n>=0?n:Math.exp(n)-1),jV={kernelName:fi,backendName:"cpu",kernelFunc:Q$};function eS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s;me([r],"leakyRelu");const i=X(r.shape),a=t.data.get(r.dataId).values,l=Ot("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return t.makeTensorInfo(r.shape,"float32",l)}const qV={kernelName:$l,backendName:"cpu",kernelFunc:eS};const KV=wt((n,e)=>n<0?e*n:n);function tS(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;me([s,r],"prelu");const o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,[a,l]=KV(s.shape,r.shape,o,i,"float32");return t.makeTensorInfo(l,"float32",a)}const XV={kernelName:Wl,backendName:"cpu",kernelFunc:tS};const nS=He(Fi,n=>Math.max(0,n)),YV={kernelName:Fi,backendName:"cpu",kernelFunc:nS};const sS=He(_i,n=>Math.min(Math.max(0,n),6)),JV={kernelName:_i,backendName:"cpu",kernelFunc:sS};function Hc(n,e,t,s,r){if(t==="linear")return Ds({inputs:{x:e},backend:n});if(t==="relu")return nS({inputs:{x:e},backend:n});if(t==="elu")return Q$({inputs:{x:e},backend:n});if(t==="relu6")return sS({inputs:{x:e},backend:n});if(t==="prelu")return tS({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return eS({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return L$({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function nt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,i=X(r.shape),a=zf(o,i),l=X(a);C(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const u=t.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const ZV={kernelName:Gl,backendName:"cpu",kernelFunc:nt};function rS(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;me([r,o],"matMul");const l=r.shape.length,u=o.shape.length,c=i?r.shape[l-2]:r.shape[l-1],h=a?o.shape[u-1]:o.shape[u-2],d=i?r.shape[l-1]:r.shape[l-2],p=a?o.shape[u-2]:o.shape[u-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=X(f),y=X(m),v=Ne(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([d,p]);C(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const x=i?[g,c,d]:[g,d,c],S=a?[y,p,h]:[y,h,p],k=nt({inputs:{x:r},backend:t,attrs:{shape:x}}),D=nt({inputs:{x:o},backend:t,attrs:{shape:S}}),F=i?k.shape[1]:k.shape[2],A=i?k.shape[2]:k.shape[1],R=a?D.shape[1]:D.shape[2],N=Math.max(g,y),z=t.data.get(k.dataId).values,V=t.data.get(D.dataId).values,j=we(k.shape),G=we(D.shape),[q,J,K]=i?[j[0],1,j[1]]:[j[0],j[1],1],[Q,te,ee]=a?[1,G[1],G[0]]:[G[1],1,G[0]],ne=A*R,oe=Ee([N,A,R],k.dtype),ue=oe.values,ae=t.blockSize;for(let de=0;de<N;de++){const be=de%g,ve=de%y;for(let Ie=0;Ie<A;Ie+=ae){const Ce=Math.min(Ie+ae,A);for(let ke=0;ke<R;ke+=ae){const We=Math.min(ke+ae,R);for(let Me=0;Me<F;Me+=ae){const je=Math.min(Me+ae,F);for(let qe=Ie;qe<Ce;qe++)for(let Ue=ke;Ue<We;Ue++){let Ye=0;for(let Ze=Me;Ze<je;Ze++){const Zn=z[be*q+qe*J+Ze*K],vt=V[Ze*Q+Ue*te+ve*ee];Ye+=Zn*vt}ue[de*ne+(qe*R+Ue)]+=Ye}}}}}return t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(D),t.makeTensorInfo(v,oe.dtype,oe.values)}const QV={kernelName:al,backendName:"cpu",kernelFunc:rS};function eW(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=rS({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:u},backend:t}),i&&(p=Zo({inputs:{a:d,b:i},backend:t}),m.push(d),d=p),c&&(f=Hc(t,d,c,a,h),m.push(d),d=f);for(const y of m)t.disposeIntermediateTensorInfo(y);return d}const tW={kernelName:La,backendName:"cpu",kernelFunc:eW};const nW=He(ti,n=>Math.acos(n)),sW={kernelName:ti,backendName:"cpu",kernelFunc:nW};const rW=He(ni,n=>Math.acosh(n)),oW={kernelName:ni,backendName:"cpu",kernelFunc:rW};function iW(n){const{inputs:e,backend:t}=n,s=e;me(e,"addN");const r=s.map(a=>t.data.get(a.dataId).values),o=Ee(s[0].shape,s[0].dtype),i=o.values;for(let a=0;a<s.length;a++){const l=r[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return t.makeTensorInfo(o.shape,o.dtype,o.values)}const aW={kernelName:nl,backendName:"cpu",kernelFunc:iW};function lW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;me(r,"all");const a=Re(o,r.shape);let l=a;const u=dt(l,r.shape.length);let c=r;u!=null&&(c=bn({inputs:{x:r},backend:t,attrs:{perm:u}}),l=bt(l.length,r.shape.length)),Xt("all",l,c.shape.length);const[h,d]=Bt(c.shape,l),p=X(d),f=jt(X(h),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let v=m[b];for(let x=0;x<p;++x){const S=m[b+x];v=v&&S}f[y]=v}u!=null&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(h,c.dtype,f);if(i){const y=yt(h,a),b=nt({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const uW={kernelName:eh,backendName:"cpu",kernelFunc:lW};function cW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;me(r,"any");const a=Re(o,r.shape);let l=a;const u=dt(l,r.shape.length);let c=r;u!=null&&(c=bn({inputs:{x:r},backend:t,attrs:{perm:u}}),l=bt(l.length,r.shape.length)),Xt("any",l,c.shape.length);const[h,d]=Bt(c.shape,l),p=X(d),f=jt(X(h),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let v=m[b];for(let x=0;x<p;++x){const S=m[b+x];v=v||S}f[y]=v}u!=null&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(h,c.dtype,f);if(i){const y=yt(h,a),b=nt({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const hW={kernelName:th,backendName:"cpu",kernelFunc:cW};function dW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;me(r,"argMax");let i=Re(o,r.shape);const a=dt(i,r.shape.length);let l=r;const u=[];a!=null&&(l=bn({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=bt(i.length,l.shape.length)),i=[i[0]],Xt("argMax",i,l.shape.length);const[c,h]=Bt(l.shape,i),d=X(c),p=jt(d,"int32"),f=X(h),m=t.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],v=0;for(let x=0;x<f;++x){const S=m[y+x];S>b&&(b=S,v=x)}p[g]=v}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",p)}const pW={kernelName:sl,backendName:"cpu",kernelFunc:dW};function fW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;me(r,"argMin");let i=Re(o,r.shape);const a=dt(i,r.shape.length);let l=r;const u=[];a!=null&&(l=bn({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=bt(i.length,l.shape.length)),i=[i[0]],Xt("argMin",i,l.shape.length);const[c,h]=Bt(l.shape,i),d=X(c),p=jt(d,"int32"),f=X(h),m=t.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],v=0;for(let x=0;x<f;++x){const S=m[y+x];S<b&&(b=S,v=x)}p[g]=v}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",p)}const mW={kernelName:rl,backendName:"cpu",kernelFunc:fW};const gW=He(si,n=>Math.asin(n)),yW={kernelName:si,backendName:"cpu",kernelFunc:gW};const bW=He(ri,n=>Math.asinh(n)),xW={kernelName:ri,backendName:"cpu",kernelFunc:bW};const wW=He(oi,n=>Math.atan(n)),vW={kernelName:oi,backendName:"cpu",kernelFunc:wW};const IW=wt((n,e)=>Math.atan2(n,e)),$W=Rt(ai,IW),SW={kernelName:ai,backendName:"cpu",kernelFunc:$W};const NW=He(ii,n=>Math.atanh(n)),CW={kernelName:ii,backendName:"cpu",kernelFunc:NW};function Cb(n,e,t,s,r,o){const i=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ee(r.outShape,t),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let x=0;x<r.batchSize;++x){const S=x*y,k=x*s[0];for(let D=0;D<r.inChannels;++D)for(let F=0;F<r.outHeight;++F){const A=F*i-d,R=Math.max(0,A),N=Math.min(r.inHeight,c+A),z=S+F*b;for(let V=0;V<r.outWidth;++V){const j=V*a-p,G=Math.max(0,j),q=Math.min(r.inWidth,h+j);let J=f,K=0,Q=0;for(let ee=R;ee<N;ee+=l){const ne=k+ee*s[1];for(let oe=G;oe<q;oe+=u){const ue=ne+oe*s[2],ae=n[ue+D];o==="max"&&ae>J?J=ae:o==="avg"&&(K+=ae,Q++)}if(isNaN(J))break}const te=z+V*v+D;g[te]=o==="avg"?K/Q:J}}}return m}function oS(n,e,t,s,r=!1,o=!1){const i=Ee(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=Ee(e,t,n);for(let g=0;g<s.batchSize;++g)for(let y=0;y<s.inChannels;++y)for(let b=0;b<s.outHeight;++b){const v=b*a-p;let x=v;for(;x<0;)x+=u;const S=Math.min(s.inHeight,h+v);for(let k=0;k<s.outWidth;++k){const D=k*l-f;let F=D;for(;F<0;)F+=c;const A=Math.min(s.inWidth,d+D);let R=Number.NEGATIVE_INFINITY,N=-1;for(let z=x;z<S;z+=u){const V=z-v;for(let j=F;j<A;j+=c){const G=j-D,q=m.get(g,z,j,y);q>R&&(R=q,r?N=o?((g*s.inHeight+z)*s.inWidth+j)*s.inChannels+y:(z*s.inWidth+j)*s.inChannels+y:N=V*d+G)}}i.set(N,g,b,k,y)}}return i}function iS(n,e,t,s,r,o){const i=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Ee(r.outShape,t),x=v.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],D=r.outShape[3]*r.outShape[4],F=r.outShape[4];for(let A=0;A<r.batchSize;++A){const R=A*S,N=A*s[0];for(let z=0;z<r.inChannels;++z)for(let V=0;V<r.outDepth;++V){const j=V*i-m;let G=j;for(;G<0;)G+=u;const q=Math.min(r.inDepth,d+j),J=R+V*k;for(let K=0;K<r.outHeight;++K){const Q=K*a-g;let te=Q;for(;te<0;)te+=c;const ee=Math.min(r.inHeight,p+Q),ne=J+K*D;for(let oe=0;oe<r.outWidth;++oe){const ue=oe*l-y;let ae=ue;for(;ae<0;)ae+=h;const de=Math.min(r.inWidth,f+ue),be=ne+oe*F;let ve=b,Ie=0,Ce=0;for(let We=G;We<q;We+=u){const Me=N+We*s[1];for(let je=te;je<ee;je+=c){const qe=Me+je*s[2];for(let Ue=ae;Ue<de;Ue+=h){const Ye=qe+Ue*s[3],Ze=n[Ye+z];if(o==="max"&&Ze>ve?ve=Ze:o==="avg"&&(Ie+=Ze,Ce++),isNaN(ve))break}if(isNaN(ve))break}if(isNaN(ve))break}const ke=be+z;x[ke]=o==="avg"?Ie/Math.max(Ce,1):ve}}}}return v}function kW(n,e){const t=Ee(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*s-d;let v=b;for(;v<0;)v+=i;const x=Math.min(e.inDepth,u+b);for(let S=0;S<e.outHeight;++S){const k=S*r-p;let D=k;for(;D<0;)D+=a;const F=Math.min(e.inHeight,c+k);for(let A=0;A<e.outWidth;++A){const R=A*o-f;let N=R;for(;N<0;)N+=l;const z=Math.min(e.inWidth,h+R);let V=Number.NEGATIVE_INFINITY,j=-1;for(let G=v;G<x;G+=i){const q=G-b;for(let J=D;J<F;J+=a){const K=J-k;for(let Q=N;Q<z;Q+=l){const te=Q-R,ee=n.get(m,G,J,Q,g);ee>=V&&(V=ee,j=q*c*h+K*c+te)}}}t.set(j,m,y,S,A,g)}}}return t}function TW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;me(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;C(Kt(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Xn(r.shape,o,i,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&_e(c.inShape,c.outShape))h=Ds({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=we(r.shape),f=Cb(d,r.shape,r.dtype,p,c,"avg");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const EW={kernelName:ol,backendName:"cpu",kernelFunc:TW};function AW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=s;me(r,"avgPool3d");const c=Zs(r.shape,o,i,1,a,l,u),h=t.data.get(r.dataId).values,d=iS(h,r.shape,r.dtype,we(r.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const RW={kernelName:il,backendName:"cpu",kernelFunc:AW};function DW(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=s;me([r,o],"avgPool3DGrad");const c=Zs(o.shape,i,a,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,S=c.effectiveFilterHeight,k=c.effectiveFilterWidth,D=x-1-c.padInfo.front,F=k-1-c.padInfo.left,A=S-1-c.padInfo.top,R=Ee(o.shape,"float32"),N=1/(f*m*g),z=t.bufferSync(r);for(let V=0;V<c.batchSize;++V)for(let j=0;j<c.inChannels;++j)for(let G=0;G<c.inDepth;++G)for(let q=0;q<c.inHeight;++q)for(let J=0;J<c.inWidth;++J){const K=G-D,Q=q-A,te=J-F;let ee=0;for(let ne=0;ne<x;ne+=y){const oe=(K+ne)/h;if(!(oe<0||oe>=c.outDepth||Math.floor(oe)!==oe))for(let ue=0;ue<S;ue+=b){const ae=(Q+ue)/d;if(!(ae<0||ae>=c.outHeight||Math.floor(ae)!==ae))for(let de=0;de<k;de+=v){const be=(te+de)/p;if(be<0||be>=c.outWidth||Math.floor(be)!==be)continue;const ve=z.get(V,oe,ae,be,j);ee+=ve}}}R.set(ee*N,V,G,q,J,j)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const FW={kernelName:sh,backendName:"cpu",kernelFunc:DW};function _W(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o;me([r,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Xn(i.shape,a,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,S=Ee(i.shape,"float32"),k=1/(p*f),D=t.data.get(r.dataId).values,F=Ee(r.shape,"float32",D);for(let A=0;A<c.batchSize;++A)for(let R=0;R<c.inChannels;++R)for(let N=0;N<c.inHeight;++N)for(let z=0;z<c.inWidth;++z){const V=N-x,j=z-v;let G=0;for(let q=0;q<y;q+=m){const J=(V+q)/h;if(!(J<0||J>=c.outHeight||Math.floor(J)!==J))for(let K=0;K<b;K+=g){const Q=(j+K)/d;if(Q<0||Q>=c.outWidth||Math.floor(Q)!==Q)continue;const te=F.get(A,J,Q,R);G+=te}}S.set(G*k,A,N,z,R)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const OW={kernelName:nh,backendName:"cpu",kernelFunc:_W};function LW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:o,offset:i,mean:a,variance:l}=e;C(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),me([r,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(l.dataId).values,p=o?t.data.get(o.dataId).values:new Float32Array([1]),f=i?t.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=d.length,v=h.length;let x=0,S=0,k=0,D=0;for(let F=0;F<c.length;++F)m[F]=f[x++]+(c[F]-h[S++])*p[k++]/Math.sqrt(d[D++]+u),x>=g&&(x=0),S>=v&&(S=0),k>=y&&(k=0),D>=b&&(D=0);return t.makeTensorInfo(r.shape,r.dtype,m)}const PW={kernelName:wl,backendName:"cpu",kernelFunc:LW};function zW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:i}=s;me([r],"batchToSpaceND");const a=o.reduce((y,b)=>y*b),l=Su(r.shape,o,a),u=Nu(l.length,o.length),c=Cu(r.shape,o,a),h=$g(i,o.length),d=Sg(c,i,o.length),p=nt({inputs:{x:r},backend:t,attrs:{shape:l}}),f=bn({inputs:{x:p},backend:t,attrs:{perm:u}}),m=nt({inputs:{x:f},backend:t,attrs:{shape:c}}),g=fo({inputs:{x:m},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}const BW={kernelName:ll,backendName:"cpu",kernelFunc:zW};function MW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i}=s,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,u=vb(a,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}const VW={kernelName:rh,backendName:"cpu",kernelFunc:MW};function WW(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,a=Ne(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const UW={kernelName:oh,backendName:"cpu",kernelFunc:WW};const GW=He(ci,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),HW={kernelName:ci,backendName:"cpu",kernelFunc:GW};const jW=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(X(e.shape)),r=t.data.get(e.dataId),o=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,a=t.data.get(o.dataId).values,l=t.data.get(i.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];s[u]=Math.hypot(c,h)}return t.makeOutput(s,e.shape,"float32")},qW={kernelName:cl,backendName:"cpu",kernelFunc:jW};function Qo(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const KW={kernelName:Nh,backendName:"cpu",kernelFunc:Qo};function ei(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Re(r,e[0].shape)[0],i=e.map(m=>m.shape);wg(i,o);let a=Ns(e.map(m=>m.shape),o);if(X(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(m=>X(m.shape)>0);if(l.length===1)return Ds({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const m=l.map(x=>po({inputs:{input:x},backend:t})),g=l.map(x=>Qo({inputs:{input:x},backend:t})),y=ei({inputs:m,backend:t,attrs:{axis:o}}),b=ei({inputs:g,backend:t,attrs:{axis:o}}),v=$n({inputs:{real:y,imag:b},backend:t});return m.forEach(x=>t.disposeIntermediateTensorInfo(x)),g.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),v}const u=l.map(m=>{const y=[-1,X(m.shape.slice(o))];return nt({inputs:{x:m},backend:t,attrs:{shape:y}})}),c=u.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));a=Ns(u.map(m=>m.shape),1);const h=u[0].shape[0]===1,d=u$(c,a,e[0].dtype,h),p=Ns(l.map(m=>m.shape),o),f=t.makeTensorInfo(p,e[0].dtype,d);return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const XW={kernelName:hl,backendName:"cpu",kernelFunc:ei};function aS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;me([r,o],"conv2d");const h=Qs(l),d=zt(r.shape,o.shape,i,u,a,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v=d.dataFormat==="channelsLast",x=new St(d.outShape,r.dtype),S=we(r.shape),k=we(o.shape),D=S[0],F=v?S[1]:S[2],A=v?S[2]:1,R=v?1:S[1],N=x.strides[0],z=v?x.strides[1]:x.strides[2],V=v?x.strides[2]:1,j=v?1:x.strides[1],G=t.data.get(r.dataId).values,q=t.data.get(o.dataId).values,J=x.values;for(let K=0;K<d.batchSize;++K){const Q=K*D,te=K*N;for(let ee=0;ee<d.outHeight;++ee){const ne=te+ee*z,oe=ee*d.strideHeight-b;for(let ue=0;ue<p;++ue){const ae=oe+ue*m;if(ae<0||ae>=d.inHeight)continue;const de=ue*k[0],be=Q+ae*F;for(let ve=0;ve<d.outWidth;++ve){const Ie=ne+ve*V,Ce=ve*d.strideWidth-y;for(let ke=0;ke<f;++ke){const We=Ce+ke*g;if(We<0||We>=d.inWidth)continue;const Me=de+ke*k[1],je=be+We*A;let qe=Me;for(let Ue=0;Ue<d.inChannels;++Ue){const Ye=G[je+Ue*R];for(let Ze=0;Ze<d.outChannels;++Ze)J[Ie+Ze*j]+=Ye*q[qe+Ze];qe+=d.outChannels}}}}}}return t.makeTensorInfo(x.shape,x.dtype,J)}const YW={kernelName:dl,backendName:"cpu",kernelFunc:aS};function JW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;me([r,o],"conv2dBackpropFilter");const h=Qs(l),d=zt(r.shape,c,i,1,a,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",b=new St(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,S=t.data.get(r.dataId).values,k=t.data.get(o.dataId).values,D=new St(r.shape,r.dtype,S),F=new St(o.shape,o.dtype,k);for(let A=0;A<m;++A){const R=Math.max(0,Math.ceil((x-A)/p)),N=Math.min(d.outHeight,(d.inHeight+x-A)/p);for(let z=0;z<g;++z){const V=Math.max(0,Math.ceil((v-z)/f)),j=Math.min(d.outWidth,(d.inWidth+v-z)/f);for(let G=0;G<d.inChannels;++G)for(let q=0;q<d.outChannels;++q){let J=0;for(let K=0;K<d.batchSize;++K)for(let Q=R;Q<N;++Q){const te=A+Q*p-x;for(let ee=V;ee<j;++ee){const ne=z+ee*f-v;y?J+=D.get(K,te,ne,G)*F.get(K,Q,ee,q):J+=D.get(K,G,te,ne)*F.get(K,q,Q,ee)}}b.set(J,A,z,G,q)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const ZW={kernelName:ah,backendName:"cpu",kernelFunc:JW};function QW(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;me([r,o],"conv2dBackpropInput");const h=we(o.shape),d=we(r.shape);let p=Qs(u);const f=zt(i,o.shape,a,1,l,c,!1,p),m=new St(f.inShape,"float32"),g=m.values,y=t.data.get(r.dataId).values,b=t.data.get(o.dataId).values,[v,x,S]=h,{batchSize:k,filterHeight:D,filterWidth:F,inChannels:A,inHeight:R,inWidth:N,outChannels:z,outHeight:V,outWidth:j,strideHeight:G,strideWidth:q}=f;p=f.dataFormat;const J=D-1-f.padInfo.top,K=F-1-f.padInfo.left,Q=p==="channelsLast",te=m.strides[0],ee=Q?m.strides[1]:m.strides[2],ne=Q?m.strides[2]:1,oe=Q?1:m.strides[1],ue=d[0],ae=Q?d[1]:d[2],de=Q?d[2]:1,be=Q?1:d[1];for(let ve=0;ve<k;++ve)for(let Ie=0;Ie<A;++Ie)for(let Ce=0;Ce<R;++Ce){const ke=Ce-J,We=Math.max(0,Math.ceil(ke/G)),Me=Math.min(V,(D+ke)/G);for(let je=0;je<N;++je){const qe=je-K,Ue=Math.max(0,Math.ceil(qe/q)),Ye=Math.min(j,(F+qe)/q);let Ze=0;for(let vt=We;vt<Me;++vt){const An=vt*G-ke;for(let ot=Ue;ot<Ye;++ot){const Qn=ot*q-qe,Rn=ue*ve+ae*vt+de*ot,Mt=v*(D-1-An)+x*(F-1-Qn)+S*Ie;for(let ys=0;ys<z;++ys){const E=y[Rn+be*ys],w=b[Mt+ys];Ze+=E*w}}}const Zn=te*ve+ee*Ce+ne*je+oe*Ie;g[Zn]=Ze}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const e4={kernelName:pl,backendName:"cpu",kernelFunc:QW};function t4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l}=s;me([r,o],"conv3d");const u=Tr(r.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new St(u.outShape,r.dtype),S=t.data.get(r.dataId).values,k=t.data.get(o.dataId).values,D=x.values,F=we(r.shape),A=we(o.shape);for(let R=0;R<u.batchSize;++R){const N=R*F[0],z=R*x.strides[0];for(let V=0;V<u.outDepth;++V){const j=z+V*x.strides[1],G=V*u.strideDepth-y;for(let q=0;q<c;++q){const J=G+q*p;if(J<0||J>=u.inDepth)continue;const K=q*A[0],Q=N+J*F[1];for(let te=0;te<u.outHeight;++te){const ee=j+te*x.strides[2],ne=te*u.strideHeight-v;for(let oe=0;oe<h;++oe){const ue=ne+oe*f;if(ue<0||ue>=u.inHeight)continue;const ae=K+oe*A[1],de=Q+ue*F[2];for(let be=0;be<u.outWidth;++be){const ve=ee+be*u.outChannels,Ie=be*u.strideWidth-b;for(let Ce=0;Ce<d;++Ce){const ke=Ie+Ce*m;if(ke<0||ke>=u.inWidth)continue;const We=ae+Ce*A[2],Me=de+ke*u.inChannels;let je=We;for(let qe=0;qe<u.inChannels;++qe){const Ue=S[Me+qe];for(let Ye=0;Ye<u.outChannels;++Ye)D[ve+Ye]+=Ue*k[je+Ye];je+=u.outChannels}}}}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const n4={kernelName:fl,backendName:"cpu",kernelFunc:t4};function s4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:l}=s;me([r,o],"conv3dBackpropFilterV2");const u=we(r.shape),c=we(o.shape),h=Tr(r.shape,l,i,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new St(h.filterShape,"float32"),v=b.values,[x,S,k,D]=b.strides,F=t.data.get(o.dataId).values,[A,R,N,z]=c,V=t.data.get(r.dataId).values,[j,G,q,J]=u,K=h.padInfo.front,Q=h.padInfo.left,te=h.padInfo.top;for(let ee=0;ee<m;++ee){const ne=Math.max(0,Math.ceil((K-ee)/d)),oe=Math.min(h.outDepth,(h.inDepth+K-ee)/d),ue=ee*x;for(let ae=0;ae<g;++ae){const de=Math.max(0,Math.ceil((te-ae)/p)),be=Math.min(h.outHeight,(h.inHeight+te-ae)/p),ve=ae*S+ue;for(let Ie=0;Ie<y;++Ie){const Ce=Math.max(0,Math.ceil((Q-Ie)/f)),ke=Math.min(h.outWidth,(h.inWidth+Q-Ie)/f),We=Ie*k+ve;for(let Me=0;Me<h.inChannels;++Me){const je=Me*D+We;for(let qe=0;qe<h.outChannels;++qe){let Ue=0;for(let Ye=0;Ye<h.batchSize;++Ye){const Ze=Ye*j,Zn=Ye*A;for(let vt=ne;vt<oe;++vt){const ot=(ee+vt*d-K)*G+Ze,Qn=vt*R+Zn;for(let Rn=de;Rn<be;++Rn){const ys=(ae+Rn*p-te)*q+ot,E=Rn*N+Qn;for(let w=Ce;w<ke;++w){const _=(Ie+w*f-Q)*J+ys,W=w*z+E;Ue+=V[_+Me]*F[W+qe]}}}}v[je+qe]=Ue}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const r4={kernelName:lh,backendName:"cpu",kernelFunc:s4};function o4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:l}=s;me([r],"conv3dBackpropInputV2");const u=we(r.shape),c=we(o.shape),h=Tr(l,o.shape,a,1,i),d=new St(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=t.data.get(r.dataId).values,[v,x,S,k]=u,D=t.data.get(o.dataId).values,[F,A,R,N]=c,{batchSize:z,filterDepth:V,filterHeight:j,filterWidth:G,inChannels:q,inDepth:J,inHeight:K,inWidth:Q,outChannels:te,outDepth:ee,outHeight:ne,outWidth:oe,strideDepth:ue,strideHeight:ae,strideWidth:de}=h,be=V-1-h.padInfo.front,ve=j-1-h.padInfo.top,Ie=G-1-h.padInfo.left;for(let Ce=0;Ce<z;++Ce)for(let ke=0;ke<q;++ke)for(let We=0;We<J;++We){const Me=We-be,je=Math.max(0,Math.ceil(Me/ue)),qe=Math.min(ee,(V+Me)/ue);for(let Ue=0;Ue<K;++Ue){const Ye=Ue-ve,Ze=Math.max(0,Math.ceil(Ye/ae)),Zn=Math.min(ne,(j+Ye)/ae);for(let vt=0;vt<Q;++vt){const An=vt-Ie,ot=Math.max(0,Math.ceil(An/de)),Qn=Math.min(oe,(G+An)/de);let Rn=0;for(let Mt=je;Mt<qe;++Mt){const ys=Mt*ue-Me;for(let E=Ze;E<Zn;++E){const w=E*ae-Ye;for(let $=ot;$<Qn;++$){const _=$*de-An,W=v*Ce+x*Mt+S*E+k*$,Y=F*(V-1-ys)+A*(j-1-w)+R*(G-1-_)+N*ke;for(let se=0;se<te;++se){const Fe=b[W+se],it=D[Y+se];Rn+=Fe*it}}}}p[f*Ce+m*We+g*Ue+y*vt+ke]=Rn}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const i4={kernelName:uh,backendName:"cpu",kernelFunc:o4};const a4=He(hi,n=>Math.cos(n)),l4={kernelName:hi,backendName:"cpu",kernelFunc:a4};const u4=He(di,n=>Math.cosh(n)),c4={kernelName:di,backendName:"cpu",kernelFunc:u4};function h4(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:u}=s,[c,h,d,p]=r.shape,f=o.shape[0],[m,g]=a,y=Ee([f,m,g,p],"float32"),b=t.data.get(o.dataId).values,v=t.data.get(i.dataId).values,x=t.data.get(r.dataId).values,S=we(r.shape),k=we(y.shape);for(let D=0;D<f;D++){const F=D*4,A=b[F],R=b[F+1],N=b[F+2],z=b[F+3],V=v[D];if(V>=c)continue;const j=m>1?(N-A)*(h-1)/(m-1):0,G=g>1?(z-R)*(d-1)/(g-1):0;for(let q=0;q<m;q++){const J=m>1?A*(h-1)+q*j:.5*(A+N)*(h-1);if(J<0||J>h-1){for(let K=0;K<g;K++)for(let Q=0;Q<p;Q++){const te=Q+K*k[2]+q*k[1]+D*k[0];y.values[te]=u}continue}if(l==="bilinear"){const K=Math.floor(J),Q=Math.ceil(J),te=J-K;for(let ee=0;ee<g;ee++){const ne=g>1?R*(d-1)+ee*G:.5*(R+z)*(d-1);if(ne<0||ne>d-1){for(let de=0;de<p;de++){const be=de+ee*k[2]+q*k[1]+D*k[0];y.values[be]=u}continue}const oe=Math.floor(ne),ue=Math.ceil(ne),ae=ne-oe;for(let de=0;de<p;de++){let be=de+oe*S[2]+K*S[1]+V*S[0];const ve=x[be];be=de+ue*S[2]+K*S[1]+V*S[0];const Ie=x[be];be=de+oe*S[2]+Q*S[1]+V*S[0];const Ce=x[be];be=de+ue*S[2]+Q*S[1]+V*S[0];const ke=x[be],We=ve+(Ie-ve)*ae,Me=Ce+(ke-Ce)*ae;be=de+ee*k[2]+q*k[1]+D*k[0],y.values[be]=We+(Me-We)*te}}}else for(let K=0;K<g;++K){const Q=g>1?R*(d-1)+K*G:.5*(R+z)*(d-1);if(Q<0||Q>d-1){for(let ne=0;ne<p;ne++){const oe=ne+K*k[2]+q*k[1]+D*k[0];y.values[oe]=u}continue}const te=Math.round(Q),ee=Math.round(J);for(let ne=0;ne<p;ne++){const oe=ne+te*S[2]+ee*S[1]+V*S[0],ue=ne+K*k[2]+q*k[1]+D*k[0];y.values[ue]=x[oe]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const d4={kernelName:hh,backendName:"cpu",kernelFunc:h4};function p4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;me(r,"cumprod");const l=dt([o],r.shape.length);let u=r;l!=null&&(u=bn({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=bt(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=pn(u.dtype,"int32"),d=Qc(X(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const v=m(y,b);if(b===0)d[v]=i?1:p[v];else{const x=m(y,b-1);d[v]=i?p[x]*d[x]:p[v]*d[x]}}const g=t.makeTensorInfo(u.shape,h,d);if(l!=null){const y=Er(l),b=bn({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),b}return g}const f4={kernelName:ch,backendName:"cpu",kernelFunc:p4};function m4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;me(r,"cumsum");const l=dt([o],r.shape.length);let u=r;l!=null&&(u=bn({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=bt(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=pn(u.dtype,"int32"),d=jt(X(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const v=m(y,b);if(b===0)d[v]=i?0:p[v];else{const x=m(y,b-1);d[v]=i?p[x]+d[x]:p[v]+d[x]}}const g=t.makeTensorInfo(u.shape,h,d);if(l!=null){const y=Er(l),b=bn({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),b}return g}const g4={kernelName:ml,backendName:"cpu",kernelFunc:m4};function y4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=vb(l,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(o),c=i$(l,u,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const b4={kernelName:dh,backendName:"cpu",kernelFunc:y4};function x4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:i}=s;C(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*o,d=u*o,p=c/(o*o),f=t.data.get(r.dataId).values,m=new Float32Array(a*h*d*p);let g=0;for(let y=0;y<a;++y)for(let b=0;b<h;++b){const v=Math.floor(b/o),x=b%o;for(let S=0;S<d;++S){const k=Math.floor(S/o),D=S%o,F=(x*o+D)*p;for(let A=0;A<p;++A){const N=A+F+c*(k+u*(v+l*y));m[g++]=f[N]}}}return t.makeTensorInfo([a,h,d,p],r.dtype,m)}const w4={kernelName:ph,backendName:"cpu",kernelFunc:x4};function lS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=s;me([r,o],"depthwiseConv2DNative");const c=we(r.shape),h=we(o.shape);let d=l;d==null&&(d=[1,1]),C(Kt(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=zt(r.shape,o.shape,i,d,a,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,S=p.outChannels/p.inChannels,k=new St(p.outShape,r.dtype),D=t.data.get(r.dataId).values,F=t.data.get(o.dataId).values,A=k.values;for(let R=0;R<p.batchSize;++R){const N=R*c[0],z=R*k.strides[0];for(let V=0;V<p.outHeight;++V){const j=z+V*k.strides[1],G=V*p.strideHeight-x;for(let q=0;q<f;++q){const J=G+q*g;if(J<0||J>=p.inHeight)continue;const K=q*h[0],Q=N+J*c[1];for(let te=0;te<p.outWidth;++te){const ee=j+te*k.strides[2],ne=te*p.strideWidth-v;for(let oe=0;oe<m;++oe){const ue=ne+oe*y;if(ue<0||ue>=p.inWidth)continue;const ae=K+oe*h[1],de=Q+ue*p.inChannels;let be=ee,ve=ae;for(let Ie=0;Ie<p.inChannels;++Ie){const Ce=D[de+Ie];for(let ke=0;ke<S;++ke)A[be+ke]+=Ce*F[ve+ke];be+=S,ve+=S}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const v4={kernelName:gl,backendName:"cpu",kernelFunc:lS};function I4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;me([r,o],"depthwiseConv2dNativeBackpropFilter");const h=zt(r.shape,c,i,a,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new St(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,x=t.data.get(r.dataId).values,S=new St(r.shape,r.dtype,x),k=t.data.get(o.dataId).values,D=new St(o.shape,o.dtype,k);for(let F=0;F<f;++F){const A=Math.max(0,Math.ceil((b-F)/d)),R=Math.min(h.outHeight,(h.inHeight+b-F)/d);for(let N=0;N<m;++N){const z=Math.max(0,Math.ceil((y-N)/p)),V=Math.min(h.outWidth,(h.inWidth+y-N)/p);for(let j=0;j<h.outChannels;++j){const G=Math.trunc(j/v),q=j%v;let J=0;for(let K=0;K<h.batchSize;++K)for(let Q=A;Q<R;++Q){const te=F+Q*d-b;for(let ee=z;ee<V;++ee){const ne=N+ee*p-y;J+=S.get(K,te,ne,G)*D.get(K,Q,ee,j)}}g.set(J,F,N,G,q)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const $4={kernelName:fh,backendName:"cpu",kernelFunc:I4};function S4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;me([r,o],"depthwiseConv2DNativeBackpropInput");const h=we(r.shape),d=we(o.shape),p=zt(c,o.shape,i,a,l,u,!0),f=new St(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=t.data.get(r.dataId).values,[x,S,k]=h,D=t.data.get(o.dataId).values,[F,A,R]=d,{batchSize:N,filterHeight:z,filterWidth:V,inChannels:j,inHeight:G,inWidth:q,outChannels:J,outHeight:K,outWidth:Q,strideHeight:te,strideWidth:ee}=p,ne=z-1-p.padInfo.top,oe=V-1-p.padInfo.left,ue=J/j;for(let ae=0;ae<N;++ae)for(let de=0;de<j;++de)for(let be=0;be<G;++be){const ve=be-ne,Ie=Math.max(0,Math.ceil(ve/te)),Ce=Math.min(K,(z+ve)/te);for(let ke=0;ke<q;++ke){const We=ke-oe,Me=Math.max(0,Math.ceil(We/ee)),je=Math.min(Q,(V+We)/ee);let qe=0;for(let Ue=Ie;Ue<Ce;++Ue){const Ye=Ue*te-ve;for(let Ze=Me;Ze<je;++Ze){const Zn=Ze*ee-We,vt=x*ae+S*Ue+k*Ze,An=F*(z-1-Ye)+A*(V-1-Zn)+R*de;for(let ot=0;ot<ue;++ot){const Qn=de*ue+ot,Rn=v[vt+Qn],Mt=D[An+ot];qe+=Rn*Mt}}}m[g*ae+y*be+b*ke+de]=qe}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const N4={kernelName:mh,backendName:"cpu",kernelFunc:S4};function C4(n){const{inputs:e,backend:t}=n,{x:s}=e,r=X(s.shape),o=t.data.get(s.dataId).values,i=Ee([r,r],s.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*r+u]=o[u];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,i.dtype,i.values)}const k4={kernelName:gh,backendName:"cpu",kernelFunc:C4};const T4={kernelName:yl,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:o,pad:i,dilations:a}=t,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:S,filterHeight:k,filterWidth:D,dilationHeight:F,dilationWidth:A,outShape:R}=iu(s.shape,r.shape,o,i,"NHWC",a),N=X(R),z=R.length,V=pt(s.dtype,N);for(let G=0;G<p;++G)for(let q=0;q<y;++q){const J=q*x-v.top;for(let K=0;K<b;++K){const Q=K*S-v.left;for(let te=0;te<g;++te){let ee=Number.MIN_SAFE_INTEGER;for(let oe=0;oe<k;++oe){const ue=J+oe*F;if(ue>=0&&ue<f)for(let ae=0;ae<D;++ae){const de=Q+ae*A;if(de>=0&&de<m){const be=os([G,ue,de,te],c,we(s.shape)),ve=os([oe,ae,te],d,we(r.shape)),Ie=u[be]+h[ve];Ie>ee&&(ee=Ie)}}}const ne=os([G,q,K,te],z,we(R));V[ne]=ee}}}return{dataId:l.write(Cr(V,s.dtype),R,s.dtype),shape:R,dtype:s.dtype}}};const E4={kernelName:Nc,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:i,pad:a,dilations:l}=t,u=e,c=Bn(s.shape,u.data.get(s.dataId).values),h=Bn(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:S,filterWidth:k,dilationHeight:D,dilationWidth:F,outShape:A}=iu(s.shape,r.shape,i,a,"NHWC",l);C(o.rank===A.length,()=>`Error in ${Nc}, dy must have the same rank as output ${A.length}, but got ${o.rank}`);const R=Bn(A,u.data.get(o.dataId).values),N=Mf(r.shape,r.dtype);for(let V=0;V<d;++V)for(let j=0;j<g;++j){const G=j*v-b.top;for(let q=0;q<y;++q){const J=q*x-b.left;for(let K=0;K<m;++K){let Q=Number.MIN_SAFE_INTEGER,te=0,ee=0;for(let ne=0;ne<S;++ne){const oe=G+ne*D;if(oe>=0&&oe<p)for(let ue=0;ue<k;++ue){const ae=J+ue*F;if(ae>=0&&ae<f){const de=c[V][oe][ae][K]+h[ne][ue][K];de>Q&&(Q=de,te=ne,ee=ue)}}}N[te][ee][K]+=R[V][j][q][K]}}}return{dataId:u.write(Cr(N,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const A4={kernelName:Sc,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:i,pad:a,dilations:l}=t,u=e,c=Bn(s.shape,u.data.get(s.dataId).values),h=Bn(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:S,filterWidth:k,dilationHeight:D,dilationWidth:F,outShape:A}=iu(s.shape,r.shape,i,a,"NHWC",l);C(o.rank===A.length,()=>`Error in ${Sc}, dy must have the same rank as output ${A.length}, but got ${o.rank}`);const R=Bn(A,u.data.get(o.dataId).values),N=Mf(s.shape,s.dtype);for(let V=0;V<d;++V)for(let j=0;j<g;++j){const G=j*v-b.top;for(let q=0;q<y;++q){const J=q*x-b.left;for(let K=0;K<m;++K){let Q=Number.MIN_SAFE_INTEGER,te=G<0?0:G,ee=J<0?0:J;for(let ne=0;ne<S;++ne){const oe=G+ne*D;if(oe>=0&&oe<p)for(let ue=0;ue<k;++ue){const ae=J+ue*F;if(ae>=0&&ae<f){const de=c[V][oe][ae][K]+h[ne][ue][K];de>Q&&(Q=de,te=oe,ee=ae)}}}N[V][te][ee][K]+=R[V][j][q][K]}}}return{dataId:u.write(Cr(N,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function R4(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:o,options:i}=s,{contextOptions:a,imageOptions:l}=i||{},u=l?.alpha||1,c=a?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=o.getContext(c,a?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],m=t.data.get(r.dataId).values,g=r.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const x=[0,0,0,255*u];for(let k=0;k<f;k++){const D=m[v*f+k];if(r.dtype==="float32"){if(D<0||D>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${D}.`)}else if(r.dtype==="int32"&&(D<0||D>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${D}.`);f===1?(x[0]=D*g,x[1]=D*g,x[2]=D*g):x[k]=D*g}const S=v*4;y[S+0]=Math.round(x[0]),y[S+1]=Math.round(x[1]),y[S+2]=Math.round(x[2]),y[S+3]=Math.round(x[3])}o.width=p,o.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),r}const D4={kernelName:yh,backendName:"cpu",kernelFunc:R4};function Pu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;me(r,"sum");let a;r.dtype==="bool"?a=Nr({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):a=Ds({inputs:{x:r},backend:t});const l=a.shape.length,u=Re(o,a.shape),c=dt(u,l);let h=u,d=a;c!=null&&(d=bn({inputs:{x:a},backend:t,attrs:{perm:c}}),h=bt(h.length,l)),Xt("sum",h,d.shape.length);const[p,f]=Bt(d.shape,h),m=pn(d.dtype,"int32");let g=Uc(t,p,m);const y=X(f),b=t.data.get(g.dataId).values,v=t.data.get(d.dataId).values;for(let x=0;x<b.length;++x){const S=x*y;let k=0;for(let D=0;D<y;++D)k+=v[S+D];b[x]=k}if(i){const x=yt(g.shape,u),S=g;g=nt({inputs:{x:g},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(S)}return t.disposeIntermediateTensorInfo(a),c!=null&&t.disposeIntermediateTensorInfo(d),g}const F4={kernelName:Yl,backendName:"cpu",kernelFunc:Pu};function _4(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:l}=Dg(r,o.length);_g(i.length,l,o);const{path:u,steps:c}=Og(a,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=Fg(p,l[g]);let v;Lg(y)?v=o[g]:(v=bn({inputs:{x:o[g]},backend:t,attrs:{perm:y}}),f.push(v));const x=v.shape.slice();for(let S=0;S<b.length;++S)x.splice(b[S],0,1);_e(v.shape,x)||(v=nt({inputs:{x:v},backend:t,attrs:{shape:x}}),f.push(v)),d===null?d=v:(d=gp({inputs:{a:v,b:d},backend:t}),f.push(d))}m<h-1&&(u[m]>=0&&(d=Pu({inputs:{x:d},backend:t,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const O4={kernelName:bh,backendName:"cpu",kernelFunc:_4};function L4(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;me([s,r],"eluGrad");const o=new Float32Array(X(r.shape)),i=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?o[l]=a[l]:o[l]=a[l]*(u+1)}return t.makeTensorInfo(r.shape,"float32",o)}const P4={kernelName:xh,backendName:"cpu",kernelFunc:L4};const z4=Ng,B4=Cg,M4=kg,V4=Tg,W4=Eg,U4=Ag,G4=He(mi,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+z4*t);return e*(1-((((U4*s+W4)*s+V4)*s+M4)*s+B4)*s*Math.exp(-t*t))}),H4={kernelName:mi,backendName:"cpu",kernelFunc:G4};function jc(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:o}=s,i=r.shape.length,a=r.shape.slice();let l=o;return o<0&&(C(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),nt({inputs:{x:r},backend:t,attrs:{shape:a}})}const j4={kernelName:xl,backendName:"cpu",kernelFunc:jc};const q4=wt((n,e)=>n/e),kb=Rt(pi,q4),kf={kernelName:pi,backendName:"cpu",kernelFunc:kb};function uS(n,e,t){const s=n.shape,r=s[0],o=s[1],i=t.data.get(n.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[r,o],c=X(u),h=Ot("float32",c),d=Ot("float32",c);for(let g=0;g<r;g++){const y=fo({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,o]}}),b=fo({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,o]}}),v=$n({inputs:{real:y,imag:b},backend:t}),{real:x,imag:S}=K4(v,e,t),k=js(x,S);for(let D=0;D<o;D++){const F=Rg(k,D);h[g*o+D]=F.real,d[g*o+D]=F.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v)}const p=t.makeTensorInfo(u,"float32",h),f=t.makeTensorInfo(u,"float32",d),m=$n({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),m}function K4(n,e,t){const s=X(n.shape),r=t.data.get(n.dataId),o=t.data.get(r.complexTensorInfos.real.dataId).values,i=t.data.get(r.complexTensorInfos.imag.dataId).values;if(X4(s)){const a=Tf(o,i,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",a.real),c=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Js(s,"float32")),d=Ds({inputs:{x:h},backend:t}),p=kf.kernelFunc({inputs:{a:u,b:h},backend:t}),f=kf.kernelFunc({inputs:{a:c,b:d},backend:t}),m=t.data.get(p.dataId).values,g=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return a}else{const a=js(o,i),l=Y4(a,s,e);return Z1(l)}}function X4(n){return(n&n-1)===0}function Tf(n,e,t,s,r){if(t===1)return{real:n,imag:e};const o=js(n,e),i=t/2,a=Q1(o),l=a.real,u=a.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=$n({inputs:{real:h,imag:d},backend:r}),f=ev(o),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),v=r.makeTensorInfo(y,"float32",g),x=$n({inputs:{real:b,imag:v},backend:r}),S=Tf(l,u,i,s,r),k=S.real,D=S.imag,F=[k.length],A=r.makeTensorInfo(F,"float32",k),R=r.makeTensorInfo(F,"float32",D),N=$n({inputs:{real:A,imag:R},backend:r}),z=Tf(m,g,i,s,r),V=z.real,j=z.imag,G=[V.length],q=r.makeTensorInfo(G,"float32",V),J=r.makeTensorInfo(G,"float32",j),K=$n({inputs:{real:q,imag:J},backend:r}),Q=nv(t,s),te=[Q.real.length],ee=r.makeTensorInfo(te,"float32",Q.real),ne=r.makeTensorInfo(te,"float32",Q.imag),oe=$n({inputs:{real:ee,imag:ne},backend:r}),ue=gp({inputs:{a:oe,b:K},backend:r}),ae=Zo({inputs:{a:N,b:ue},backend:r}),de=Nb({inputs:{a:N,b:ue},backend:r}),be=po({inputs:{input:ae},backend:r}),ve=po({inputs:{input:de},backend:r}),Ie=Qo({inputs:{input:ae},backend:r}),Ce=Qo({inputs:{input:de},backend:r}),ke=ei({inputs:[be,ve],backend:r,attrs:{axis:0}}),We=ei({inputs:[Ie,Ce],backend:r,attrs:{axis:0}}),Me=r.data.get(ke.dataId).values,je=r.data.get(We.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(ue),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(be),r.disposeIntermediateTensorInfo(Ie),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(We),{real:Me,imag:je}}function Y4(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let o=0,i=0;for(let a=0;a<e;a++){const l=sv(r*a,e,t),u=Rg(n,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}t&&(o/=e,i/=e),tv(s,o,i,r)}return s}function J4(n){const{inputs:e,backend:t}=n,{input:s}=e,r=X(s.shape),o=s.shape[s.shape.length-1],i=r/o,a=nt({inputs:{x:s},backend:t,attrs:{shape:[i,o]}}),l=uS(a,!1,t),u=nt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const Z4={kernelName:wh,backendName:"cpu",kernelFunc:J4};function Tb(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:o}=t,i=o||xo(r),a=pt(i,X(s));return eU(a,r,i),e.makeTensorInfo(s,i,a)}const Q4={kernelName:vh,backendName:"cpu",kernelFunc:Tb};function eU(n,e,t){n.fill(e)}const tU={kernelName:Ih,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,o=Ot(s.dtype,X(s.shape)),[i,a,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let d=0;d<i;d++){const p=d*l*a*u;for(let f=0;f<a;f++){const m=f*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let b=0;b<u;b++){const v=Math.round(l-g-1),x=p+m+y+b;let S=c[x];if(v>=0&&v<l){const k=v*u,D=p+m+k+b;S=c[D]}o[x]=S}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function nU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=aS({inputs:{x:r,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const y=nt({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});m=Zo({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=Zo({inputs:{a:m,b:i},backend:t});t.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(c==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=nt({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=Hc(t,m,p,y,f),t.disposeIntermediateTensorInfo(y)}else m=Hc(t,m,p,a,f);t.disposeIntermediateTensorInfo(g)}return m}const sU={kernelName:Pa,backendName:"cpu",kernelFunc:nU};function rU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=lS({inputs:{x:r,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const g=m;m=Zo({inputs:{a:m,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=Hc(t,m,p,a,f),t.disposeIntermediateTensorInfo(g)}return m}const oU={kernelName:za,backendName:"cpu",kernelFunc:rU};function iU(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=X(s.shape),i=r.shape,a=i[i.length-1],[l,u,c,h]=Gd(s,r);if(u===0)return t.makeTensorInfo(l,s.dtype,[]);const d=t.data.get(r.dataId).values,p=t.bufferSync(s),f=y$(d,p,s.dtype,u,a,c,h,s.shape,o);return t.makeTensorInfo(l,s.dtype,f.values)}const aU={kernelName:$h,backendName:"cpu",kernelFunc:iU};function lU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:i,batchDims:a}=s;me([r,o],"gatherV2");const l=Re(i,r.shape)[0],u=t.data.get(o.dataId).values,c=r.shape[l];for(let x=0;x<u.length;++x){const S=u[x];C(S<=c-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const d=X(o.shape),p=zg(r,o,l,h),f=nt({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=nt({inputs:{x:o},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=t.bufferSync(m),b=t.bufferSync(f),v=b$(b,y,g);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(p.outputShape,v.dtype,v.values)}const uU={kernelName:vl,backendName:"cpu",kernelFunc:lU};function cU(n){const{inputs:e,backend:t}=n,{input:s}=e,r=X(s.shape),o=s.shape[s.shape.length-1],i=r/o,a=nt({inputs:{x:s},backend:t,attrs:{shape:[i,o]}}),l=uS(a,!0,t),u=nt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const hU={kernelName:Sh,backendName:"cpu",kernelFunc:cU};const dU=He(Ii,n=>Number.isFinite(n)?1:0,"bool"),pU={kernelName:Ii,backendName:"cpu",kernelFunc:dU};const fU=He($i,n=>Math.abs(n)===1/0?1:0,"bool"),mU={kernelName:$i,backendName:"cpu",kernelFunc:fU};const gU=He(Si,n=>Number.isNaN(n)?1:0,"bool"),yU={kernelName:Si,backendName:"cpu",kernelFunc:gU};function bU(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,i=$$(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const xU={kernelName:Ch,backendName:"cpu",kernelFunc:bU};const wU=He(Ci,n=>Math.log1p(n)),vU={kernelName:Ci,backendName:"cpu",kernelFunc:wU};const IU=wt((n,e)=>n&&e),$U=Rt(Cl,IU,null,"bool"),SU={kernelName:Cl,backendName:"cpu",kernelFunc:$U};const NU=He(kl,n=>n?0:1,"bool"),CU={kernelName:kl,backendName:"cpu",kernelFunc:NU};const kU=wt((n,e)=>n||e),TU=Rt(Tl,kU,null,"bool"),EU={kernelName:Tl,backendName:"cpu",kernelFunc:TU};function AU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=s;me(r,"LRN");const u=r.shape[3],c=u-1,h=t.data.get(r.dataId).values,d=X(r.shape),p=new Float32Array(d);function f(m){const g=m%u;let y=m-g+Math.max(0,g-o);const b=m-g+Math.min(g+o,c);let v=0;for(;y<=b;y++){const x=h[y];v+=x*x}return v}for(let m=0;m<d;m++){const g=f(m),y=h[m]*Math.pow(i+a*g,-l);p[m]=y}return t.makeTensorInfo(r.shape,r.dtype,p)}const RU={kernelName:El,backendName:"cpu",kernelFunc:AU};function DU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s;me(i,"LRNGrad");const h=X(i.shape),d=i.shape[3],p=t.data.get(i.dataId).values,f=t.data.get(r.dataId).values,m=t.data.get(o.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const v=b%d,x=b-v+Math.max(0,v-a),S=b-v+Math.min(d,v+a+1);let k=0;for(let D=x;D<S;D++)k+=Math.pow(f[D],2);k=u*k+l;for(let D=x;D<S;D++){let F=-2*u*c*f[D]*m[b]/k;b===D&&(F+=Math.pow(k,-c)),F*=p[b],g[D]+=F}}return t.makeTensorInfo(i.shape,r.dtype,g)}const FU={kernelName:kh,backendName:"cpu",kernelFunc:DU};function cS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=t;let l=r.shape;const u=l.length,c=Re(o,l);let h=c;const d=dt(h,u);let p=a.data.get(r.dataId).values;if(d!=null){const x=new Array(u);for(let S=0;S<x.length;S++)x[S]=l[d[S]];p=$b(p,l,r.dtype,d,x),h=bt(h.length,u),l=x}me(r,"max"),Xt("max",h,u);const[f,m]=Bt(l,h),g=X(m),y=N$(p,g,f,r.dtype),b=a.write(y,f,r.dtype);let v=f;return i&&(v=yt(f,c)),{dataId:b,shape:v,dtype:r.dtype}}const _U={kernelName:Al,backendName:"cpu",kernelFunc:cS};function OU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;me(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;C(Kt(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Xn(r.shape,o,i,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&_e(c.inShape,c.outShape))h=Ds({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=we(r.shape),f=Cb(d,r.shape,r.dtype,p,c,"max");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const LU={kernelName:Rl,backendName:"cpu",kernelFunc:OU};function PU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=s;me(r,"maxPool3d");const c=Zs(r.shape,o,i,1,a,l,u),h=t.data.get(r.dataId).values,d=iS(h,r.shape,r.dtype,we(r.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const zU={kernelName:Dl,backendName:"cpu",kernelFunc:PU};function BU(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=s;me([r,o],"maxPool3DGrad");const c=Zs(o.shape,i,a,1,l,u),h=t.bufferSync(o),d=kW(h,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,x=c.effectiveFilterHeight,S=c.effectiveFilterWidth,k=v-1-c.padInfo.front,D=S-1-c.padInfo.left,F=x-1-c.padInfo.top,A=Ee(o.shape,"float32"),R=t.bufferSync(r);for(let N=0;N<c.batchSize;++N)for(let z=0;z<c.inChannels;++z)for(let V=0;V<c.inDepth;++V)for(let j=0;j<c.inHeight;++j)for(let G=0;G<c.inWidth;++G){const q=V-k,J=j-F,K=G-D;let Q=0;for(let te=0;te<v;te+=g){const ee=(q+te)/p;if(!(ee<0||ee>=c.outDepth||Math.floor(ee)!==ee))for(let ne=0;ne<x;ne+=y){const oe=(J+ne)/f;if(!(oe<0||oe>=c.outHeight||Math.floor(oe)!==oe))for(let ue=0;ue<S;ue+=b){const ae=(K+ue)/m;if(ae<0||ae>=c.outWidth||Math.floor(ae)!==ae)continue;const de=v*x*S-1-d.get(N,ee,oe,ae,z),be=te*x*S+ne*S+ue,ve=de===be?1:0;if(ve===0)continue;const Ie=R.get(N,ee,oe,ae,z);Q+=Ie*ve}}}A.set(Q,N,V,j,G,z)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const MU={kernelName:Eh,backendName:"cpu",kernelFunc:BU};function VU(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:i}=e,a=o;me([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=Xn(a.shape,l,u,1,c,h),p=t.data.get(a.dataId).values,f=Ee(d.outShape,a.dtype,oS(p,a.shape,a.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,S=x-1-d.padInfo.left,k=v-1-d.padInfo.top,D=Ee(a.shape,"float32"),F=t.data.get(r.dataId).values,A=Ee(r.shape,"float32",F);for(let R=0;R<d.batchSize;++R)for(let N=0;N<d.inChannels;++N)for(let z=0;z<d.inHeight;++z)for(let V=0;V<d.inWidth;++V){const j=z-k,G=V-S;let q=0;for(let J=0;J<v;J+=y){const K=(j+J)/m;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let Q=0;Q<x;Q+=b){const te=(G+Q)/g;if(te<0||te>=d.outWidth||Math.floor(te)!==te)continue;const ee=v*x-1-f.get(R,K,te,N),ne=J*x+Q,oe=ee===ne?1:0;if(oe===0)continue;const ue=A.get(R,K,te,N);q+=ue*oe}}D.set(q,R,z,V,N)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const WU={kernelName:Th,backendName:"cpu",kernelFunc:VU};function UU(n,e,t,s,r){const o=we(e),i=Cb(n,e,t,o,r,"max"),a=oS(n,e,t,r,!0,s);return[i.values,a.values]}const GU={kernelName:Ah,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,l=t;me(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Xn(s.shape,r,o,[1,1],i),[h,d]=UU(u,s.shape,s.dtype,a,c),p=l.write(h,c.outShape,s.dtype),f=l.write(d,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function HU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=Re(o,r.shape),u=Bt(r.shape,a)[1],c=X(u),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const p=Nr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});h.push(p);const f=kb({inputs:{a:p,b:d},backend:t});h.push(f);const m=Pu({inputs:{x:f},backend:t,attrs:{axis:o,keepDims:i}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const jU={kernelName:Fl,backendName:"cpu",kernelFunc:HU};function qU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;me(r,"min");const a=Re(o,r.shape);let l=a;const u=dt(l,r.shape.length);let c=r;u!=null&&(c=bn({inputs:{x:r},backend:t,attrs:{perm:u}}),l=bt(l.length,r.shape.length)),Xt("min",l,c.shape.length);const[h,d]=Bt(c.shape,l),p=X(d),f=jt(X(h),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let v=m[b];for(let x=0;x<p;++x){const S=m[b+x];(Number.isNaN(S)||S<v)&&(v=S)}f[y]=v}u!=null&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(h,c.dtype,f);if(i){const y=yt(h,a),b=nt({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const KU={kernelName:_l,backendName:"cpu",kernelFunc:qU};function XU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,mode:i}=s;me(r,"mirrorPad");const a=o.map((v,x)=>v[0]+r.shape[x]+v[1]),l=o.map(v=>v[0]),u=o.map((v,x)=>v[0]+r.shape[x]),c=i==="reflect"?0:1,h=t.data.get(r.dataId).values,d=r.shape.length,p=we(r.shape),f=X(a),m=a.length,g=we(a),y=Ot(r.dtype,f);for(let v=0;v<f;v++){let x=wo(v,m,g);for(let k=0;k<m;k++)x[k]<l[k]?x[k]=l[k]*2-x[k]-c:x[k]>=u[k]&&(x[k]=(u[k]-1)*2-x[k]+c);x=x.map((k,D)=>k-l[D]);const S=os(x,d,p);y[v]=h[S]}return{dataId:t.write(y,a,r.dtype),shape:a,dtype:r.dtype}}const YU={kernelName:Ol,backendName:"cpu",kernelFunc:XU};const JU=wt((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),ZU=Rt(Ei,JU),QU={kernelName:Ei,backendName:"cpu",kernelFunc:ZU};function hS(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,i=r.shape.length;let a=o;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=Re([a],r.shape),u=cS({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=yt(u.shape,l),h=nt({inputs:{x:u},backend:t,attrs:{shape:c}}),d=Nb({inputs:{a:r,b:h},backend:t}),p=p$({inputs:{x:d},backend:t}),f=Pu({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),m=nt({inputs:{x:f},backend:t,attrs:{shape:c}}),g=kb({inputs:{a:p,b:m},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}const eG={kernelName:Ql,backendName:"cpu",kernelFunc:hS};function tG(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s;me(r,"multinomial");const l=a?r:hS({inputs:{logits:r},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=t.data.get(l.dataId).values,d=[u,o],p=jt(X(d),"int32");for(let f=0;f<u;++f){const m=f*c,g=new Float32Array(c-1);g[0]=h[m];for(let v=1;v<g.length;++v)g[v]=g[v-1]+h[m+v];const y=na.alea(i.toString()),b=f*o;for(let v=0;v<o;++v){const x=y();p[b+v]=g.length;for(let S=0;S<g.length;S++)if(x<g[S]){p[b+v]=S;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const nG={kernelName:Rh,backendName:"cpu",kernelFunc:tG};const sG=Md;function rG(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=s;me(r,"NonMaxSuppression");const u=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,{selectedIndices:h}=sG(u,c,i,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const oG={kernelName:Dh,backendName:"cpu",kernelFunc:rG};const iG=Vd;function aG(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;me(r,"NonMaxSuppressionPadded");const c=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,{selectedIndices:d,validOutputs:p}=iG(c,h,i,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const lG={kernelName:Fh,backendName:"cpu",kernelFunc:aG};const uG=Wd;function cG(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;me(r,"NonMaxSuppressionWithScore");const c=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,d=i,p=a,f=l,m=u,{selectedIndices:g,selectedScores:y}=uG(c,h,d,p,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const hG={kernelName:_h,backendName:"cpu",kernelFunc:cG};function dG(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:l}=s;me(r,"oneHot");const u=X(r.shape),c=new Float32Array(u*i);c.fill(l);const h=t.data.get(r.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=a);return t.makeTensorInfo([...r.shape,i],o,c)}const pG={kernelName:Bl,backendName:"cpu",kernelFunc:dG};function qc(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=po({inputs:{input:s},backend:t}),o=qc({inputs:{x:r},backend:t}),i=Qo({inputs:{input:s},backend:t}),a=qc({inputs:{x:i},backend:t}),l=$n({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return Tb({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const fG={kernelName:su,backendName:"cpu",kernelFunc:qc};function dS(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=po({inputs:{input:s},backend:t}),o=dS({inputs:{x:r},backend:t}),i=Qo({inputs:{input:s},backend:t}),a=qc({inputs:{x:i},backend:t}),l=$n({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return Tb({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const mG={kernelName:zl,backendName:"cpu",kernelFunc:dS};function pS(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return jc({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{qt(o,c.shape,"All tensors passed to stack must have matching shapes"),C(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=jc({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=ei({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const gG={kernelName:Ml,backendName:"cpu",kernelFunc:pS};function yG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:i}=s;me(r,"pad");const a=o.map((b,v)=>b[0]+r.shape[v]+b[1]),l=o.map(b=>b[0]),u=t.data.get(r.dataId).values,c=X(r.shape),h=r.shape.length,d=we(r.shape),p=X(a),f=a.length,m=we(a),g=Ot(r.dtype,p);i!==0&&g.fill(i);for(let b=0;b<c;b++){const x=wo(b,h,d).map((k,D)=>k+l[D]),S=os(x,f,m);g[S]=u[b]}return{dataId:t.write(g,a,r.dtype),shape:a,dtype:r.dtype}}const fS={kernelName:Vl,backendName:"cpu",kernelFunc:yG};const bG=wt((n,e)=>Math.pow(n,e)),xG=Rt(Ri,bG),wG={kernelName:Ri,backendName:"cpu",kernelFunc:xG};function vG(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=s,l=r.map(y=>t.data.get(y.dataId).values),u=r.map(y=>y.shape),c=t.data.get(o.dataId).values,h=t.data.get(i.dataId).values,[d,p,f]=R$(l,u,c,o.shape,o.dtype,h,i.shape),m=d.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(f,o.dtype,p);return m.concat([g])}const IG={kernelName:Oh,backendName:"cpu",kernelFunc:vG};function $G(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=D$(i,s.shape,s.dtype,a,r.shape,l,o.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const SG={kernelName:Lh,backendName:"cpu",kernelFunc:$G};function NG(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,h=t.data.get(i.dataId).values,d=a.map(g=>t.data.get(g.dataId).values),p=a.map(g=>g.shape),[f,m]=F$(u,r.shape,c,o.shape,o.dtype,h,i.shape,d,p,l);return t.makeTensorInfo(f,o.dtype,m)}const CG={kernelName:Ph,backendName:"cpu",kernelFunc:NG};function kG(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:o,step:i}=t,a=_$(s,r,i,o);return e.makeTensorInfo([a.length],o,a)}const TG={kernelName:zh,backendName:"cpu",kernelFunc:kG};const EG=He(Di,n=>1/n),AG={kernelName:Di,backendName:"cpu",kernelFunc:EG};function RG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s;me(r,"resizeBilinear");const l=we(r.shape),[u,c]=a,[h,d,p,f]=r.shape,m=t.data.get(r.dataId).values,g=new Float32Array(X([h,u,c,f])),y=[o&&u>1?d-1:d,o&&c>1?p-1:p],b=[o&&u>1?u-1:u,o&&c>1?c-1:c];let v=0;const x=y[0]/b[0],S=y[1]/b[1];for(let k=0;k<h;k++)for(let D=0;D<u;D++){let F;i?F=x*(D+.5)-.5:F=x*D;const A=Math.max(0,Math.floor(F)),R=F-A,N=Math.min(d-1,Math.ceil(F)),z=k*l[0]+A*l[1],V=k*l[0]+N*l[1];for(let j=0;j<c;j++){let G;i?G=S*(j+.5)-.5:G=S*j;const q=Math.max(0,Math.floor(G)),J=G-q,K=Math.min(p-1,Math.ceil(G)),Q=z+q*l[2],te=V+q*l[2],ee=z+K*l[2],ne=V+K*l[2];for(let oe=0;oe<f;oe++){const ue=m[Q+oe],ae=m[te+oe],de=m[ee+oe],be=m[ne+oe],ve=ue+(de-ue)*J,Ie=ae+(be-ae)*J,Ce=ve+(Ie-ve)*R;g[v++]=Ce}}}return t.makeTensorInfo([h,u,c,f],"float32",g)}const DG={kernelName:jl,backendName:"cpu",kernelFunc:RG};function FG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s;me([o,r],"resizeBilinearGrad");const a=we(r.shape),[l,u,c,h]=r.shape,[,d,p]=o.shape,f=new Float32Array(l*u*c*h),m=[i&&d>1?u-1:u,i&&p>1?c-1:c],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=t.data.get(o.dataId).values;let x=0;for(let S=0;S<l;S++){const k=S*a[0];for(let D=0;D<d;D++){const F=D*y,A=Math.floor(F),R=Math.min(Math.ceil(F),u-1),N=k+A*a[1],z=k+R*a[1],V=F-A,j=1-V;for(let G=0;G<p;G++){const q=G*b,J=Math.floor(q),K=Math.min(Math.ceil(q),c-1),Q=q-J,te=1-Q,ee=N+J*a[2],ne=N+K*a[2],oe=z+J*a[2],ue=z+K*a[2],ae=j*te,de=j*Q,be=V*te,ve=V*Q;for(let Ie=0;Ie<h;Ie++){const Ce=v[x++];f[ee+Ie]+=Ce*ae,f[ne+Ie]+=Ce*de,f[oe+Ie]+=Ce*be,f[ue+Ie]+=Ce*ve}}}}return t.makeTensorInfo([l,c,u,h],"float32",f)}const _G={kernelName:Vh,backendName:"cpu",kernelFunc:FG};function OG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s;me(r,"resizeNearestNeighbor");const l=we(r.shape),[u,c]=a,[h,d,p,f]=r.shape,m=t.data.get(r.dataId).values,g=new Float32Array(h*u*c*f),y=[o&&u>1?d-1:d,o&&c>1?p-1:p],b=[o&&u>1?u-1:u,o&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let S=0;for(let k=0;k<h;k++){const D=k*l[0];for(let F=0;F<u;F++){const A=i?v*(F+.5):v*F;let R=Math.min(d-1,o?Math.round(A):Math.floor(A));i&&(R=Math.max(0,R));const N=D+R*l[1];for(let z=0;z<c;z++){const V=i?x*(z+.5):x*z;let j=Math.min(p-1,o?Math.round(V):Math.floor(V));i&&(j=Math.max(0,j));const G=N+j*l[2];for(let q=0;q<f;q++){const J=m[G+q];g[S++]=J}}}}return t.makeTensorInfo([h,u,c,f],r.dtype,g)}const LG={kernelName:Hl,backendName:"cpu",kernelFunc:OG};function PG(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s;me([o,r],"resizeNearestNeighborGrad");const a=we(r.shape),l=we(o.shape),[u,c,h,d]=r.shape,[,p,f]=o.shape,m=new Float32Array(u*c*h*d),g=t.data.get(o.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],S=1/v,k=1/x,D=Math.ceil(S)*2+2,F=Math.ceil(k)*2+2;for(let A=0;A<u;A++){const R=A*a[0];for(let N=0;N<c;N++){const z=R+N*a[1],V=Math.floor(N*S),j=Math.floor(V-D/2);for(let G=0;G<h;G++){const q=z+G*a[2],J=Math.floor(G*k),K=Math.floor(J-F/2);for(let Q=0;Q<d;Q++){let te=0;for(let ee=0;ee<D;ee++){const ne=ee+j;if(ne<0||ne>=p)continue;const oe=R+ne*l[1],ue=ne*v,ae=Math.min(c-1,i?Math.round(ue):Math.floor(ue));if(N===ae)for(let de=0;de<F;de++){const be=de+K;if(be<0||be>=f)continue;const ve=oe+be*l[2],Ie=be*x,Ce=Math.min(h-1,i?Math.round(Ie):Math.floor(Ie));G===Ce&&(te+=g[ve+Q])}}m[q+Q]=te}}}}return t.makeTensorInfo(r.shape,r.dtype,m)}const zG={kernelName:Mh,backendName:"cpu",kernelFunc:PG};function BG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s;me(r,"reverse");const i=r.shape.length,a=Re(o,r.shape);if(i===0)return Ds({inputs:{x:r},backend:t});const l=new St(r.shape,r.dtype),u=t.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();a.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const MG={kernelName:ql,backendName:"cpu",kernelFunc:BG};const VG={kernelName:rd,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:i}=e,a=t,l=Ot(s.dtype,X(s.shape)),[u,c,h,d]=s.shape,[p,f]=Ig(i,c,h),m=255,g=Math.sin(r),y=Math.cos(r),b=a.data.get(s.dataId).values;for(let x=0;x<u;x++){const S=x*h*c*d;for(let k=0;k<c;k++){const D=k*(h*d);for(let F=0;F<h;F++){const A=F*d;for(let R=0;R<d;R++){const N=[u,k,F,R],z=N[2],V=N[1];let j=(z-p)*y-(V-f)*g,G=(z-p)*g+(V-f)*y;j=Math.round(j+p),G=Math.round(G+f);let q=o;if(typeof o!="number"&&(R===3?q=m:q=o[R]),j>=0&&j<h&&G>=0&&G<c){const K=G*(h*d),Q=j*d,te=S+K+Q+R;q=b[te]}const J=S+D+A+R;l[J]=q}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const WG=He(Oi,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),UG={kernelName:Oi,backendName:"cpu",kernelFunc:WG};function GG(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Fr(o,r,i),d=!0,p=t.bufferSync(r),f=t.bufferSync(o),m=qr(p,f,i,h,u,l,a,c,0,d);return t.makeTensorInfo(i,m.dtype,m.values)}const HG={kernelName:Wh,backendName:"cpu",kernelFunc:GG};function jG(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function qG(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function KG(n,e,t,s,r,o){const i=pt("int32",t*r);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),u=a*r;for(let c=0;c<r;++c)i[u+c]=o==="left"?jG(l,e[c+u]):qG(l,e[c+u])}return i}function XG(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:i}=s,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,u=KG(a,l,r.shape[0],r.shape[1],o.shape[1],i);return t.makeTensorInfo(o.shape,"int32",u)}const YG={kernelName:Gh,backendName:"cpu",kernelFunc:XG};function JG(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e;me([s,r,o],"select");const i=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=pn(r.dtype,o.dtype),h=jt(X(r.shape),c);let d=0;const p=i===0||i>1||r.shape.length===1?1:X(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let m=0;m<p;m++)a[f]===1?h[d++]=l[f]:h[d++]=u[f];return t.makeTensorInfo(r.shape,c,h)}const ZG={kernelName:Kl,backendName:"cpu",kernelFunc:JG};const QG=qd,eH=Kd,tH=He(Pi,n=>n>=0?eH*n:QG*(Math.exp(n)-1)),nH={kernelName:Pi,backendName:"cpu",kernelFunc:tH};const sH=He(Mi,n=>n<0?-1:n>0?1:0),rH={kernelName:Mi,backendName:"cpu",kernelFunc:sH};const oH=He(zi,n=>Math.sin(n)),iH={kernelName:zi,backendName:"cpu",kernelFunc:oH};const aH=He(Bi,n=>Math.sinh(n)),lH={kernelName:Bi,backendName:"cpu",kernelFunc:aH};const uH=11920928955078125e-23,a0=Math.log(uH)+2,cH=He(Wi,n=>{const e=n>-a0,t=n<a0,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),hH={kernelName:Wi,backendName:"cpu",kernelFunc:cH};function dH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:i}=s;me([r],"spaceToBatchND");const a=X(o),l=[[0,0]];l.push(...i);for(let k=1+o.length;k<r.shape.length;++k)l.push([0,0]);const u=fS.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),c=Su(u.shape,o,a,!1),h=Nu(c.length,o.length,!1),d=Cu(u.shape,o,a,!1),m=nt({inputs:{x:u},backend:t,attrs:{shape:c}}),b=bn({inputs:{x:m},backend:t,attrs:{perm:h}}),S=nt({inputs:{x:b},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),S}const pH={kernelName:Jl,backendName:"cpu",kernelFunc:dH};function fH(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=t.data.get(i.dataId).values[0],[h,d,p,f,m]=z$(a,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const mH={kernelName:Hh,backendName:"cpu",kernelFunc:fH};function gH(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.data.get(r.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(o.dataId).values),[u,c,h]=B$(a,s.shape,s.dtype,i,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const yH={kernelName:jh,backendName:"cpu",kernelFunc:gH};function bH(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=Sb(i,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const xH={kernelName:qh,backendName:"cpu",kernelFunc:bH};function wH(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=Sb(i,s.shape,s.dtype,a,l);return t.makeTensorInfo(c,s.dtype,u)}const vH={kernelName:Kh,backendName:"cpu",kernelFunc:wH};function IH(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Fr(o,r,a),p=!1,f=t.bufferSync(r);let m;switch(o.dtype){case"bool":{const g=t.bufferSync(o),y=!!t.data.get(i.dataId).values[0];m=qr(f,g,a,d,c,u,l,h,y,p);break}case"float32":{const g=t.bufferSync(o),y=t.data.get(i.dataId).values[0];m=qr(f,g,a,d,c,u,l,h,y,p);break}case"int32":{const g=t.bufferSync(o),y=t.data.get(i.dataId).values[0];m=qr(f,g,a,d,c,u,l,h,y,p);break}case"string":{const g=t.bufferSync(o),y=Ws(t.data.get(i.dataId).values[0]);m=qr(f,g,a,d,c,u,l,h,y,p);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return t.makeTensorInfo(a,m.dtype,m.values)}const $H={kernelName:Xh,backendName:"cpu",kernelFunc:IH};function SH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=Re(i,r.shape)[0],l=Pg(r,o,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const d=[...c];d[a]=h;const p=fo({inputs:{x:r},backend:t,attrs:{begin:u,size:d}});return u[a]+=h,p})}const NH={kernelName:Zl,backendName:"cpu",kernelFunc:SH};const CH={kernelName:Yh,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;me(t,"square");const r=s.data.get(t.dataId).values,o=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];o[a]=l*l}return{dataId:s.write(o,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const kH=He(Xi,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),TH={kernelName:Xi,backendName:"cpu",kernelFunc:kH};function EH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;me(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=bg(r.shape,o,i,a,l,u,c,h,d);let S;if(m)S=nt({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){C(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=mg(b,v,x),D=fo({inputs:{x:r},backend:t,attrs:{begin:b,size:k}});S=nt({inputs:{x:D},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(D)}else{const k=t.bufferSync(r),D=W$(p,k,x,b);S=t.makeTensorInfo(f,D.dtype,D.values)}return S}const AH={kernelName:Jh,backendName:"cpu",kernelFunc:EH};function RH(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=t.data.get(c.dataId).values,p=t.data.get(h.dataId).values,[f,m]=U$(d,p,r,o,i,a,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",m)]}const DH={kernelName:Zh,backendName:"cpu",kernelFunc:RH};function FH(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.data.get(o.dataId).values,l=t.data.get(i.dataId).values[0],[u,c,h]=G$(a,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const _H={kernelName:Qh,backendName:"cpu",kernelFunc:FH};function OH(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.data.get(o.dataId).values,a=H$(i,r);return t.makeTensorInfo(o.shape,"int32",a)}const LH={kernelName:ed,backendName:"cpu",kernelFunc:OH};const PH=He(ji,n=>Math.tan(n)),zH={kernelName:ji,backendName:"cpu",kernelFunc:PH};const BH=He(qi,n=>Math.tanh(n)),MH={kernelName:qi,backendName:"cpu",kernelFunc:BH};function VH(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:o}=e,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Fr(o,r,s.shape),h=!1,d=t.bufferSync(r),p=t.bufferSync(o),f=t.bufferSync(s),m=qr(d,p,s.shape,c,l,a,i,u,f,h);return t.makeTensorInfo(s.shape,m.dtype,m.values)}const WH={kernelName:Uh,backendName:"cpu",kernelFunc:VH};function UH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;me(r,"tile");const i=q$(t.bufferSync(r),o);return t.makeTensorInfo(i.shape,i.dtype,i.values)}const GH={kernelName:Ki,backendName:"cpu",kernelFunc:UH};function HH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:i}=s;me(r,"topk");const a=t.data.get(r.dataId).values,[l,u]=X$(a,r.shape,r.dtype,o,i);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const jH={kernelName:td,backendName:"cpu",kernelFunc:HH};function qH(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=t,[c,h,d,p]=r.shape,[f,m]=u??[h,d],g=[c,f,m,p],y=we(r.shape),b=y[0],v=y[1],x=y[2],S=we(g),k=S[0],D=S[1],F=S[2],A=Ot(r.dtype,X(g));A.fill(l);const R=s.data.get(r.dataId).values,N=s.data.get(o.dataId).values;for(let V=0;V<c;++V){const j=o.shape[0]===1?N:N.subarray(V*8,V*8+8);for(let G=0;G<f;++G)for(let q=0;q<m;++q)for(let J=0;J<p;++J){let K;const Q=j[6]*q+j[7]*G+1;if(Q===0)continue;const te=(j[0]*q+j[1]*G+j[2])/Q,ee=(j[3]*q+j[4]*G+j[5])/Q,ne=l0(te,d,a),oe=l0(ee,h,a);switch(i){case"nearest":K=QH(R,h,d,b,v,x,V,oe,ne,J,l);break;case"bilinear":K=ej(R,h,d,b,v,x,V,oe,ne,J,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const ue=V*k+G*D+q*F+J;A[ue]=K}return s.makeTensorInfo(g,r.dtype,A)}return{dataId:s.write(A,g,r.dtype),shape:r.shape,dtype:r.dtype}}const KH={kernelName:nd,backendName:"cpu",kernelFunc:qH};function l0(n,e,t){switch(t){case"reflect":return XH(n,e);case"wrap":return YH(n,e);case"nearest":return ZH(n,e);case"constant":default:return JH(n)}}function XH(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return mr(0,t,e-1)}function YH(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return mr(0,t,e-1)}function JH(n,e){return n}function ZH(n,e){return mr(0,n,e-1)}function Ea(n,e,t,s,r,o,i,a,l,u,c){const h=i*s+a*r+l*o+u;return 0<=a&&a<e&&0<=l&&l<t?n[h]:c}function QH(n,e,t,s,r,o,i,a,l,u,c){const h=Math.round(a),d=Math.round(l);return Ea(n,e,t,s,r,o,i,h,d,u,c)}function ej(n,e,t,s,r,o,i,a,l,u,c){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1,m=(f-l)*Ea(n,e,t,s,r,o,i,h,d,u,c)+(l-d)*Ea(n,e,t,s,r,o,i,h,f,u,c),g=(f-l)*Ea(n,e,t,s,r,o,i,p,d,u,c)+(l-d)*Ea(n,e,t,s,r,o,i,p,f,u,c);return(p-a)*m+(a-h)*g}function tj(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;me(o,"unique");const i=s.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=Y$(i,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const nj={kernelName:sd,backendName:"cpu",kernelFunc:tj};function sj(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r.shape.length,a=r.shape[o],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==o&&(l[u++]=r.shape[p]);const c=new Array(i).fill(0),h=r.shape.slice();h[o]=1;const d=new Array(a);for(let p=0;p<d.length;p++){c[o]=p;const f=fo({inputs:{x:r},backend:t,attrs:{begin:c,size:h}});d[p]=nt({inputs:{x:f},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(f)}return d}const rj={kernelName:tu,backendName:"cpu",kernelFunc:sj};function oj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:i}=s;me(r,"unsortedSegmentSum");const a=r.shape.length,l=o.shape.length,u=[],c=[],h=a-l;let d=o;for(let f=0;f<h;++f){const m=jc({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=m,c.push(m)}for(let f=0;f<i;++f){const m=Js(f,"int32"),g=t.makeTensorInfo([],"int32",m),y=h$({inputs:{a:g,b:d},backend:t}),b=Nr({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),v=gp({inputs:{a:b,b:r},backend:t}),x=Pu({inputs:{x:v},backend:t,attrs:{axis:0,keepDims:!1}});u.push(x),c.push(g),c.push(y),c.push(b),c.push(v),c.push(x)}const p=pS({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const ij={kernelName:nu,backendName:"cpu",kernelFunc:oj};const aj=[tW,LM,sW,oW,WM,aW,uW,hW,pW,mW,yW,xW,vW,SW,CW,EW,RW,FW,OW,QV,PW,BW,VW,GM,UW,MM,jM,HW,PM,qW,XW,YW,ZW,e4,n4,r4,i4,l4,c4,d4,f4,g4,b4,w4,v4,$4,N4,k4,T4,E4,A4,D4,O4,jV,P4,qM,H4,KM,j4,YM,Z4,Q4,tU,ZM,eV,sU,oU,aU,uU,nV,rV,zM,hU,KW,pU,mU,yU,qV,iV,lV,xU,cV,vU,SU,CU,EU,RU,FU,_U,dV,LU,zU,MU,WU,GU,jU,KU,fV,YU,QU,nG,gV,bV,oG,lG,hG,wV,pG,mG,gG,fS,wG,XV,$V,IG,SG,CG,TG,BM,kf,AG,YV,JV,ZV,DG,_G,LG,zG,MG,VG,UG,RV,HG,YG,ZG,nH,FV,rH,iH,lH,_V,eG,hH,pH,mH,yH,xH,vH,$H,NH,PV,CH,BV,VV,TH,AH,DH,_H,LH,HV,F4,zH,MH,WH,GH,jH,KH,vV,nj,rj,ij,fG];for(const n of aj)od(n);const Hr={},Qu={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function mS(n,e){Hr[n]=e}function ds(n,e){if(!(n in Hr)||e!=null){const s=uj(n,e);if(s!==null)Hr[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Hr[n];return t==null||t.isContextLost()?(delete Hr[n],ds(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Hr[n])}function lj(n){if(!H().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function uj(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??lj(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Hr[n]},!1),H().getBool("SOFTWARE_WEBGL_ENABLED")&&(Qu.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Qu)||t.getContext("experimental-webgl",Qu):t.getContext("webgl2",Qu)}var Ya;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Ya||(Ya={}));var Pn;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Pn||(Pn={}));var Gt;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Gt||(Gt={}));function zu(n,e){return[e,n]}function cj(n,e){return n*e}function ec(n){const e=X(n),t=Math.ceil(e/4);return vc(t)}function ca(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function hj(n,e){const[t,s]=ca(n,e);return t*s*4}function Eb(n,e){const t=n;let s,r,o,i,a,l,u,c,h,d;return H().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,o=t.RGBA16F,i=t.RGBA32F,a=t.RED,u=4,c=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,o=n.RGBA,i=t.RGBA,a=n.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function he(n,e){const t=e();return H().getBool("DEBUG")&&dj(n),t}function dj(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+yS(n,e))}const pj=596e-10,fj=65504;function gS(n){return!!(H().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||pj<Math.abs(n)&&Math.abs(n)<fj)}function yS(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Aa(n,e){return rr(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function bS(n,e){const t=rr(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(he(n,()=>n.shaderSource(t,e)),he(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function xS(n,e){const t=rr(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(he(n,()=>n.shaderSource(t,e)),he(n,()=>n.compileShader(t)),H().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw Ab(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const mj=/ERROR: [0-9]+:([0-9]+):/g;function Ab(n,e){const t=mj.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),o=r.length.toString().length+2,i=r.map((h,d)=>Kr((d+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const l=i.slice(0,s-1),u=i.slice(s-1,s),c=i.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Kr(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function wS(n){return rr(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function vS(n,e){if(he(n,()=>n.linkProgram(e)),!H().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function mc(n,e){if(he(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function IS(n,e){const t=rr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return he(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),he(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function $S(n,e){const t=rr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return he(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),he(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function gj(){return H().getNumber("WEBGL_VERSION")===2?1:4}function SS(n){return rr(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function NS(n,e){const t=H().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function CS(n){return rr(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Ef(n,e,t,s,r,o,i){const a=n.getAttribLocation(e,t);return a===-1?!1:(he(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),he(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,o,i)),he(n,()=>n.enableVertexAttribArray(a)),!0)}function kS(n,e,t){DS(n,t),he(n,()=>n.activeTexture(n.TEXTURE0+t)),he(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function yj(n,e){DS(n,e),he(n,()=>n.activeTexture(n.TEXTURE0+e)),he(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function TS(n,e,t){return rr(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function ES(n,e,t){return n.getUniformLocation(e,t)}function AS(n,e,t,s){he(n,()=>kS(n,e,s)),he(n,()=>n.uniform1i(t,s))}function bj(n){he(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),he(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),he(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function gc(n,e,t){he(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),he(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Af(n,e){he(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),he(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ra(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+RS(n,e))}function RS(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function rr(n,e,t){const s=he(n,()=>e());if(s==null)throw new Error(t);return s}function DS(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function mo(n,e=2){return X(n.slice(0,n.length-e))}function go(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Da(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[mo(n),...go(n)]),e}function FS(n,e=!1){let t=H().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=H().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&H().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?Zc(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Ys(n).newShape);let r=X(n),o=null;n.length<=1&&r<=t?o=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const i=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=mo(n);let l=2,u=2;n.length&&([l,u]=go(n)),r=a*(l/2)*(u/2),o=vc(r).map(c=>c*2)}else o=vc(r);return o}function tc(n){return n%2===0}function Ja(n,e){if(n=n.slice(-2),e=e.slice(-2),_e(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||tc(t)&&tc(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&tc(n[0])&&tc(e[0])}let yc,bc;function _S(n){if(yc==null){const e=ds(n);yc=e.getParameter(e.MAX_TEXTURE_SIZE)}return yc}function xj(){yc=null}function wj(){bc=null}function OS(n){if(bc==null){const e=ds(n);bc=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,bc)}function LS(n){if(n===0)return 0;let e;const t=ds(n);return zn(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:zn(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function zn(n,e){return n.getExtension(e)!=null}function Rf(n){try{if(ds(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function PS(n){if(n===0)return!1;const e=ds(n);if(n===1){if(!zn(e,"OES_texture_float"))return!1}else if(!zn(e,"EXT_color_buffer_float"))return!1;return Df(e)}function zS(n){if(n===0)return!1;const e=ds(n);if(n===1){if(!zn(e,"OES_texture_float")||!zn(e,"WEBGL_color_buffer_float"))return!1}else{if(zn(e,"EXT_color_buffer_float"))return Df(e);const s="EXT_color_buffer_half_float";if(zn(e,s)){const r=e.getExtension(s);return vj(e,r)}return!1}return Df(e)}function Df(n){const e=Eb(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),i}function vj(n,e){const t=Eb(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(i),a}function BS(n){return n!==2?!1:ds(n).fenceSync!=null}function ha(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&C(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const Ij=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:ha,bindCanvasToFramebuffer:bj,bindColorTextureToFramebuffer:gc,bindTextureToProgramUniformSampler:AS,bindTextureUnit:kS,bindVertexBufferToProgramAttribute:Ef,callAndCheck:he,canBeRepresented:gS,createFragmentShader:xS,createFramebuffer:CS,createProgram:wS,createStaticIndexBuffer:$S,createStaticVertexBuffer:IS,createTexture:SS,createVertexShader:bS,getBatchDim:mo,getExtensionOrThrow:Aa,getFramebufferErrorMessage:RS,getMaxTexturesInShader:OS,getNumChannels:gj,getProgramUniformLocation:ES,getProgramUniformLocationOrThrow:TS,getRowsCols:go,getShapeAs3D:Da,getTextureShapeFromLogicalShape:FS,getWebGLDisjointQueryTimerVersion:LS,getWebGLErrorMessage:yS,getWebGLMaxTextureSize:_S,hasExtension:zn,isCapableOfRenderingToFloatTexture:PS,isDownloadFloatTextureEnabled:zS,isReshapeFree:Ja,isWebGLFenceEnabled:BS,isWebGLVersionEnabled:Rf,linkProgram:vS,logShaderSourceAndInfoLog:Ab,resetMaxTextureSize:xj,resetMaxTexturesInShader:wj,unbindColorTextureFromFramebuffer:Af,unbindTextureUnit:yj,validateFramebuffer:Ra,validateProgram:mc,validateTextureSize:NS},Symbol.toStringTag,{value:"Module"}));const ye=H();ye.registerFlag("HAS_WEBGL",()=>ye.getNumber("WEBGL_VERSION")>0);ye.registerFlag("WEBGL_VERSION",()=>Rf(2)?2:Rf(1)?1:0);ye.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ye.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ye.get("WEBGL_VERSION")===2);ye.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ye.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ye.registerFlag("WEBGL_PACK",()=>ye.getBool("HAS_WEBGL"));ye.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_CLIP",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_REDUCE",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_LAZILY_UNPACK",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_CONV_IM2COL",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>_S(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>OS(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ye.getNumber("WEBGL_VERSION");return n===0?0:LS(n)});ye.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ye.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Gf());ye.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>PS(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ye.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ye.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ye.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>zS(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_FENCE_API_ENABLED",()=>BS(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ye.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ye.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ye.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Gf()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ye.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ye.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ye.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ye.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ye.registerFlag("WEBGL_EXP_CONV",()=>!1);ye.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ye.getBool("IS_TEST"));ye.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ye.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ye.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ye.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function un(){let n,e,t,s,r,o,i,a,l,u;return H().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",o="outputColor",i="out vec4 outputColor;",a=H().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Eo(n,e,t="index"){const s=we(e);return s.map((r,o)=>{const i=`int ${n[o]} = ${t} / ${r}`,a=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${i}; ${a};`}).join("")}function yp(n,e,t="index"){const s=we(e);return s.map((r,o)=>{const i=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,a=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function $j(n,e){const t=n.length,s=n.map(o=>`${e}[${o}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function Sj(n,e,t="index"){const s=n.map((o,i)=>i),r=$j(s,e);return r.map((o,i)=>{const a=`int ${n[i]} = ${t} / ${r[i]}`,l=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r[i]}`:`index -= ${n[i]} * ${r[i]}`;return`${a}; ${l};`}).join("")}function Rb(n){const e=we(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Db(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const MS=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:VS}=bv;function Nj(n,e,t){const s=[];if(n.forEach(p=>{const f=X(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:m}=Fb(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),o=n.map(p=>Cj(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=un(),l=Ej(a);let u,c,h=Dj(a);return e.isPacked?(u=kj(e.logicalShape,i,t.enableShapeUniforms),c=Rj(a)):(u=Tj(e.logicalShape,i,t.enableShapeUniforms),c=Aj(a)),t.packedInputs&&(h+=Lj),[h,l,c,r,u,o,t.userCode].join(`
`)}function da(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Kj(n,e);case 1:return Yj(n,e);case 2:return Zj(n,e);case 3:return eq(n,e);case 4:return nq(n,e);case 5:return sq(n);case 6:return rq(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function WS(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return qj(n);case 1:return Xj(n,e);case 2:return Jj(n,e);case 3:return Qj(n,e);default:return tq(n,e)}}function Cj(n,e,t=!1,s){let r="";t?r+=WS(n,s):r+=da(n,s);const o=n.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(t?r+=oq(n,e):r+=iq(n,e)),r}function kj(n,e,t){switch(n.length){case 0:return US();case 1:return Pj(n,e,t);case 2:return Hj(n,e,t);case 3:return Bj(n,e,t);default:return Vj(n,e,t)}}function Tj(n,e,t){switch(n.length){case 0:return US();case 1:return zj(n,e,t);case 2:return jj(n,e,t);case 3:return Mj(n,e,t);case 4:return Wj(n,e,t);case 5:return Uj(n,e);case 6:return Gj(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Ej(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Aj(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Rj(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Dj(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Fj}
    ${_j}
    ${Oj}
  `}const Fj=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,_j=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Oj=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Lj=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function US(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Pj(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function zj(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Bj(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Mj(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${yp(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Eo(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function Vj(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function Wj(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${yp(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Eo(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Uj(n,e){const t=Eo(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Gj(n,e){const t=Eo(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Hj(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(_e(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function jj(n,e,t){return _e(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Ao(n){return`offset${n}`}function qj(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=un();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function Kj(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,o]=n.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Ao(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Xj(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,o=un();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function Yj(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${pa(n)}
      }
    `;const r=n.shapeInfo.texShape,o=r[0],i=r[1];if(i===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Ao(t);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Jj(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],l=un();if(o!=null&&_e(t,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Zj(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape;if(o!=null&&_e(t,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=o[0],p=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:a}=Ys(t),l=i;if(l.length<t.length){const d=fa(n,l),p=["row","col"];return`
      ${da(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${ma(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${pa(n)}
      }
    `;const u=o[0],c=o[1],h=Ao(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function Qj(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=fa(n,d),m=["b","row","col"];return`
        ${WS(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${ma(m,p)});
        }
      `}const a=un();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function eq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[1]*t[2],i=t[2],{newShape:a,keptDims:l}=Ys(t),u=a;if(u.length<t.length){const m=fa(n,u),g=["row","col","depth"];return`
        ${da(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${ma(g,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${pa(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],d=c[1],p=n.shapeInfo.flatOffset;if(d===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Ao(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function tq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=un();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],h=Math.ceil(o[i-1]/2);let d=h*Math.ceil(o[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,d*=o[i-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${t}, uv);
    }
  `}function nq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[3],i=t[2]*o,a=t[1]*i,{newShape:l,keptDims:u}=Ys(t);if(l.length<t.length){const b=fa(n,l),v=["row","col","depth","depth2"];return`
      ${da(b,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${ma(v,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${pa(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,m=`int stride1 = ${s}Shape[2] * stride2;`,g=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=Ao(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function sq(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],o=e[3]*r,i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:u}=Ys(e);if(l.length<e.length){const m=fa(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${da(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${ma(g,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${r})) +
          depth3;
        ${pa(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Ao(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function rq(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:o}=Ys(e);if(r.length<e.length){const g=fa(n,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${da(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${ma(y,o)});
      }
    `}const i=e[5],a=e[4]*i,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${pa(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=Ao(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function pa(n){const e=n.name,t=X(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function oq(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=VS(n.shapeInfo.logicalShape,e.logicalShape),l=Xe(i),u=i-o;let c;const h=["x","y","z","w","u","v"];o===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${h[b+u]} = 0;`).join(`
`);let d="";i<2&&o>0?d="coords":d=n.shapeInfo.logicalShape.map((b,v)=>`coords.${h[v+u]}`).join(", ");let p="return outputValue;";const m=X(n.shapeInfo.logicalShape)===1,y=X(e.logicalShape)===1;if(o===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=o-2,v=o-1;a.indexOf(b)>-1&&a.indexOf(v)>-1?p="return vec4(outputValue.x);":a.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function iq(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&_e(i,o))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=Xe(l),c=VS(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function Xe(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Fb(n,e,t){const{newShape:s,keptDims:r}=Ys(e),o=e.length,i=n&&o===3&&e[0]===1,a=i?e.slice(1):s,l=!n&&o>1&&!_e(e,t)&&s.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function fa(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function ma(n,e){return e.map(t=>n[t]).join(", ")}function aq(n,e,t,s){const r=t.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),o=r.map(c=>c.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=Nj(r,i,e),l=xS(n.gl,a),u=n.createProgram(l);return H().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},GS(n,e,u)))}function GS(n,e,t){const s=[],r=[];let o,i,a,l=null,u=null;u=n.getUniformLocation(t,"NAN",!1),H().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:n.getUniformLocation(t,h,c),offset:n.getUniformLocation(t,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${h}Shape`,c),d.texShape=n.getUniformLocation(t,`${h}TexShape`,c)),s.push(d)}if(e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",c),a=n.getUniformLocation(t,"outShapeStrides",c),i=n.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)r.push(n.getUniformLocation(t,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function u0(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,o=e[s],i=o.shape;if(!_e(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(t.isUniform&&o.isUniform)return;const a=t.texShape,l=o.isUniform?null:o.texData.texShape;if(!_e(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function lq(n,e,t,s,r){e.program.enableShapeUniforms||(u0(e.inShapeInfos,t),u0([e.outShapeInfo],[s]));const o=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),H().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:h,shape:d,texShape:p}=e.variablesLocations[l];if(d){const{uniformShape:f}=Fb(e.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(d,new Int32Array(f));break;case 2:n.gl.uniform2iv(d,new Int32Array(f));break;case 3:n.gl.uniform3iv(d,new Int32Array(f));break;case 4:n.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&n.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(X(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=we(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=r[l];if(u.type==="float")n.gl.uniform1fv(c,h);else if(u.type==="vec2")n.gl.uniform2fv(c,h);else if(u.type==="vec3")n.gl.uniform3fv(c,h);else if(u.type==="vec4")n.gl.uniform4fv(c,h);else if(u.type==="int")n.gl.uniform1iv(c,h);else if(u.type==="ivec2")n.gl.uniform2iv(c,h);else if(u.type==="ivec3")n.gl.uniform3iv(c,h);else if(u.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function uq(n,e,t){let s="";e.concat(t).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=Fb(n.packedInputs,i.shape,l);let d="",p="",f="";if(c.length===1&&n.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${S[0]>1}_${S[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const S=we(c);f=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const m=i.shape.length,g=c.length===2&&_e(i.shape,l),y=X(i.shape)===1,b=oo(i.shape,t.shape),v=!n.packedInputs&&m===t.shape.length&&_e(l,t.texData.texShape),x=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${m}_${v}_${u?h:""}_${c.length}_${y}_${b}_${g}_${d}_${p}_${f}_${x}_${a}`}else{const l=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${l}_${a}`}});const r=n.userCode;let o=n.constructor.name;return o+="_"+s+"_"+r+`${H().getNumber("WEBGL_VERSION")}`,o}function Qt(n){return H().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class cq{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ya.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yp(["r","c","d"],e):Eo(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class hq{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ya.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yp(["r","c","d"],e):Eo(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class dq{constructor(e){this.variableNames=["A"],this.outTexUsage=Pn.DOWNLOAD;const t=un();this.outputShape=e,this.userCode=`
      ${MS}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class pq{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Pn.DOWNLOAD;const t=un();this.outputShape=e,this.userCode=`
      ${MS}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const fq={R:0,G:1,B:2,A:3};class c0{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<s.length;a++){const l=s[a];i+=`
          if(offset == ${a}) {
            result = values[${fq[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Db():Rb(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}class mq{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);let r="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=i*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Db():Rb(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}function HS(n){const e=un(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return bS(n,t)}function jS(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return IS(n,e)}function qS(n){const e=new Uint16Array([0,1,2,2,1,3]);return $S(n,e)}function Bu(n,e,t,s,r,o){NS(e,t);const i=SS(n),a=n.TEXTURE_2D;return he(n,()=>n.bindTexture(a,i)),he(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),he(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),he(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),he(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),H().getNumber("WEBGL_VERSION")===1?he(n,()=>n.texImage2D(a,0,s,e,t,0,r,o,null)):he(n,()=>n.texStorage2D(a,1,s,e,t)),he(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function _b(n){return n.internalFormatFloat}function KS(n,e,t,s){const[r,o]=zu(e,t);return Bu(n,r,o,_b(s),s.textureFormatFloat,n.FLOAT)}function Ob(n){return n.internalFormatHalfFloat}function XS(n,e,t,s){const[r,o]=zu(e,t);return Bu(n,r,o,Ob(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function Lb(n){return n.downloadTextureFormat}function YS(n,e,t,s){const[r,o]=zu(e,t);return Bu(n,r,o,Lb(s),n.RGBA,n.UNSIGNED_BYTE)}function Pb(n){return n.internalFormatPackedFloat}function JS(n,e,t,s){const[r,o]=ca(e,t);return Bu(n,r,o,Pb(s),n.RGBA,n.FLOAT)}function zb(n){return n.internalFormatPackedHalfFloat}function ZS(n,e,t,s){const[r,o]=ca(e,t);return Bu(n,r,o,zb(s),n.RGBA,s.textureTypeHalfFloat)}function QS(n,e,t){return he(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Ef(n,e,"clipSpacePos",t,3,20,0)&&Ef(n,e,"uv",t,2,20,12)}function eN(n,e,t,s,r,o){he(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,l;r instanceof Uint8Array?(i=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(t*s*4),a=n.FLOAT,l=o.internalFormatPackedFloat),i.set(r),H().getNumber("WEBGL_VERSION")===2?he(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,i)):he(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,i)),he(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function tN(n,e,t){he(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?H().getNumber("WEBGL_VERSION")===2?he(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):he(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):H().getNumber("WEBGL_VERSION")===2?he(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):he(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),he(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function nN(n,e,t,s){const r=n.createBuffer();he(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return he(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),he(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),he(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function sN(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function rN(n,e,t,s){const[r,o]=zu(e,t),i=4,a=new Uint8Array(cj(e*t,i));return he(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function oN(n,e,t,s,r,o,i,a){const l=n,u=new Float32Array(hj(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function iN(n,e,t){const s=new Float32Array(e*t*4);return he(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const gq=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:QS,createBufferFromOutputTexture:nN,createFloat16MatrixTexture:XS,createFloat16PackedMatrixTexture:ZS,createFloat32MatrixTexture:KS,createIndexBuffer:qS,createPackedMatrixTexture:JS,createUnsignedBytesMatrixTexture:YS,createVertexBuffer:jS,createVertexShader:HS,downloadByteEncodedFloatMatrixFromOutputTexture:rN,downloadFloat32MatrixFromBuffer:sN,downloadMatrixFromPackedOutputTexture:iN,downloadPackedMatrixFromBuffer:oN,getInternalFormatForFloat16MatrixTexture:Ob,getInternalFormatForFloat16PackedMatrixTexture:zb,getInternalFormatForFloat32MatrixTexture:_b,getInternalFormatForPackedMatrixTexture:Pb,getInternalFormatForUnsignedBytesMatrixTexture:Lb,uploadDenseMatrixToTexture:eN,uploadPixelDataToTexture:tN},Symbol.toStringTag,{value:"Module"}));class xc{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=H().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,mS(t,e)):this.gl=ds(t),e=this.gl,H().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>he(o,()=>o.createVertexArray()),this.bindVertexArray=i=>he(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>he(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>he(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>he(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>he(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>he(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>he(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),H().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Aa(this.gl,o),zn(this.gl,i))this.textureHalfFloatExtension=Aa(this.gl,i);else if(H().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),zn(this.gl,r))this.colorBufferHalfFloatExtension=Aa(this.gl,r);else if(H().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",zn(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(zn(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=jS(this.gl),this.indexBuffer=qS(this.gl),this.framebuffer=CS(this.gl),this.textureConfig=Eb(this.gl,this.textureHalfFloatExtension)}get debug(){return H().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;he(e,()=>e.finish()),he(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),he(e,()=>e.deleteFramebuffer(this.framebuffer)),he(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),he(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),he(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),KS(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),XS(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),YS(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),tN(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),eN(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),ZS(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),JS(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Af(this.gl,this.framebuffer),this.outputTexture=null),he(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>rN(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,o,i){return oN(this.gl,e,t,s,r,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return sN(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=nN(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(H().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(o,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},t=o}else H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>iN(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=HS(t));const s=wS(t);he(t,()=>t.attachShader(s,this.vertexShader)),he(t,()=>t.attachShader(s,e)),vS(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&mc(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;he(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),QS(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(he(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&mc(this.gl,this.program),he(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?TS(this.gl,e,t):ES(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),he(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),AS(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,o]=ca(t,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&mc(this.gl,this.program),Ra(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}he(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),he(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Aa(this.gl,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Bp(()=>this.disposed||this.isQueryAvailable(e,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=yq(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in H().platform&&(s=H().platform.setTimeoutCustom.bind(H().platform)),Bp(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),gc(this.gl,e,this.framebuffer),this.debug&&Ra(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(gc(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ra(this.gl)):Af(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;gc(r,e,this.framebuffer),this.debug&&Ra(r),this.outputTexture=e,he(r,()=>r.viewport(0,0,t,s)),he(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),he(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function yq(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:bq,bincountImpl:aN,bincountReduceImpl:xq,bitwiseAndImpl:wq,castImpl:vq,ceilImpl:Iq,concatImpl:$q,equalImpl:Sq,expImpl:Nq,expm1Impl:Cq,floorImpl:kq,gatherNdImpl:Tq,gatherV2Impl:Eq,greaterImpl:Aq,greaterEqualImpl:Rq,lessImpl:Dq,lessEqualImpl:Fq,linSpaceImpl:_q,logImpl:Oq,maxImpl:Lq,maximumImpl:Pq,minimumImpl:zq,multiplyImpl:Bq,negImpl:Mq,notEqualImpl:Vq,prodImpl:Wq,raggedGatherImpl:Uq,raggedRangeImpl:Gq,raggedTensorToTensorImpl:Hq,rangeImpl:jq,rsqrtImpl:qq,scatterImpl:Kq,sigmoidImpl:Xq,simpleAbsImpl:lN,sliceImpl:Yq,sparseFillEmptyRowsImpl:Jq,sparseReshapeImpl:Zq,sparseSegmentReductionImpl:uN,sqrtImpl:Qq,staticRegexReplaceImpl:e6,stridedSliceImpl:t6,stringNGramsImpl:n6,stringSplitImpl:s6,stringToHashBucketFastImpl:r6,subImpl:o6,tileImpl:i6,topKImpl:a6,transposeImpl:Bb,uniqueImpl:l6}=J$;function cN(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function sn(n,e){return e===1?[n]:cN(n,e)}function u6(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class c6{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Qt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=sn("rc",this.rank),s=Xe(this.rank),r=this.getOutOfBoundsCondition(t),o=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class hN{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${h6(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Db():Rb(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function h6(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Sj(["r","c","d"],"inputShape"):Eo(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class d6{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=d0(t,s),o=p0(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=h0(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return r===Gt.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Gt.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Gt.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Gt.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Gt.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const o=d0(s,r),i=p0(t,o,r);i in this.freeTextures||(this.freeTextures[i]=[]);const a=h0(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=H().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function p6(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function h0(n,e,t,s,r){const o=f6(e,s);let i;if(r){const[l,u]=ca(n[0],n[1]);i=l*u}else{const[l,u]=zu(n[0],n[1]);i=l*u}const a=p6(t,o);return i*a}function f6(n,e){switch(n){case Gt.PACKED_2X2_FLOAT32:return Pb(e);case Gt.PACKED_2X2_FLOAT16:return zb(e);case Gt.UNPACKED_FLOAT32:return _b(e);case Gt.UNPACKED_FLOAT16:return Ob(e);case Gt.PACKED_4X1_UNSIGNED_BYTE:return Lb(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function m6(n){return H().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Gt.PACKED_2X2_FLOAT32:Gt.UNPACKED_FLOAT32:n?Gt.PACKED_2X2_FLOAT16:Gt.UNPACKED_FLOAT16}function d0(n,e){if(n===Pn.UPLOAD)return Gt.PACKED_2X2_FLOAT32;if(n===Pn.RENDER||n==null)return m6(e);if(n===Pn.DOWNLOAD||n===Pn.PIXELS)return Gt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function p0(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class Is{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Jn="if (isnan(x)) return x;",g6="return x;",f0="return abs(x);",y6="return (x >= 0.0) ? x : (exp(x) - 1.0);",b6=Jn+`
  return (x < 0.0) ? 0.0 : x;
`,x6=Jn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ir="return x;",w6="return 1.0 / (1.0 + exp(-1.0 * x));";const v6="return x;",I6=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,$6=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,S6=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,N6="return 1.0 / (1.0 + exp(-1.0 * x));";class cr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class C6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);const t=e.length,s=sn("rc",t),r=Xe(t),o=u6(t,s),i=s.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}const k6=_d,T6=1e-7,E6=1e-4,nc={};function A6(n){return n in nc||(nc[n]={}),nc[n]}const R6=H().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),D6=600;function F6(){return H().global.screen==null?1024:H().global.screen.height*H().global.screen.width*window.devicePixelRatio*D6/1024/1024}class Mu extends Jc{nextDataId(){return Mu.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!H().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof xc)t=e;else{const s=ds(H().getNumber("WEBGL_VERSION"),e);t=new xc(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=ds(H().getNumber("WEBGL_VERSION"));t=new xc(s),this.binaryCache=A6(H().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new d6(this.gpgpu),this.numMBBeforeWarning=F6(),this.texData=new Lf(this,ns())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,o,i){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,o]},l.texShape=[r,o];const u=Da(t),c=new c0(u,!1,i),h=this.runWebGLProgram(c,[a],s,[[r,o]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,s){if((H().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||H().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Pn.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,o){if(H().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Pn.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:i,shape:a,isPacked:l}=t;if(i!=null){let d;l?d=new cr(a,ir):d=new Is(a,ir);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let c;u&&(c=Vt());let h;if(r==="complex64"){const d=this.readSync(o.real.dataId),p=this.readSync(o.imag.dataId);h=js(d,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Vt()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const t=this.texData.get(e),{values:s,shape:r,slice:o,dtype:i,complexTensorInfos:a,isPacked:l}=t;if(o!=null){let f;l?f=new cr(r,ir):f=new Is(r,ir);const m=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(H().getBool("DEBUG")&&!H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&H().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&H().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...ec(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=f[0],g=f[1];h=js(m,g)}else if(u==null)h=this.getValuesFromTexture(e);else{const f=X(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;he(f,()=>f.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ns().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:o,slice:i,dtype:a,isPacked:l,texture:u}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new cr(o,ir):p=new Is(o,ir);const f=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:a}],a),m=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),m}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=ns().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ws(r));return Ee(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ee(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!gS(s))throw H().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),o=X(t);if(H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...ec(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),f}const i=H().getBool("WEBGL_PACK")&&r===!0,a=i?Da(t):t,l=i?new pq(a):new dq(a),u=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=Ts(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Ts(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);a.kernelMs=P0(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Vt(),endMs:null}}endTimer(e){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Vt(),e)}async getQueryTime(e){if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:o,isPacked:i,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,o,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=R6){return H().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&X(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Fn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return k6(e.shape,t)}packedUnaryOp(e,t,s){const r=new cr(e.shape,t),o=this.compileAndRun(r,[e],s);return ns().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=lN(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(H().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,f0,e.dtype);const t=new Is(e.shape,f0),s=this.compileAndRun(t,[e]);return ns().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&vs(s[0])){const o=s.map(i=>$s(i));r=this.write(o,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return ns().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new C6(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new c6(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[mo(e.shape),...go(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[mo(t),...go(t)],i=new hN(o,s),a=!0,l=[s],u=this.runWebGLProgram(i,[r],e.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:i}=s;if(t!=null){const d=X(o),p=t[0]*t[1]*4;C(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Da(o);let l;r?l=new hq(a):l=new cq(a);const u=!0,c=[t??ec(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,c,u,t);return{dtype:i,shape:o,dataId:h.dataId}}runWebGLProgram(e,t,s,r,o=!1,i){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Ya.DENSE){const y=i??ec(e.outputShape);l.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),X(a.shape)===0)return l.values=Ot(a.dtype,0),a;const u=[],c=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&X(y.shape)<=H().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!Ja(b.shape,y.shape)){const v=y,x=y.shape;y.shape=b.shape,y=this.packedReshape(y,x),u.push(y),b=this.texData.get(y.dataId),v.shape=x}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=uq(e,c,h),p=this.getAndSaveBinary(d,()=>aq(this.gpgpu,e,c,h)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),H().get("ENGINE_COMPILE_ONLY")||lq(this.gpgpu,p,c,h,r),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=H().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=Vt();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!H().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,t,s,r,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(H().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=U(()=>{if(!H().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=H().getBool("DEBUG");H().set("DEBUG",!1);const t=this.abs(xe(1e-8)).dataSync()[0];if(H().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?T6:E6}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:o,texture:i,usage:a,isPacked:l}=t;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Vt());let h=t.texShape;if(h==null&&(h=FS(s,l),t.texShape=h),o!=null){const d=Da(s);let p,f=h[1],m=h[0];const g=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!g)&&([f,m]=ca(h[0],h[1])),l?p=new mq(d,g):p=new c0(d,g);const y=g?[m,f]:h,b=this.makeTensorInfo(y,r),v=this.texData.get(b.dataId);g?v.usage=Pn.PIXELS:v.usage=Pn.UPLOAD,v.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,o);const x=[[m,f]],k=this.runWebGLProgram(p,[b],r,x,!0),D=this.texData.get(k.dataId);t.texShape=D.texShape,t.isPacked=D.isPacked,t.usage=D.usage,H().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=D.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=Vt()-c)}else{const d=this.acquireTexture(h,a,r,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=_6(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Oa(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await xg(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Ab(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:l}=GS(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:i,channels:a}=e,l=ns().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,t,s,o,i,a);return ns().makeTensorFromDataId(u,t,s,l)}}Mu.nextDataId=0;function _6(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}const dN="4.22.0";function pN(){H().set("WEBGL_FORCE_F16_TEXTURES",!0)}Hf()&&qf("webgl",()=>new Mu,2);const O6={forceHalfFloat:pN};const Mb=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class yo{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Ne(t,s),this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Ro=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ga{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ne(t,s);const o=this.outputShape.length;this.enableShapeUniforms=Qt(o);let i="";if(r)if(o===0||X(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Xe(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=sn("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}function Tn(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const L6={kernelName:vi,backendName:"webgl",kernelFunc:Tn};function Or(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),i=t.texData.get(o.dataId),a=Tn({inputs:{x:s},backend:t}),l=Tn({inputs:{x:r},backend:t});return i.complexTensorInfos={real:a,imag:l},o}const P6={kernelName:ih,backendName:"webgl",kernelFunc:Or};const fN="return (a < 0.) ? b * a : a;",mN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function z6(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,i=t.makeTensorInfo([],"float32",Js(o,"float32")),a=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ga(mN,r.shape,i.shape):new yo(fN,r.shape,i.shape),l=t.runWebGLProgram(a,[r,i],"float32");return t.disposeIntermediateTensorInfo(i),l}const B6={kernelName:$l,backendName:"webgl",kernelFunc:z6};const gN="return (a < 0.) ? b * a : a;",yN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function M6(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ga(yN,s.shape,r.shape):new yo(gN,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],"float32")}const V6={kernelName:Wl,backendName:"webgl",kernelFunc:M6};const ya="if (isnan(x)) return x;";function Be({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:i}=r,a=o,l=s||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){const h=a.texData.get(i.dataId),d=t(h.values,l);return a.makeTensorInfo(i.shape,l,d)}const u=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new cr(i.shape,e):c=new Is(i.shape,n),a.runWebGLProgram(c,[i],l)}}function Jt({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(s&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{const[x,S]=v,k={dataId:x.dataId,dtype:x.dtype,shape:l.shape},D={dataId:S.dataId,dtype:S.dtype,shape:u.shape},F=new yo(n,l.shape,u.shape);return c.runWebGLProgram(F,[k,D],pn(x.dtype,S.dtype))}),b=Or({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const h=o||pn(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?qs(f):f,y=l.dtype==="string"?qs(m):m,[b,v]=r(l.shape,u.shape,g,y,h),x=c.makeTensorInfo(v,h),S=c.texData.get(x.dataId);return S.values=b,x}const d=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new ga(e,l.shape,u.shape,t):p=new yo(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function Za(n,e=!1){if(n==="linear")return e?v6:g6;if(n==="relu")return e?$6:b6;if(n==="elu")return e?I6:y6;if(n==="relu6")return e?S6:x6;if(n==="prelu")return e?yN:gN;if(n==="leakyrelu")return e?mN:fN;if(n==="sigmoid")return e?N6:w6;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class bN{constructor(e,t,s,r=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Qt(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",x="rc.x";e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${x};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}const m0={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class g0{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ne(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const y0="return a * b;";function Vb(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=pn(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),u=new g0(m0.REAL,s.shape,r.shape),c=new g0(m0.IMAG,s.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=Or({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[u,c]=Bq(s.shape,r.shape,a.values,l.values,o),h=t.makeTensorInfo(c,o),d=t.texData.get(h.dataId);return d.values=u,h}let i;return H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new ga(y0,s.shape,r.shape):i=new yo(y0,s.shape,r.shape),t.runWebGLProgram(i,[s,r],o)}const W6={kernelName:Ai,backendName:"webgl",kernelFunc:Vb};function U6(n,e,t){const s=[mo(n.shape),...go(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[mo(e),...go(e)],i=new hN(o,s),a=!0,l=[s],u=t.runWebGLProgram(i,[r],n.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function ce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,i=t,a=X(r.shape),l=zf(o,a),u=X(l);C(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return c.isPacked&&!Ja(r.shape,l)&&!(c.texture!==null&&Ja(c.shape,l))?U6(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const G6={kernelName:Gl,backendName:"webgl",kernelFunc:ce};class b0{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];const a=Math.floor(s/4)*4,l=s%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${Qr(h)?h.toPrecision(2):h}, ones);`}let c="";o%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}class H6{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}function j6(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=jd(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Do(n,e,t,s){const r=j6(n.shape);let o=n;for(let i=0;i<r.length;i++){const{inSize:a,windowSize:l,outSize:u}=r[i];let c,h;t==="mean"?c=i===0?new b0({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new b0({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):c=new H6({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},t),h=o,o=s.runWebGLProgram(c,[o],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return o}class q6{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.rank=s.length;const r=Xe(this.rank),o=K6(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function K6(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class X6{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[t[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Xe(this.rank),o=cN("rc",this.rank),i=new Array(this.rank);for(let c=0;c<t.length;c++)i[t[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}function bp(n,e,t){const s=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new X6(n.shape,e):new q6(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function Y6(n,e,t,s){const r=e,o=n.shape.length,i=Re(r,n.shape);let a=i;const l=dt(a,o),u=l!=null;let c=n;u&&(c=bp(n,l,s),a=bt(a.length,o)),Xt("sum",a,o);const[h,d]=Bt(c.shape,a);let p=h;t&&(p=yt(h,i));const f=X(d),g=X(n.shape)/f,y=ce({inputs:{x:c},attrs:{shape:[g,f]},backend:s}),b=id(n.dtype),v=Do(y,b,"sum",s),x=ce({inputs:{x:v},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(v),u&&s.disposeIntermediateTensorInfo(c),x}function xp(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;return Y6(r,o,i,t)}const J6={kernelName:Yl,backendName:"webgl",kernelFunc:xp};function on(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,i=t,a=r.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=r.shape[o[c]];let u;if(i.shouldExecuteOnCPU([r])){const h=i.texData.get(r.dataId).values,d=Bb(h,r.shape,r.dtype,o,l);u=i.makeTensorInfo(l,r.dtype);const p=i.texData.get(u.dataId);p.values=d}else u=bp(r,o,i);return u}const Z6={kernelName:Xr,backendName:"webgl",kernelFunc:on};const xN=1e3;function Kc({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],p=t?n.shape[u-1]:n.shape[u-2],f=s?e.shape[c-2]:e.shape[c-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=X(m),b=X(g),x=Ne(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);C(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const S=t?[y,h,p]:[y,p,h],k=s?[b,f,d]:[b,d,f],D=ce({inputs:{x:n},backend:r,attrs:{shape:S}}),F=ce({inputs:{x:e},backend:r,attrs:{shape:k}}),A=[D,F],R=Math.max(y,b),N=t?D.shape[1]:D.shape[2],z=o!=null,V=i!=null,j=l==="leakyrelu",G=l!=null?Za(l,!0):null,q=z||V||j||G!=null;let J;if((p===1||f===1)&&N>xN&&q===!1){let Q=D,te=F;t&&(Q=on({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),A.push(Q)),s&&(te=on({inputs:{x:F},backend:r,attrs:{perm:[0,2,1]}}),A.push(te));const ee=f!==1,ne=f===1;let oe=Q;ee&&(oe=ce({inputs:{x:Q},backend:r,attrs:{shape:[R,N,1]}}),A.push(oe));const ue=f===1?2:1;let ae=te;ne&&(ae=ce({inputs:{x:te},backend:r,attrs:{shape:[R,1,N]}}),A.push(ae));const de=Vb({inputs:{a:oe,b:ae},backend:r});J=xp({inputs:{x:de},backend:r,attrs:{axis:ue,keepDims:!0}}),A.push(de)}else{const Q=pn(n.dtype,e.dtype),te=new bN(S,k,[R,p,f],t,s,z,G,V,j),ee=[D,F];if(o!=null&&ee.push(o),V&&ee.push(i),j){const ne=r.makeTensorInfo([],"float32",Js(a,"float32"));ee.push(ne),A.push(ne)}J=r.runWebGLProgram(te,ee,Q)}const K=ce({inputs:{x:J},backend:r,attrs:{shape:x}});A.push(J);for(const Q of A)r.disposeIntermediateTensorInfo(Q);return K}function Q6(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return Kc({a:r,b:o,transposeA:l,transposeB:u,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const eK={kernelName:La,backendName:"webgl",kernelFunc:Q6};const x0="return abs(x);";function tK(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=t.texData.get(s.dataId),i=lN(o.values);return t.makeTensorInfo(s.shape,s.dtype,i)}let r;return H().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new cr(s.shape,x0):r=new Is(s.shape,x0),t.runWebGLProgram(r,[s],s.dtype)}const nK={kernelName:tl,backendName:"webgl",kernelFunc:tK};const sK=Jn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,rK=Be({opSnippet:sK}),oK={kernelName:ti,backendName:"webgl",kernelFunc:rK};const iK=Jn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,aK=Be({opSnippet:iK}),lK={kernelName:ni,backendName:"webgl",kernelFunc:aK};const w0="return a + b;",uK=Jt({opSnippet:w0,packedOpSnippet:w0,supportsComplex:!0,cpuKernelImpl:bq}),cK={kernelName:vo,backendName:"webgl",kernelFunc:uK};class hK{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class dK{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function wc(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Tn({inputs:{x:s[0]},backend:t});if(s.length>H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=wc({inputs:s.slice(0,l),backend:t}),c=wc({inputs:s.slice(l),backend:t});return wc({inputs:[u,c],backend:t})}const r=s.map(l=>l.dtype).reduce((l,u)=>pn(l,u)),o=s.map(l=>l.shape),a=H().getBool("WEBGL_PACK")?new dK(s[0].shape,o):new hK(s[0].shape,o);return t.runWebGLProgram(a,s,r)}const pK={kernelName:nl,backendName:"webgl",kernelFunc:wc};function fK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=Re(o,r.shape);let u=l;const c=dt(u,a);let h=r;c!=null&&(h=on({inputs:{x:r},backend:t,attrs:{perm:c}}),u=bt(u.length,a)),Xt("all",u,a);const[d,p]=Bt(h.shape,u),f=X(p),m=ce({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),g=Do(m,m.dtype,"all",t);let y;if(i){const b=yt(d,l);y=ce({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=ce({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(h),y}const mK={kernelName:eh,backendName:"webgl",kernelFunc:fK};function gK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=Re(o,r.shape);let u=l;const c=dt(u,a);let h=r;c!=null&&(h=on({inputs:{x:r},backend:t,attrs:{perm:c}}),u=bt(u.length,a)),Xt("any",u,a);const[d,p]=Bt(h.shape,u),f=X(p),m=ce({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),g=Do(m,m.dtype,"any",t);let y;if(i){const b=yt(d,l);y=ce({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=ce({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(h),y}const yK={kernelName:th,backendName:"webgl",kernelFunc:gK};class bK{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class xK{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Xe(l),c=sn("coords",l);let h,d;if(i===1){d=l+1;const F=Xe(d);h=`
        ${F} sourceLocR = ${F}(${c.join()}, 0);
        ++${c[l-1]};
        ${F} sourceLocG = ${F}(${c.join()}, 0);
        ++${c[l-2]};
        ${F} sourceLocA = ${F}(${c.join()}, 0);
        --${c[l-1]};
        ${F} sourceLocB = ${F}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(F=>"int "+F),g=sn("sourceLocR",d-1).concat("inIdx.r"),y=sn("sourceLocG",d-1).concat("inIdx.g"),b=sn("sourceLocB",d-1).concat("inIdx.b"),v=sn("sourceLocA",d-1).concat("inIdx.a"),x=s==="max"?"greaterThan":"lessThan",S=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()})));`,k=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,D=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${D}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function wN(n,e,t,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const i=jd(o),a={windowSize:i,inSize:o,batchSize:r,outSize:Math.ceil(o/i)},l=new bK(a,t,s==null),u=[e];s!=null&&u.push(s);const c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=wN(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function vN(n,e,t,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],i=jd(o),a=new xK(r,i,t,s==null),l=s==null?[e]:[e,s],u=n.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=vN(n,e,t,u);return n.disposeIntermediateTensorInfo(u),c}return u}function IN(n,e,t,s){const r=[t];if(Xt("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!H().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked;let l=e;a&&(l=n.unpackTensor(e),o.push(l));const[u,c]=Bt(l.shape,r),h=X(c),d=ce({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});o.push(d);const p=wN(n,d,s);o.push(p);const f=ce({inputs:{x:p},backend:n,attrs:{shape:u}});return o.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return vN(n,e,s)}function wK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=Re(o,r.shape);const a=dt(i,r.shape.length);let l=r;const u=[];a!=null&&(l=on({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=bt(i.length,l.shape.length)),Xt("argMax",[i[0]],l.shape.length);const c=IN(t,l,i[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const vK={kernelName:sl,backendName:"webgl",kernelFunc:wK};function IK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=Re(o,r.shape);const a=dt(i,r.shape.length);let l=r;const u=[];a!=null&&(l=on({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),i=bt(i.length,l.shape.length)),Xt("argMin",[i[0]],l.shape.length);const c=IN(t,l,i[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const $K={kernelName:rl,backendName:"webgl",kernelFunc:IK};const SK=Jn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,NK=Be({opSnippet:SK}),CK={kernelName:si,backendName:"webgl",kernelFunc:NK};const kK=Jn+"return log(x + sqrt(x * x + 1.0));",TK=Be({opSnippet:kK}),EK={kernelName:ri,backendName:"webgl",kernelFunc:TK};const AK=Jn+`
  return atan(x);
`,RK=Be({opSnippet:AK}),DK={kernelName:oi,backendName:"webgl",kernelFunc:RK};const FK=Mb+`
  return atan(a, b);
`,_K=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ro+`
  return result;
`,OK=Jt({opSnippet:FK,packedOpSnippet:_K}),LK={kernelName:ai,backendName:"webgl",kernelFunc:OK};const PK=Jn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,zK=Be({opSnippet:PK}),BK={kernelName:ii,backendName:"webgl",kernelFunc:zK};class Qa{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");const S=Math.floor(i/4)*4,k=i%4,D=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${D}
          }

          int xC = xCCorner + ${S};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${D}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${D}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${D}
          }
        }
        setOutput(${x});
      }
    `}}class Wb{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const v=t==="avg";let x="0.0";if(v||(x="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const D=Math.floor(i/4)*4,F=i%4,A=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${D}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${D};
            if (${F===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${F===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${F===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${A}
            }
          }
        }
        setOutput(${k});
      }
    `}}function MK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;ha(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;C(Kt(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Xn(r.shape,o,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&_e(c.inShape,c.outShape))return Tn({inputs:{x:r},backend:t});const h=new Qa(c,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const VK={kernelName:ol,backendName:"webgl",kernelFunc:MK};function WK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=s,c=[1,1,1],h=Zs(r.shape,o,i,c,a,l,u),d=new Wb(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const UK={kernelName:il,backendName:"webgl",kernelFunc:WK};class GK{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class HK{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,m=d-1-e.padInfo.top,g=p-1-e.padInfo.left,y=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function jK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Zs(i.shape,a,l,h,u,c),p=new HK(d);return t.runWebGLProgram(p,[r],i.dtype)}const qK={kernelName:sh,backendName:"webgl",kernelFunc:jK};function KK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o;ha([r,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Xn(i.shape,a,l,1,u),h=new GK(c);return t.runWebGLProgram(h,[r],i.dtype)}const XK={kernelName:nh,backendName:"webgl",kernelFunc:KK};function YK(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;return Kc({a:r,b:o,transposeA:i,transposeB:a,backend:t})}const JK={kernelName:al,backendName:"webgl",kernelFunc:YK};class ZK{constructor(e,t,s,r,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Ne(e,t),Ne(e,s);let a="0.0";r!=null&&(Ne(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";o!=null&&(Ne(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class QK{constructor(e,t,s,r,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ne(e,t),Ne(e,s);let a="vec4(0.0)";r!=null&&(Ne(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(Ne(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const eX=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:o,offset:i,scale:a}=n;C(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[s,r,o];let c=null;i!=null&&(c=i.shape,u.push(i));let h=null;a!=null&&(h=a.shape,u.push(a));const d=H().getBool("WEBGL_PACK_NORMALIZATION")?new QK(s.shape,r.shape,o.shape,c,h,l):new ZK(s.shape,r.shape,o.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},tX={kernelName:wl,backendName:"webgl",kernelFunc:eX};class nX{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Xe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=sX(this.rank);let r;const o=e.map((i,a)=>`sourceLoc.${Ff[a]} = start[${a}] + coords.${Ff[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Ff=["x","y","z","w","u","v"];function sX(n){if(n===1)return"sourceLoc";if(n<=6)return Ff.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class rX{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Xe(this.rank),s=sn("coords",this.rank),r=sn("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}function oX(n,e,t,s){const r=s.texData.get(n.dataId),o=s.makeTensorInfo(t,n.dtype),i=s.texData.get(o.dataId);Object.assign(i,r),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=yg(e,we(n.shape));r.slice&&(a+=r.slice.flatOffset),i.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,l+1),o}function ba(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:i}=s,[a,l]=Hd(r,o,i);if(fg(r,a,l),X(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),d=Yq(h.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const{isPacked:u}=t.texData.get(r.dataId),c=gg(r.shape,a,l);if(u||!c){const h=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rX(l):new nX(l),d=[a];return t.runWebGLProgram(h,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),oX(r,a,l,t)}const iX={kernelName:Xl,backendName:"webgl",kernelFunc:ba};const aX=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:i}=s;C(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((b,v)=>b*v),l=Su(r.shape,o,a),u=Nu(l.length,o.length),c=Cu(r.shape,o,a),h=$g(i,o.length),d=Sg(c,i,o.length),p=[],f=ce({inputs:{x:r},backend:t,attrs:{shape:l}}),m=on({inputs:{x:f},backend:t,attrs:{perm:u}}),g=ce({inputs:{x:m},backend:t,attrs:{shape:c}}),y=ba({inputs:{x:g},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},lX={kernelName:ll,backendName:"webgl",kernelFunc:aX};function uX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i}=s,a=t.readSync(r.dataId),l=t.readSync(o.dataId),u=aN(a,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}const cX={kernelName:rh,backendName:"webgl",kernelFunc:uX};const hX=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,dX=`
  return float(int(a.r) & int(b.r));
`;function pX(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=H().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=H().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||i===1){const l=t.texData.get(s.dataId).values,u=t.texData.get(r.dataId).values,[c,h]=wq(s.shape,r.shape,l,u,s.dtype),d=t.makeTensorInfo(h,s.dtype),p=t.texData.get(d.dataId);return p.values=c,d}let a;return o?a=new ga(hX,s.shape,r.shape,!1):a=new yo(dX,s.shape,r.shape),t.runWebGLProgram(a,[s,r],s.dtype)}const fX={kernelName:ul,backendName:"webgl",kernelFunc:pX};function mX(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.readSync(s.dataId),i=t.readSync(r.dataId),a=Ne(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const gX={kernelName:oh,backendName:"webgl",kernelFunc:mX};const yX="return float(a != b);",$N=Jt({opSnippet:yX,cpuKernelImpl:Vq,dtype:"bool"}),bX={kernelName:Pl,backendName:"webgl",kernelFunc:$N};function Vu(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Tn({inputs:{x:r.complexTensorInfos.real},backend:t})}const xX={kernelName:Bh,backendName:"webgl",kernelFunc:Vu};const wX="return float(int(x));";function vX(n,e){const t=new Is(n.shape,wX),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function _f(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Tn({inputs:{x:r},backend:t});const i=mt(r.shape),a=_f({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Or({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const i=Vu({inputs:{input:r},backend:t}),a=_f({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(i),a}if(!Bf(r.dtype,o)){const i=Tn({inputs:{x:r},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId).values,[a,l,u]=vq(i,r.shape,r.dtype,o);return t.makeTensorInfo(a,l,u)}if(o==="int32")return vX(r,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",Ot("bool",1)),l=$N({inputs:{a:r,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const IX={kernelName:li,backendName:"webgl",kernelFunc:_f};const v0="return ceil(x);",$X=Be({opSnippet:v0,packedOpSnippet:v0,cpuKernelImpl:Iq}),SX={kernelName:ui,backendName:"webgl",kernelFunc:$X};class NX{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class CX{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function kX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:i}=s;let a;H().getBool("WEBGL_PACK_CLIP")?a=new CX(r.shape):a=new NX(r.shape);const l=[[o],[i]];return t.runWebGLProgram(a,[r],r.dtype,l)}const TX={kernelName:ci,backendName:"webgl",kernelFunc:kX};class EX{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function I0(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function AX(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),o=new EX(s.shape),i=[I0(s,r.complexTensorInfos.real),I0(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}const RX={kernelName:cl,backendName:"webgl",kernelFunc:AX};class DX{constructor(e){this.outputShape=[],this.outputShape=Ns(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const a=t[i-1];s.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const r=t.length,o=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class FX{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ns(e,t);const s=this.outputShape,r=s.length,o=Xe(r),i=sn("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const u=a[t],c=a.slice(-2),h=a.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];d+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${sc(a,u,g)}),
            vec2(${sc(c,u,g)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${sc(a,u,f)}),
          vec2(${sc(c,u,f)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function sc(n,e,t){const s=n.indexOf(e);return n.map((o,i)=>i===s?`${o} - ${t}`:o).join()}function wp(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Tn({inputs:{x:r.complexTensorInfos.imag},backend:t})}const _X={kernelName:Nh,backendName:"webgl",kernelFunc:wp};function Fa(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(b=>Vu({inputs:{input:b},backend:t})),f=n.map(b=>wp({inputs:{input:b},backend:t})),m=Fa(p,e,t),g=Fa(f,e,t),y=Or({inputs:{real:m,imag:g},backend:t});return p.forEach(b=>t.disposeIntermediateTensorInfo(b)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const p=n.map(x=>{const k=[-1,X(x.shape.slice(e))];return ce({inputs:{x},backend:t,attrs:{shape:k}})}),f=p.map(x=>({vals:t.readSync(x.dataId),shape:x.shape})),m=Ns(p.map(x=>x.shape),1),g=p[0].shape[0]===1,y=$q(f,m,s,g),b=Ns(n.map(x=>x.shape),e),v=t.makeTensorInfo(b,s,y);return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),v}const o=n.filter(p=>X(p.shape)>0),i=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const p=i?new Is(n[0].shape,ir):new cr(n[0].shape,ir);return t.runWebGLProgram(p,n,s)}const a=H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const p=[];for(let m=0;m<o.length;m+=a){const g=o.slice(m,m+a);p.push(Fa(g,e,t))}const f=Fa(p,e,t);for(const m of p)t.disposeIntermediateTensorInfo(m);return f}if(i){const p=new FX(o.map(f=>f.shape),e);return t.runWebGLProgram(p,o,s)}const{tensors2D:l,outShape:u}=OX(o,e,t),c=new DX(l.map(p=>p.shape)),h=t.runWebGLProgram(c,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=ce({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),d}function OX(n,e,t){const s=Ns(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>ce({inputs:{x:o},attrs:{shape:[-1,X(o.shape.slice(e))]},backend:t})),outShape:s}}function SN(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Re(r,e[0].shape)[0],i=e.map(u=>u.shape);wg(i,o);const a=Ns(e.map(u=>u.shape),o);if(X(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>X(u.shape)>0);return l.length===1?Tn({inputs:{x:l[0]},backend:t}):Fa(l,o,t)}const LX={kernelName:hl,backendName:"webgl",kernelFunc:SN};class NN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,v=g?3:1;let x="",S="";s&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`
          float activation(float x) {
            ${s}
          }
        `,S="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${S}
        setOutput(result);
      }
    `}}class PX{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qt(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(d+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const b=i%2===0?Zc(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}class zX{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);const{dataFormat:s}=t,r=un(),o=s==="channelsLast",i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}function Xc(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function kN({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.shape,u=s.texData.get(n.dataId),c=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(o!=null){const x=Xc(o.shape,p);x!=null&&(o=ce({inputs:{x:o},backend:s,attrs:{shape:x}}),y.push(o))}if(r!=null){const x=Xc(r.shape,p);x!=null&&(r=ce({inputs:{x:r},backend:s,attrs:{shape:x}}),y.push(r))}if(!((h===1||d===1)&&c>xN)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&_e(u.shape.slice(-3),l.slice(-3))){const x=l[0]*l[1]*(l[2]+1),S={dataId:n.dataId,shape:[1,x,t.inChannels],dtype:n.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,C(Ja(u.shape,S.shape),()=>`packed reshape ${u.shape} to ${S.shape} isn't free`);const D=ce({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(D);const F=Kc({a:S,b:D,backend:s,transposeA:f,transposeB:m,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),A=s.texData.get(F.dataId);C(A.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,A.shape=t.outShape,g=Tn({inputs:{x:F},backend:s}),g.shape=t.outShape,y.push(F)}else{const x=t.outHeight*t.outWidth,S=ce({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,x,t.inChannels]:[t.batchSize,t.inChannels,x]}}),k=ce({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),D=Kc({a:p?S:k,b:p?k:S,transposeA:!p,transposeB:m,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i});g=ce({inputs:{x:D},backend:s,attrs:{shape:t.outShape}}),y.push(S),y.push(k),y.push(D)}for(const x of y)s.disposeIntermediateTensorInfo(x);return g}function TN({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",m=l*u*c,g=d*h,y=[t.batchSize,m,g],b=!0,v=!1,x=[];if(o!=null){const K=Xc(o.shape,f);K!=null&&(o=ce({inputs:{x:o},backend:s,attrs:{shape:K}}),x.push(o))}if(r!=null){const K=Xc(r.shape,f);K!=null&&(r=ce({inputs:{x:r},backend:s,attrs:{shape:K}}),x.push(r))}const S=ce({inputs:{x:e},backend:s,attrs:{shape:[1,m,X(e.shape)/m]}});x.push(S);const k=new zX(y,t),D=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],F=s.runWebGLProgram(k,[n],"float32",D),A=ce({inputs:{x:F},backend:s,attrs:{shape:y}});x.push(F),x.push(A);const R=r!=null,N=o!=null,z=a==="leakyrelu",V=a?Za(a,!0):null,j=new bN(f?A.shape:S.shape,f?S.shape:A.shape,f?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],b,v,R,V,N,z),G=f?[A,S]:[S,A];if(r&&G.push(r),N&&G.push(o),z){const K=s.makeTensorInfo([],"float32",Js(i,"float32"));G.push(K),x.push(K)}const q=s.runWebGLProgram(j,G,"float32"),J=ce({inputs:{x:q},backend:s,attrs:{shape:t.outShape}});x.push(q);for(const K of x)s.disposeIntermediateTensorInfo(K);return J}function BX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=Qs(l),d=zt(r.shape,o.shape,i,u,a,c,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=kN({x:r,filter:o,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&H().getBool("WEBGL_EXP_CONV")){const m=new CN(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(m,[r,o],"float32",g)}else if(H().getBool("WEBGL_CONV_IM2COL"))p=TN({x:r,filter:o,convInfo:d,backend:t});else{const m=new NN(d);p=t.runWebGLProgram(m,[r,o],"float32")}const f=ce({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const MX={kernelName:dl,backendName:"webgl",kernelFunc:BX};class VX{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class WX{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,u=i?1:2,c=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class UX{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class GX{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,u=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function HX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=Qs(l),d=zt(r.shape,c,i,1,a,u,!1,h),p=new VX(d);return t.runWebGLProgram(p,[r,o],"float32")}const jX={kernelName:ah,backendName:"webgl",kernelFunc:HX};class qX{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Qt(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function KX(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=Qs(u),d=zt(i,o.shape,a,1,l,c,!1,h);if(H().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new qX(d);return t.runWebGLProgram(f,[r,o],"float32",p)}else{const p=new WX(d);return t.runWebGLProgram(p,[r,o],"float32")}}const XX={kernelName:pl,backendName:"webgl",kernelFunc:KX};function YX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l}=s,u=Tr(r.shape,o.shape,i,l,a),c=new PX(u);return t.runWebGLProgram(c,[r,o],"float32")}const JX={kernelName:fl,backendName:"webgl",kernelFunc:YX};function ZX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:l}=s,u=Tr(r.shape,l,i,1,a),c=new UX(u);return t.runWebGLProgram(c,[r,o],"float32")}const QX={kernelName:lh,backendName:"webgl",kernelFunc:ZX};function e8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:l}=s,u=Tr(l,o.shape,a,1,i),c=new GX(u);return t.runWebGLProgram(c,[r,o],"float32")}const t8={kernelName:uh,backendName:"webgl",kernelFunc:e8};const n8=ya+`
  return cos(x);
`,s8=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ro}
  return result;
`,r8=Be({opSnippet:n8,packedOpSnippet:s8}),o8={kernelName:hi,backendName:"webgl",kernelFunc:r8};const i8=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,a8=Be({opSnippet:i8}),l8={kernelName:di,backendName:"webgl",kernelFunc:a8};class u8{constructor(e,t,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=e,[c]=t,[h,d]=s;this.outputShape=[c,h,d,u];const p=r==="bilinear"?1:0,[f,m]=[`${a-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[v,x,S]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${x};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const c8=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:u}=s,c=new u8(r.shape,o.shape,a,l,u);return t.runWebGLProgram(c,[r,o,i],"float32")},h8={kernelName:hh,backendName:"webgl",kernelFunc:c8};var el;(function(n){n.Prod="*",n.Sum="+"})(el||(el={}));class $0{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===el.Prod?"1.0":"0.0",a=s?i:`getX(${S0(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Xe(o)} coords = getOutputCoords();
        int end = ${N0(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${N0(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${S0(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function S0(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function N0(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function EN(n,e,t,s,r,o){const i=e.shape.length,a=dt([s],i);let l=e;a!=null&&(l=on({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=bt(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=Tn({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new $0(n,l.shape,!1,o),f=[[d]],m=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(m)}if(r){const d=new $0(n,l.shape,r,o),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Er(a),p=on({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}function d8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return EN(el.Prod,r,t,o,i,a)}const p8={kernelName:ch,backendName:"webgl",kernelFunc:d8};function f8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return EN(el.Sum,r,t,o,i,a)}const m8={kernelName:ml,backendName:"webgl",kernelFunc:f8};function g8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),u=t.readSync(o.dataId),c=aN(l,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(o),c=xq(l,u,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const y8={kernelName:dh,backendName:"webgl",kernelFunc:g8};class b8{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function x8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:i}=s,a=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],u=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=l*o,d=u*o,p=c/(o*o),f=i==="NHWC"?[a,h,d,p]:[a,p,h,d],m=new b8(f,o,i);return t.runWebGLProgram(m,[r],r.dtype)}const w8={kernelName:ph,backendName:"webgl",kernelFunc:x8};class AN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qt(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}class RN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qt(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<h;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){const b=y*2;if(p+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const v=a%2===0?Zc(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):v===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}function v8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=s;let c=l;c==null&&(c=[1,1]),C(Kt(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=zt(r.shape,o.shape,i,c,a,u,!0);let d;H().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new RN(h):d=new AN(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[r,o],"float32",p)}const I8={kernelName:gl,backendName:"webgl",kernelFunc:v8};class $8{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class S8{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function N8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=zt(r.shape,c,i,a,l,u,!0),d=new $8(h);return t.runWebGLProgram(d,[r,o],"float32")}const C8={kernelName:fh,backendName:"webgl",kernelFunc:N8};function k8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=zt(c,o.shape,i,a,l,u,!0),d=new S8(h);return t.runWebGLProgram(d,[r,o],"float32")}const T8={kernelName:mh,backendName:"webgl",kernelFunc:k8};class E8{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function A8(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=X(s.shape),i=ce({inputs:{x:s},backend:t,attrs:{shape:[o]}}),a=new E8(o),l=t.runWebGLProgram(a,[i],i.dtype),u=ce({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}const R8={kernelName:gh,backendName:"webgl",kernelFunc:A8};class D8{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function F8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:l}=s,u=iu(r.shape,o.shape,i,a,"NHWC",l);let c;const h=new D8(u);c=t.runWebGLProgram(h,[r,o],"float32");const d=ce({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),d}const _8={kernelName:yl,backendName:"webgl",kernelFunc:F8};function O8(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:l}=Dg(r,o.length);_g(i.length,l,o);const{path:u,steps:c}=Og(a,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=Fg(p,l[g]);let v;Lg(y)?v=o[g]:(v=on({inputs:{x:o[g]},backend:t,attrs:{perm:y}}),f.push(v));const x=v.shape.slice();for(let S=0;S<b.length;++S)x.splice(b[S],0,1);_e(v.shape,x)||(v=ce({inputs:{x:v},backend:t,attrs:{shape:x}}),f.push(v)),d===null?d=v:(d=Vb({inputs:{a:v,b:d},backend:t}),f.push(d))}m<h-1&&(u[m]>=0&&(d=xp({inputs:{x:d},backend:t,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const L8={kernelName:bh,backendName:"webgl",kernelFunc:O8};const P8="return (x >= 0.0) ? x : (exp(x) - 1.0);",z8=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,B8=Be({opSnippet:P8,packedOpSnippet:z8}),M8={kernelName:fi,backendName:"webgl",kernelFunc:B8};const V8="return (b >= 0.0) ? a : a * (b + 1.0);",W8=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,U8=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ga(W8,s.shape,r.shape):new yo(V8,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],s.dtype)},G8={kernelName:xh,backendName:"webgl",kernelFunc:U8};const H8=`
  return vec4(equal(a, b));
`,j8="return float(a == b);",q8=Jt({opSnippet:j8,packedOpSnippet:H8,dtype:"bool",cpuKernelImpl:Sq}),K8={kernelName:bl,backendName:"webgl",kernelFunc:q8};const X8=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Ng};
  float a1 = ${Cg};
  float a2 = ${kg};
  float a3 = ${Tg};
  float a4 = ${Eg};
  float a5 = ${Ag};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Y8=Be({opSnippet:X8}),J8={kernelName:mi,backendName:"webgl",kernelFunc:Y8};const Z8=ya+`
  return exp(x);
`,Q8=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DN=Be({opSnippet:Z8,packedOpSnippet:Q8,cpuKernelImpl:Nq,dtype:"float32"}),e5={kernelName:gi,backendName:"webgl",kernelFunc:DN};function Of(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=r;return r<0&&(C(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),a.splice(l,0,1),ce({inputs:{x:o},backend:s,attrs:{shape:a}})}const t5={kernelName:xl,backendName:"webgl",kernelFunc:Of};const C0="return exp(x) - 1.0;",n5=Be({opSnippet:C0,packedOpSnippet:C0,cpuKernelImpl:Cq}),s5={kernelName:yi,backendName:"webgl",kernelFunc:n5};class k0{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function FN(n,e,t){const s=t.texData.get(n.dataId),r=X(n.shape),o=n.shape[n.shape.length-1],i=r/o,a=ce({inputs:{x:n},backend:t,attrs:{shape:[i,o]}}),l=a.shape,u=new k0("real",l,e),c=new k0("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=Or({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const m=ce({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),m}function r5(n){const{inputs:e,backend:t}=n,{input:s}=e;return FN(s,!1,t)}const o5={kernelName:wh,backendName:"webgl",kernelFunc:r5};class i5{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function Wu(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||xo(r),o==="string"){const i=pt(o,X(s));return i.fill(r),e.makeTensorInfo(s,o,i)}else{const i=new i5(s,r),a=[[r]];return e.runWebGLProgram(i,[],o,a)}}const a5={kernelName:vh,backendName:"webgl",kernelFunc:Wu};class l5{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const u5={kernelName:Ih,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new l5(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const T0="return floor(x);",c5=Be({opSnippet:T0,packedOpSnippet:T0,cpuKernelImpl:kq}),h5={kernelName:bi,backendName:"webgl",kernelFunc:c5};const d5=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,p5=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,f5=Jt({opSnippet:d5,packedOpSnippet:p5,dtype:"int32"}),m5={kernelName:xi,backendName:"webgl",kernelFunc:f5};class g5{constructor(e){this.variableNames=["A"];const t=un(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class y5{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=un(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const b5={kernelName:Cc,backendName:"webgl",kernelFunc:x5};let _o,Pp=H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function x5(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,o];if(a||i){const m=H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(_o==null||m!==Pp)&&(Pp=m,_o=document.createElement("canvas").getContext("2d",{willReadFrequently:Pp})),_o.canvas.width=l,_o.canvas.height=u,_o.drawImage(r,0,0,l,u),r=_o.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=Pn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const p=H().getBool("WEBGL_PACK")?new y5(h):new g5(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}function w5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=Qs(c),g=zt(r.shape,o.shape,l,h,u,d,!1,m);let y;const b=[],v=i!=null,x=a!=null,S=p==="leakyrelu",k=()=>{const F=[r,o],A=(R,N)=>{if(N==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){const z=ce({inputs:{x:R},backend:t,attrs:{shape:[R.shape[0],1,1]}});return b.push(z),z}return R};if(v&&F.push(A(i,c)),x&&F.push(A(a,c)),S){const R=t.makeTensorInfo([],"float32",Js(f,"float32"));F.push(R),b.push(R)}return F};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=kN({x:r,filter:o,convInfo:g,backend:t,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&H().getBool("WEBGL_EXP_CONV")){const F=p?Za(p,!0):null,A=new CN(g,v,F,x,S),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=k();y=t.runWebGLProgram(A,N,"float32",R)}else if(H().getBool("WEBGL_CONV_IM2COL"))y=TN({x:r,filter:o,convInfo:g,backend:t,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const F=p?Za(p,!1):null,A=new NN(g,v,F,x,S),R=k();y=t.runWebGLProgram(A,R,"float32")}const D=ce({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return b.push(y),b.forEach(F=>t.disposeIntermediateTensorInfo(F)),D}const v5={kernelName:Pa,backendName:"webgl",kernelFunc:w5};function I5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let m=c;m==null&&(m=[1,1]),C(Kt(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=zt(r.shape,o.shape,l,m,u,h,!0),y=H().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?Za(d,y):null,v=[r,o],x=i!=null,S=a!=null,k=d==="leakyrelu";if(x&&v.push(i),S&&v.push(a),k){const R=t.makeTensorInfo([],"float32",Js(p,"float32"));v.push(R),f.push(R)}let D;y?D=new RN(g,x,b,S,k):D=new AN(g,x,b,S,k);const F=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=t.runWebGLProgram(D,v,"float32",F);return f.forEach(R=>t.disposeIntermediateTensorInfo(R)),A}const $5={kernelName:za,backendName:"webgl",kernelFunc:I5};class S5{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=Xe(s.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function N5(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,i=o[o.length-1],a=X(s.shape),[l,u,c,h]=Gd(s,r),d=ce({inputs:{x:r},backend:t,attrs:{shape:[u,i]}}),p=ce({inputs:{x:s},backend:t,attrs:{shape:[X(s.shape)/c,c]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=t.readSync(r.dataId),b=t.bufferSync(s),v=Tq(y,b,s.dtype,u,i,c,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,v.values)}const f=new S5(i,h,[u,c],s.shape),m=t.runWebGLProgram(f,[p,d],p.dtype),g=ce({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const C5={kernelName:$h,backendName:"webgl",kernelFunc:N5};class k5{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Xe(this.rank),r=T5(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function T5(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function _N(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:i,batchDims:a}=s,l=Re(i,r.shape)[0];if(H().get("DEBUG")){const b=t.readSync(o.dataId),v=r.shape[l];for(let x=0;x<b.length;++x){const S=b[x];C(S<=v-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${v-1}]`)}}const u=zg(r,o,l,a),c=X(o.shape),h=[],d=ce({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=ce({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const b=t.bufferSync(p),v=t.bufferSync(d),x=Eq(v,b,f);return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(u.outputShape,x.dtype,x.values)}const m=new k5(d.shape,f),g=t.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=ce({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const E5={kernelName:vl,backendName:"webgl",kernelFunc:_N};const A5="return float(a > b);",R5=`
  return vec4(greaterThan(a, b));
`,D5=Jt({opSnippet:A5,packedOpSnippet:R5,cpuKernelImpl:Aq,dtype:"bool"}),F5={kernelName:Il,backendName:"webgl",kernelFunc:D5};const _5="return float(a >= b);",O5=`
  return vec4(greaterThanEqual(a, b));
`,L5=Jt({opSnippet:_5,packedOpSnippet:O5,dtype:"bool",cpuKernelImpl:Rq}),P5={kernelName:wi,backendName:"webgl",kernelFunc:L5};function z5(n){const{inputs:e,backend:t}=n,{input:s}=e;return FN(s,!0,t)}const B5={kernelName:Sh,backendName:"webgl",kernelFunc:z5};const M5="return float(!isnan(x) && !isinf(x));",V5=Be({opSnippet:M5,dtype:"bool"}),W5={kernelName:Ii,backendName:"webgl",kernelFunc:V5};const U5="return float(isinf(x));",G5=Be({opSnippet:U5,dtype:"bool"}),H5={kernelName:$i,backendName:"webgl",kernelFunc:G5};const j5="return float(isnan(x));",q5=Be({opSnippet:j5,dtype:"bool"}),K5={kernelName:Si,backendName:"webgl",kernelFunc:q5};const X5="return float(a < b);",Y5=`
  return vec4(lessThan(a, b));
`,J5=Jt({opSnippet:X5,packedOpSnippet:Y5,cpuKernelImpl:Dq,dtype:"bool"}),Z5={kernelName:Sl,backendName:"webgl",kernelFunc:J5};const Q5="return float(a <= b);",eY=`
  return vec4(lessThanEqual(a, b));
`,tY=Jt({opSnippet:Q5,packedOpSnippet:eY,cpuKernelImpl:Fq,dtype:"bool"}),nY={kernelName:Nl,backendName:"webgl",kernelFunc:tY};function sY(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,i=_q(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const rY={kernelName:Ch,backendName:"webgl",kernelFunc:sY};const oY=ya+`
  return x < 0.0 ? 0./0. : log(x);
`,iY=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,aY=Be({opSnippet:oY,packedOpSnippet:iY,cpuKernelImpl:Oq}),lY={kernelName:Ni,backendName:"webgl",kernelFunc:aY};const uY=ya+`
  return log(1.0 + x);
`,cY=Be({opSnippet:uY}),hY={kernelName:Ci,backendName:"webgl",kernelFunc:cY};const dY="return float(a >= 1.0 && b >= 1.0);",pY=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,fY=Jt({opSnippet:dY,packedOpSnippet:pY,dtype:"bool"}),mY={kernelName:Cl,backendName:"webgl",kernelFunc:fY};const gY="return float(!(x >= 1.0));",yY=Be({opSnippet:gY}),bY={kernelName:kl,backendName:"webgl",kernelFunc:yY};const xY="return float(a >= 1.0 || b >= 1.0);",wY=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,vY=Jt({opSnippet:xY,packedOpSnippet:wY,dtype:"bool"}),IY={kernelName:Tl,backendName:"webgl",kernelFunc:vY};class $Y{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class SY{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const NY=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=s,u=H().getBool("WEBGL_PACK_NORMALIZATION")?new SY(r.shape,o,i,a,l):new $Y(r.shape,o,i,a,l);return t.runWebGLProgram(u,[r],r.dtype)},CY={kernelName:El,backendName:"webgl",kernelFunc:NY};class kY{constructor(e,t,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const TY=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new kY(r.shape,a,l,u,c);return t.runWebGLProgram(h,[r,o,i],r.dtype)},EY={kernelName:kh,backendName:"webgl",kernelFunc:TY};function AY(n,e,t,s){const r=X(e),i=X(n.shape)/r,a=ce({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),l=Do(a,n.dtype,"max",s),u=ce({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}function ON(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=r.shape.length,l=Re(o,r.shape);let u=l;const c=dt(u,a),h=c!=null,d=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const v=t.texData.get(p.dataId).values,x=new Array(a);for(let D=0;D<x.length;D++)x[D]=r.shape[c[D]];const S=Bb(v,r.shape,r.dtype,c,x);p=t.makeTensorInfo(x,r.dtype);const k=t.texData.get(p.dataId);k.values=S}else p=bp(r,c,t);u=bt(u.length,a)}Xt("max",u,a);const[f,m]=Bt(p.shape,u);let g=f;i&&(g=yt(f,l));let y;if(d){const v=t.texData.get(p.dataId).values,x=Lq(v,X(m),g,r.dtype);y=t.makeTensorInfo(g,r.dtype);const S=t.texData.get(y.dataId);S.values=x}else y=AY(p,m,g,t);return h&&t.disposeIntermediateTensorInfo(p),y}const RY={kernelName:Al,backendName:"webgl",kernelFunc:ON};const DY=Mb+`
  return max(a, b);
`,FY=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ro+`
  return result;
`,_Y=Jt({opSnippet:DY,packedOpSnippet:FY,cpuKernelImpl:Pq}),OY={kernelName:ki,backendName:"webgl",kernelFunc:_Y};function LY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;ha(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s,u=1;C(Kt(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Xn(r.shape,o,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&_e(c.inShape,c.outShape))return Tn({inputs:{x:r},backend:t});const h=new Qa(c,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const PY={kernelName:Rl,backendName:"webgl",kernelFunc:LY};function zY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=Zs(r.shape,o,i,c,a,u,l),d=new Wb(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const BY={kernelName:Dl,backendName:"webgl",kernelFunc:zY};class MY{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,l=i-1-e.padInfo.left,u=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class VY{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=u-1-e.padInfo.top,p=c-1-e.padInfo.left,f=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function WY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Zs(i.shape,a,l,h,u,c),p=new Wb(d,"max",!0),f=t.runWebGLProgram(p,[i],i.dtype),m=new VY(d),g=t.runWebGLProgram(m,[r,f],i.dtype);return t.disposeIntermediateTensorInfo(f),g}const UY={kernelName:Eh,backendName:"webgl",kernelFunc:WY};function GY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:i}=e,a=o;ha([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=Xn(a.shape,l,u,1,c,h),p=!0,f=new Qa(d,"max",p),m=t.runWebGLProgram(f,[a],a.dtype),g=new MY(d),y=t.runWebGLProgram(g,[r,m],a.dtype);return t.disposeIntermediateTensorInfo(m),y}const HY={kernelName:Th,backendName:"webgl",kernelFunc:GY};function jY(n,e,t,s){let r=new Qa(t,"max",!1);const o=s.runWebGLProgram(r,[n],"float32");r=new Qa(t,"max",!0,!0,e);const i=s.runWebGLProgram(r,[n],"float32");return[o,i]}const qY={kernelName:Ah,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,l=t;C(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];C(Kt(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Xn(s.shape,r,o,u,i),[h,d]=jY(s,a,c,l);return[h,d]}};function KY(n,e,t,s){const r=X(e),i=X(n.shape)/r,a=ce({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),l=Do(a,"float32","mean",s),u=ce({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}const XY={kernelName:Fl,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:o}=e,i=t,a=s.shape.length,l=Re(o,s.shape);let u=l;const c=dt(u,a),h=c!=null,d=i.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const x=i.texData.get(f.dataId).values,S=new Array(a);for(let F=0;F<S.length;F++)S[F]=s.shape[c[F]];const k=Bb(x,s.shape,s.dtype,c,S);f=i.makeTensorInfo(S,s.dtype);const D=i.texData.get(f.dataId);D.values=k}else f=bp(s,c,i);p.push(f),u=bt(u.length,a)}Xt("sum",u,a);const[m,g]=Bt(f.shape,u);let y=m;r&&(y=yt(m,l));const b=KY(f,g,y,i);for(const v of p)i.disposeIntermediateTensorInfo(v);return b}};function YY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=Re(o,r.shape);let u=l;const c=dt(u,a);let h=r;c!=null&&(h=on({inputs:{x:r},backend:t,attrs:{perm:c}}),u=bt(u.length,r.shape.length)),Xt("min",u,a);const[d,p]=Bt(h.shape,u),f=X(p),m=ce({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),g=Do(m,m.dtype,"min",t);let y;if(i){const b=yt(d,l);y=ce({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=ce({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(h),y}const JY={kernelName:_l,backendName:"webgl",kernelFunc:YY};const ZY=Mb+`
  return min(a, b);
`,QY=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ro+`
  return result;
`,e7=Jt({opSnippet:ZY,packedOpSnippet:QY,cpuKernelImpl:zq}),t7={kernelName:Ti,backendName:"webgl",kernelFunc:e7};class n7{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,o=Xe(r),i=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class s7{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);const r=e.length,o=Xe(r),i=t.map(f=>f[0]).join(","),a=t.map((f,m)=>f[0]+e[m]).join(","),l=sn("rc",r),u=sn("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}const r7=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:o}=t,i=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new s7(s.shape,r,o):new n7(s.shape,r,o);return e.runWebGLProgram(i,[s],s.dtype)},o7={kernelName:Ol,backendName:"webgl",kernelFunc:r7};const i7=`if (b == 0.0) return NAN;
  return mod(a, b);`,a7=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ro+`
  return result;
`,l7=Jt({opSnippet:i7,packedOpSnippet:a7}),u7={kernelName:Ei,backendName:"webgl",kernelFunc:l7};class c7{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const h7=`
if (a == b) {
  return 1.0;
};
return a / b;`,d7=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,LN=Jt({opSnippet:h7,packedOpSnippet:d7,checkOutOfBounds:!0}),p7={kernelName:pi,backendName:"webgl",kernelFunc:LN};const E0="return a - b;",PN=Jt({opSnippet:E0,packedOpSnippet:E0,supportsComplex:!0,cpuKernelImpl:o6}),f7={kernelName:Hi,backendName:"webgl",kernelFunc:PN};function zN(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,i=Re([o],r.shape),a=ON({inputs:{x:r},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),l=yt(a.shape,i),u=ce({inputs:{x:a},backend:t,attrs:{shape:l}}),c=PN({inputs:{a:r,b:u},backend:t}),h=DN({inputs:{x:c},backend:t}),d=xp({inputs:{x:h},backend:t,attrs:{axis:i,keepDims:!1}}),p=ce({inputs:{x:d},backend:t,attrs:{shape:l}}),f=LN({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const m7={kernelName:Ql,backendName:"webgl",kernelFunc:zN};function g7(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s,l=a?r:zN({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new c7(u,c,o),d=[[i]],p=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),p}const y7={kernelName:Rh,backendName:"webgl",kernelFunc:g7};const b7=Jn+`
  return -x;
`,x7=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function w7(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId),[i,a]=Mq(o.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}let r;return H().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new cr(s.shape,x7):r=new Is(s.shape,b7),t.runWebGLProgram(r,[s],s.dtype)}const v7={kernelName:Ll,backendName:"webgl",kernelFunc:w7};const I7=Md;function $7(n){Fn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=s,u=t.readSync(r.dataId),c=t.readSync(o.dataId),{selectedIndices:h}=I7(u,c,i,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const S7={kernelName:Dh,backendName:"webgl",kernelFunc:$7};const N7=Vd;function C7(n){Fn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s,c=t.readSync(r.dataId),h=t.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=N7(c,h,i,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const k7={kernelName:Fh,backendName:"webgl",kernelFunc:C7};const T7=Wd;function E7(n){Fn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=t.readSync(r.dataId),h=t.readSync(o.dataId),d=i,p=a,f=l,m=u,{selectedIndices:g,selectedScores:y}=T7(c,h,d,p,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const A7={kernelName:_h,backendName:"webgl",kernelFunc:E7};class R7{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const D7=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:l}=s,u=X(r.shape),c=new R7(u,i,a,l),h=ce({inputs:{x:r},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(c,[h],o);t.disposeIntermediateTensorInfo(h);const p=[...r.shape,i],f=ce({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},F7={kernelName:Bl,backendName:"webgl",kernelFunc:D7};function Yc(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Vu({inputs:{input:s},backend:t}),o=Yc({inputs:{x:r},backend:t}),i=wp({inputs:{input:s},backend:t}),a=Yc({inputs:{x:i},backend:t}),l=Or({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return Wu({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const _7={kernelName:su,backendName:"webgl",kernelFunc:Yc};function BN(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Vu({inputs:{input:s},backend:t}),o=BN({inputs:{x:r},backend:t}),i=wp({inputs:{input:s},backend:t}),a=Yc({inputs:{x:i},backend:t}),l=Or({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}else return Wu({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const O7={kernelName:zl,backendName:"webgl",kernelFunc:BN};function L7(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Of({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{qt(o,c.shape,"All tensors passed to stack must have matching shapes"),C(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=Of({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=SN({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const P7={kernelName:Ml,backendName:"webgl",kernelFunc:L7};class z7{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,o=Xe(r),i=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class B7{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const r=e.length,o=Xe(r),i=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+e[g]).join(","),l=sn("rc",r),u=sn("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=r===1?2:4;m<g;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}const MN=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:i}=s;if(X(r.shape)===0){const u=o.map((c,h)=>c[0]+r.shape[h]+c[1]);return Wu({backend:t,attrs:{shape:u,value:i,dtype:r.dtype}})}const a=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new B7(r.shape,o,i):new z7(r.shape,o,i),l=[[i]];return t.runWebGLProgram(a,[r],r.dtype,l)},M7={kernelName:Vl,backendName:"webgl",kernelFunc:MN};const V7=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,W7=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ro+`
  return result;
`,U7=Jt({opSnippet:V7,packedOpSnippet:W7}),G7={kernelName:Ri,backendName:"webgl",kernelFunc:U7};function H7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,l=[],u=Re(o,r.shape);let c=u;const h=dt(c,a);let d=r;h!=null&&(d=on({inputs:{x:r},backend:t,attrs:{perm:h}}),c=bt(c.length,a),l.push(d)),Xt("prod",c,a);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=Wq(d.shape,d.dtype,f,c);p=t.makeTensorInfo(g,y,m)}else{const[f,m]=Bt(d.shape,c),g=X(m),y=ce({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),b=id(r.dtype),v=Do(y,b,"prod",t);p=ce({inputs:{x:v},backend:t,attrs:{shape:f}}),l.push(y),l.push(v)}if(i){l.push(p);const f=yt(p.shape,u);p=ce({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const j7={kernelName:Ul,backendName:"webgl",kernelFunc:H7};function q7(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=s,l=r.map(y=>t.readSync(y.dataId)),u=r.map(y=>y.shape),c=t.readSync(o.dataId),h=t.readSync(i.dataId),[d,p,f]=Uq(l,u,c,o.shape,o.dtype,h,i.shape,a),m=d.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(f,o.dtype,p);return m.concat([g])}const K7={kernelName:Oh,backendName:"webgl",kernelFunc:q7};function X7(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=Gq(i,s.shape,s.dtype,a,r.shape,l,o.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const Y7={kernelName:Lh,backendName:"webgl",kernelFunc:X7};function J7(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=t.readSync(r.dataId),c=t.readSync(o.dataId),h=t.readSync(i.dataId),d=a.map(g=>t.readSync(g.dataId)),p=a.map(g=>g.shape),[f,m]=Hq(u,r.shape,c,o.shape,o.dtype,h,i.shape,d,p,l);return t.makeTensorInfo(f,o.dtype,m)}const Z7={kernelName:Ph,backendName:"webgl",kernelFunc:J7};const VN=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:i}=t,a=jq(s,r,o,i);return e.makeTensorInfo([a.length],i,a)},Q7={kernelName:zh,backendName:"webgl",kernelFunc:VN};const eJ="return 1.0 / x;",tJ=Be({opSnippet:eJ}),nJ={kernelName:Di,backendName:"webgl",kernelFunc:tJ};const sJ=Jn+`
  return (x < 0.0) ? 0.0 : x;
`,rJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,oJ=Be({opSnippet:sJ,packedOpSnippet:rJ}),iJ={kernelName:Fi,backendName:"webgl",kernelFunc:oJ};const aJ=Jn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,lJ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uJ=Be({opSnippet:aJ,packedOpSnippet:lJ}),cJ={kernelName:_i,backendName:"webgl",kernelFunc:uJ};class hJ{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class dJ{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function pJ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[l,u]=a,c=H().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dJ(r.shape,l,u,o,i):new hJ(r.shape,l,u,o,i);return t.runWebGLProgram(c,[r],"float32")}const fJ={kernelName:jl,backendName:"webgl",kernelFunc:pJ};class mJ{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,i,a]=e,l=[s&&i>1?r-1:r,s&&a>1?o-1:o],u=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function gJ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,a=new mJ(o.shape,r.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const yJ={kernelName:Vh,backendName:"webgl",kernelFunc:gJ};class bJ{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;o?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class xJ{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=e;this.outputShape=[i,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;o?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function wJ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[l,u]=a,c=H().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xJ(r.shape,l,u,o,i):new bJ(r.shape,l,u,o,i);return t.runWebGLProgram(c,[r],r.dtype)}const vJ={kernelName:Hl,backendName:"webgl",kernelFunc:wJ};class IJ{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,i,a]=e,l=[s&&i>1?r-1:r,s&&a>1?o-1:o],u=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function $J(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,a=new IJ(o.shape,r.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const SJ={kernelName:Mh,backendName:"webgl",kernelFunc:$J};class NJ{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,l)=>r(l)).join(","),i=Xe(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}class CJ{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=sn("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Xe(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${o}){
            result.g = ${u(r.slice())};
          }
          if(${i}) {
            result.b = ${c(r.slice())};
            if(${o}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function u(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function c(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const m=e.map((b,v)=>p(v,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}function kJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,i=r.shape.length,a=Re(o,r.shape);if(i===0)return Tn({inputs:{x:r},backend:t});const l=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CJ(r.shape,a):new NJ(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const TJ={kernelName:ql,backendName:"webgl",kernelFunc:kJ};class EJ{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const AJ={kernelName:rd,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:i}=e,a=t,l=new EJ(s.shape,o),[u,c]=Ig(i,s.shape[1],s.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};const RJ=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,DJ=Be({opSnippet:RJ}),FJ={kernelName:Oi,backendName:"webgl",kernelFunc:DJ};const _J="return inversesqrt(x);",OJ=Be({opSnippet:_J,cpuKernelImpl:qq}),LJ={kernelName:Li,backendName:"webgl",kernelFunc:OJ};class Ub{constructor(e,t,s,r,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Xe(o.length),c=Xe(i.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}class PJ{constructor(e,t,s,r,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Xe(o.length),c=Xe(i.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}function zJ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Fr(o,r,i),d=[h/u,u];if(h===0)return t.makeTensorInfo(i,r.dtype);const p=ce({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),f=ce({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;H().getBool("WEBGL_PACK")?g=new PJ(l,a,p.shape.length,f.shape.length,c,d):g=new Ub(l,a,p.shape.length,f.shape.length,c,d);const y=t.runWebGLProgram(g,[f,p,m],f.dtype),b=ce({inputs:{x:y},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),b}const BJ={kernelName:Wh,backendName:"webgl",kernelFunc:zJ};class MJ{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=H().getNumber("WEBGL_VERSION")===2?o:i,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function VJ(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:i}=s,a=new MJ(r.shape[0],r.shape[1],o.shape[1],i),l=[[r.shape[1]]];return t.runWebGLProgram(a,[r,o],"int32",l)}const WJ={kernelName:Gh,backendName:"webgl",kernelFunc:VJ};class UJ{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);r=l.join(),o=u.join()}const i=Xe(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}function GJ(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,i=new UJ(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(i,[s,r,o],pn(r.dtype,o.dtype))}const HJ={kernelName:Kl,backendName:"webgl",kernelFunc:GJ};const jJ=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${qd};
  float scale = ${Kd};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,qJ=Be({opSnippet:jJ}),KJ={kernelName:Pi,backendName:"webgl",kernelFunc:qJ};const XJ=ya+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,YJ=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,JJ=Be({opSnippet:XJ,packedOpSnippet:YJ,cpuKernelImpl:Xq}),ZJ={kernelName:Vi,backendName:"webgl",kernelFunc:JJ};const QJ=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,eZ=Be({opSnippet:QJ}),tZ={kernelName:Mi,backendName:"webgl",kernelFunc:eZ};const nZ=ya+`
  return sin(x);
`,sZ=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ro}
  return result;
`,rZ=Be({opSnippet:nZ,packedOpSnippet:sZ}),oZ={kernelName:zi,backendName:"webgl",kernelFunc:rZ};const iZ=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,aZ=Be({opSnippet:iZ}),lZ={kernelName:Bi,backendName:"webgl",kernelFunc:aZ};const uZ=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,cZ=Be({opSnippet:uZ}),hZ={kernelName:Wi,backendName:"webgl",kernelFunc:cZ};const dZ=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:i}=s;C(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=MN({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=Su(c.shape,o,a,!1),d=Nu(h.length,o.length,!1),p=Cu(c.shape,o,a,!1),f=ce({inputs:{x:c},backend:t,attrs:{shape:h}}),m=on({inputs:{x:f},backend:t,attrs:{perm:d}}),g=ce({inputs:{x:m},backend:t,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},pZ={kernelName:Jl,backendName:"webgl",kernelFunc:dZ};function fZ(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[h,d,p,f,m]=Jq(a,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const mZ={kernelName:Hh,backendName:"webgl",kernelFunc:fZ};function gZ(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(o.dataId)),[u,c,h]=Zq(a,s.shape,s.dtype,i,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const yZ={kernelName:jh,backendName:"webgl",kernelFunc:gZ};function bZ(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=uN(i,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const xZ={kernelName:qh,backendName:"webgl",kernelFunc:bZ};function wZ(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=uN(i,s.shape,s.dtype,a,l);return t.makeTensorInfo(c,s.dtype,u)}const vZ={kernelName:Kh,backendName:"webgl",kernelFunc:wZ};function IZ(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Fr(o,r,a),p=!1;if(o.dtype==="string"){const y=t.bufferSync(r),b=t.bufferSync(o),v=Ws(t.readSync(i.dataId)[0]),x=Kq(y,b,a,d,c,u,l,h,v,p);return t.makeTensorInfo(a,x.dtype,x.values)}const f=new Ub(u,l,r.shape.length,o.shape.length,h,[d,1],p),m=t.runWebGLProgram(f,[o,r,i],o.dtype),g=ce({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),g}const $Z={kernelName:Xh,backendName:"webgl",kernelFunc:IZ};function SZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=Re(i,r.shape)[0],l=Pg(r,o,a),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=ba({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=d,f})}const NZ={kernelName:Zl,backendName:"webgl",kernelFunc:SZ};const A0="return sqrt(x);",CZ=Be({opSnippet:A0,packedOpSnippet:A0,cpuKernelImpl:Qq}),kZ={kernelName:Ui,backendName:"webgl",kernelFunc:CZ};const TZ="return x * x;",EZ=Be({opSnippet:TZ}),AZ={kernelName:Yh,backendName:"webgl",kernelFunc:EZ};const R0="return (a - b) * (a - b);",RZ=Jt({opSnippet:R0,packedOpSnippet:R0}),DZ={kernelName:Gi,backendName:"webgl",kernelFunc:RZ};function FZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=t.readSync(r.dataId),i=qs(o),a=e6(i,"string",s);return t.makeTensorInfo(r.shape,"string",a)}const _Z={kernelName:eu,backendName:"webgl",kernelFunc:FZ};function OZ({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Jn+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new Is(s.shape,r);return t.runWebGLProgram(o,[s],s.dtype)}const LZ={kernelName:Xi,backendName:"webgl",kernelFunc:OZ};class PZ{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=Xe(s.length),i=Xe(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((u,c)=>(l++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}function zZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=bg(r.shape,o,i,a,l,u,c,h,d);let S;if(m)S=ce({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){C(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const D=mg(b,v,x),F=ba({inputs:{x:r},backend:t,attrs:{begin:b,size:D}});S=ce({inputs:{x:F},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(F)}else if(t.shouldExecuteOnCPU([r])){const F=t.readSync(r.dataId),A=Ee(r.shape,r.dtype,F),R=t6(p,A,x,b);S=t.makeTensorInfo(f,r.dtype,R.values)}else{const F=new PZ(b,x,p);S=t.runWebGLProgram(F,[r],r.dtype)}const k=ce({inputs:{x:S},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(S),k}const BZ={kernelName:Jh,backendName:"webgl",kernelFunc:zZ};function MZ(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=t.readSync(c.dataId),p=t.readSync(h.dataId),[f,m]=n6(d,p,r,o,i,a,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",m)]}const VZ={kernelName:Zh,backendName:"webgl",kernelFunc:MZ};function WZ(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.readSync(o.dataId),l=t.readSync(i.dataId)[0],[u,c,h]=s6(a,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const UZ={kernelName:Qh,backendName:"webgl",kernelFunc:WZ};function GZ(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),a=r6(i,r);return t.makeTensorInfo(o.shape,"int32",a)}const HZ={kernelName:ed,backendName:"webgl",kernelFunc:GZ};const jZ="return tan(x);",qZ=Be({opSnippet:jZ}),KZ={kernelName:ji,backendName:"webgl",kernelFunc:qZ};const XZ=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,YZ=Be({opSnippet:XZ}),JZ={kernelName:qi,backendName:"webgl",kernelFunc:YZ};function ZZ(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Fr(i,o,r.shape),d=[h/u,u];if(h===0)return t.makeTensorInfo(r.shape,o.dtype);const p=ce({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),f=ce({inputs:{x:i},backend:t,attrs:{shape:[l,u]}}),m=ce({inputs:{x:r},backend:t,attrs:{shape:d}}),g=new Ub(l,a,p.shape.length,f.shape.length,c,d,!1,!0),y=t.runWebGLProgram(g,[f,p,m],m.dtype),b=ce({inputs:{x:y},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const QZ={kernelName:Uh,backendName:"webgl",kernelFunc:ZZ};class e9{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*t[i];this.outputShape=s,this.rank=s.length;const r=Xe(this.rank),o=t9(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function t9(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function WN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),u=r.dtype==="string"?l.map(d=>Ws(d)):l,c=Ee(r.shape,r.dtype,u),h=i6(c,o);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new e9(r.shape,o);return t.runWebGLProgram(i,[r],r.dtype)}const n9={kernelName:Ki,backendName:"webgl",kernelFunc:WN};class s9{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class r9{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function zr(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function D0(n){let e=1;for(;e<n;)e*=2;return e}function o9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:i}=s,a=H().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=H().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([r])||c<a||o>l){const R=t.readSync(r.dataId),[N,z]=a6(R,u,r.dtype,o,i);return[t.makeTensorInfo(N.shape,N.dtype,N.values),t.makeTensorInfo(z.shape,z.dtype,z.values)]}if(o===0)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[r,Wu({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(r):r,m=X(u)/c,g=ce({inputs:{x:p},attrs:{shape:[m,c]},backend:t});d&&zr(t,p);const y=D0(o),b=D0(c);let v=null;const x=()=>v===null?[g,g]:[g,v],S=(R,N,z)=>{const V=x(),j=new s9(z),q=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[R],[N]],J=v;v=t.runWebGLProgram(j,V,"int32",q),zr(t,J)};for(let R=1;R<y;R*=2){const N=R*2;for(let z=R;z>=1;z/=2)S(N,z,[m,b])}for(let R=b;R>y;R/=2){const N=x(),z=new r9([m,R/2]),j=[[c],[v===null?1:0],[y]],G=v;v=t.runWebGLProgram(z,N,"int32",j),zr(t,G);const q=y/2,J=q*2;for(let K=q;K>=1;K/=2)S(J,K,v.shape)}let k=v;v=ba({inputs:{x:v},backend:t,attrs:{begin:0,size:[m,o]}}),zr(t,k);let D=_N({inputs:{x:g,indices:v},backend:t,attrs:{axis:1,batchDims:1}});zr(t,g);const F=u.slice(0,-1);F.push(o),k=v,v=ce({inputs:{x:v},attrs:{shape:F},backend:t}),zr(t,k);const A=D;return D=ce({inputs:{x:D},attrs:{shape:F},backend:t}),zr(t,A),[D,v]}const i9={kernelName:td,backendName:"webgl",kernelFunc:o9};class a9{constructor(e,t,s,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function l9(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,m]=u??[h,d],g=[c,f,m,p],y=new a9(h,d,i,a,l,g);return t.runWebGLProgram(y,[r,o],"float32")}const u9={kernelName:nd,backendName:"webgl",kernelFunc:l9};function c9(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;ha(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=l6(i,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const h9={kernelName:sd,backendName:"webgl",kernelFunc:c9};function d9(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r,a=i.shape.length,l=r.shape[o],u=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(u[c++]=i.shape[m]);const h=[],d=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[o]=m;const g=ba({inputs:{x:i},backend:t,attrs:{begin:d,size:p}}),y=ce({inputs:{x:g},backend:t,attrs:{shape:u}});f[m]=y,h.push(g)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const p9={kernelName:tu,backendName:"webgl",kernelFunc:d9};class f9{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/s);this.outputShape=[r,a];const l="0.0",u="sumValue",c=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}function m9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:i}=s,a=r.shape.length,l=[];let u=0;const c=dt([u],a);let h=r;c!=null&&(h=on({inputs:{x:r},backend:t,attrs:{perm:c}}),l.push(h),u=bt(1,a)[0]);const d=gv(h.shape,u,i),p=X([h.shape[u]]),f=ce({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const m=id(r.dtype),g=(x,S,k,D,F)=>{const A=x.shape[0],R=x.shape[1],N=mv(R,F),z={windowSize:N,inSize:R,batchSize:A,numSegments:F},V=new f9(z,S),j=t.compileAndRun(V,[x,k],D);if(l.push(j),j.shape[1]===F)return j;const G=VN({backend:t,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),q=WN({inputs:{x:G},backend:t,attrs:{reps:[R/N]}});return l.push(G),l.push(q),g(j,S,q,D,F)},y=g(f,"unsortedSegmentSum",o,m,i),b=ce({inputs:{x:y},backend:t,attrs:{shape:d}});let v=b;if(c!=null){l.push(b);const x=Er(c);v=on({inputs:{x:v},backend:t,attrs:{perm:x}})}return l.forEach(x=>t.disposeIntermediateTensorInfo(x)),v}const g9={kernelName:nu,backendName:"webgl",kernelFunc:m9};const y9=[eK,nK,oK,lK,cK,pK,mK,yK,vK,$K,CK,EK,DK,LK,BK,VK,UK,qK,XK,JK,tX,lX,cX,fX,gX,IX,SX,TX,P6,RX,LX,MX,jX,XX,JX,QX,t8,o8,l8,h8,p8,m8,y8,w8,I8,C8,T8,R8,_8,L8,M8,G8,K8,J8,e5,t5,s5,o5,a5,u5,h5,m5,b5,v5,$5,C5,E5,F5,P5,L6,B5,_X,W5,H5,K5,B6,Z5,nY,rY,lY,hY,mY,bY,IY,CY,EY,RY,OY,PY,BY,UY,HY,qY,XY,JY,t7,o7,u7,y7,W6,v7,S7,k7,A7,bX,F7,O7,P7,M7,G7,V6,j7,K7,Y7,Z7,Q7,xX,p7,nJ,iJ,cJ,G6,fJ,yJ,vJ,SJ,TJ,AJ,FJ,LJ,BJ,WJ,HJ,KJ,ZJ,tZ,oZ,lZ,iX,m7,hZ,pZ,mZ,yZ,xZ,vZ,$Z,NZ,kZ,AZ,DZ,_Z,LZ,BZ,VZ,UZ,HZ,f7,J6,KZ,JZ,QZ,n9,i9,u9,Z6,h9,p9,g9,_7];for(const n of y9)od(n);const b9="4.22.0";const x9={"tfjs-core":j1,"tfjs-backend-cpu":Z$,"tfjs-backend-webgl":dN,"tfjs-data":n$,"tfjs-layers":ap,"tfjs-converter":MI,tfjs:b9},w9=Object.freeze(Object.defineProperty({__proto__:null,Abs:tl,Acos:ti,Acosh:ni,AdadeltaOptimizer:rg,AdagradOptimizer:og,AdamOptimizer:ig,AdamaxOptimizer:ag,Add:vo,AddN:nl,All:eh,Any:th,ArgMax:sl,ArgMin:rl,Asin:si,Asinh:ri,Atan:oi,Atan2:ai,Atanh:ii,AvgPool:ol,AvgPool3D:il,AvgPool3DGrad:sh,AvgPoolGrad:nh,BatchMatMul:al,BatchToSpaceND:ll,Bincount:rh,BitwiseAnd:ul,BroadcastArgs:oh,BroadcastTo:q0,Callback:_I,CallbackList:Ov,Cast:li,Ceil:ui,ClipByValue:ci,Complex:ih,ComplexAbs:cl,Concat:hl,Conv2D:dl,Conv2DBackpropFilter:ah,Conv2DBackpropInput:pl,Conv3D:fl,Conv3DBackpropFilterV2:lh,Conv3DBackpropInputV2:uh,Cos:hi,Cosh:di,CropAndResize:hh,Cumprod:ch,Cumsum:ml,CustomCallback:Pv,DataStorage:Lf,DenseBincount:dh,DepthToSpace:ph,DepthwiseConv2dNative:gl,DepthwiseConv2dNativeBackpropFilter:fh,DepthwiseConv2dNativeBackpropInput:mh,Diag:gh,Dilation2D:yl,Dilation2DBackpropFilter:Nc,Dilation2DBackpropInput:Sc,Draw:yh,get ENV(){return Vf},EarlyStopping:OI,Einsum:bh,Elu:fi,EluGrad:xh,Environment:H0,Equal:bl,Erf:mi,Exp:gi,ExpandDims:xl,Expm1:yi,FFT:wh,Fill:vh,FlipLeftRight:Ih,Floor:bi,FloorDiv:xi,FromPixels:Cc,FusedBatchNorm:wl,FusedConv2D:Pa,FusedDepthwiseConv2D:za,GPGPUContext:xc,GatherNd:$h,GatherV2:vl,GraphModel:mb,Greater:Il,GreaterEqual:wi,History:Lv,IFFT:Sh,Identity:vi,Imag:Nh,InputSpec:$t,IsFinite:Ii,IsInf:$i,IsNan:Si,KernelBackend:Jc,LRN:El,LRNGrad:kh,LayerVariable:Rv,LayersModel:Ms,LeakyRelu:$l,Less:Sl,LessEqual:Nl,LinSpace:Ch,Log:Ni,Log1p:Ci,LogSoftmax:K0,LogicalAnd:Cl,LogicalNot:kl,LogicalOr:Tl,LogicalXor:aC,LowerBound:lC,MathBackendCPU:Lu,MathBackendWebGL:Mu,MatrixBandPart:uC,Max:Al,MaxPool:Rl,MaxPool3D:Dl,MaxPool3DGrad:Eh,MaxPoolGrad:Th,MaxPoolWithArgmax:Ah,Maximum:ki,Mean:Fl,Min:_l,Minimum:Ti,MirrorPad:Ol,Mod:Ei,MomentumOptimizer:lg,Multinomial:Rh,Multiply:Ai,Neg:Ll,NonMaxSuppressionV3:Dh,NonMaxSuppressionV4:Fh,NonMaxSuppressionV5:_h,NotEqual:Pl,OP_SCOPE_SUFFIX:jf,OneHot:Bl,OnesLike:zl,Optimizer:sr,OptimizerConstructors:q1,Pack:Ml,PadV2:Vl,Pool:cC,Pow:Ri,Prelu:Wl,Prod:Ul,RMSPropOptimizer:ug,RNN:gs,RaggedGather:Oh,RaggedRange:Lh,RaggedTensorToTensor:Ph,Range:zh,get Rank(){return Wp},Real:Bh,RealDiv:pi,Reciprocal:Di,get Reduction(){return nn},Relu:Fi,Relu6:_i,Reshape:Gl,ResizeBilinear:jl,ResizeBilinearGrad:Vh,ResizeNearestNeighbor:Hl,ResizeNearestNeighborGrad:Mh,Reverse:ql,RotateWithOffset:rd,Round:Oi,Rsqrt:Li,SGDOptimizer:Ud,ScatterNd:Wh,SearchSorted:Gh,Select:Kl,Selu:Pi,Sequential:co,Sigmoid:Vi,Sign:Mi,Sin:zi,Sinh:Bi,Slice:Xl,Softmax:Ql,Softplus:Wi,SpaceToBatchND:Jl,SparseFillEmptyRows:Hh,SparseReshape:jh,SparseSegmentMean:qh,SparseSegmentSum:Kh,SparseToDense:Xh,SplitV:Zl,Sqrt:Ui,Square:Yh,SquaredDifference:Gi,StaticRegexReplace:eu,Step:Xi,StridedSlice:Jh,StringNGrams:Zh,StringSplit:Qh,StringToHashBucketFast:ed,Sub:Hi,Sum:Yl,SymbolicTensor:hs,Tan:ji,Tanh:qi,Tensor:ze,TensorBuffer:St,TensorScatterUpdate:Uh,Tile:Ki,TopK:td,Transform:nd,Transpose:Xr,Unique:sd,Unpack:tu,UnsortedSegmentSum:nu,UpperBound:hC,Variable:Va,ZerosLike:su,_FusedMatMul:La,abs:It,acos:em,acosh:tm,add:re,addN:Sw,all:ud,any:Ua,argMax:so,argMin:nm,asin:sm,asinh:rm,atan:om,atan2:im,atanh:am,avgPool:au,avgPool3d:um,backend:Kf,backend_util:bv,basicLSTMCell:Nw,batchNorm:Yi,batchNorm2d:cm,batchNorm3d:hm,batchNorm4d:dm,batchToSpaceND:lu,bincount:pm,bitwiseAnd:Cw,booleanMaskAsync:c1,broadcastArgs:kw,broadcastTo:Yr,broadcast_util:WT,browser:iF,buffer:Ee,callbacks:vz,cast:le,ceil:fm,clipByValue:mn,clone:Ss,complex:Gs,concat:gt,concat1d:mm,concat2d:gm,concat3d:ym,concat4d:bm,constraints:lL,conv1d:cd,conv2d:Hs,conv2dTranspose:hd,conv3d:wm,conv3dTranspose:vm,copyRegisteredKernels:mC,cos:uu,cosh:dd,cosineWindow:Od,cumprod:ja,cumsum:pd,customGrad:Rs,data:FM,denseBincount:Ec,deprecationWarn:jC,depthToSpace:Im,depthwiseConv2d:Ji,deregisterOp:Sz,device_util:MC,diag:Ew,dilation2d:$m,disableDeprecationWarnings:HC,dispose:Se,disposeVariables:qC,div:ge,divNoNan:Sm,dot:Nm,dropout:Qm,einsum:Wr,elu:Zi,enableDebugMode:GC,enableProdMode:UC,enclosingPowerOfTwo:eg,engine:ns,ensureShape:Aw,env:H,equal:Nn,erf:fd,euclideanNorm:km,exp:gn,expandDims:Wt,expm1:Tm,eye:md,fft:Iu,fill:Io,findBackend:QC,findBackendFactory:ek,floor:ea,floorDiv:ld,forceHalfFloat:pN,fused:x1,gather:ta,gatherND:f1,gather_util:aF,getBackend:cw,getGradient:Mp,getKernel:Ma,getKernelsForBackend:kc,gpgpu_util:gq,grad:N2,grads:C2,greater:ln,greaterEqual:er,ifft:Ko,imag:cu,image:Ln,inTopKAsync:m1,initializers:SL,input:Qv,io:dg,irfft:Ed,isFinite:Em,isInf:Am,isNaN:Rm,keep:kt,kernel_impls:gF,layers:J3,leakyRelu:hu,less:Go,lessEqual:Ar,linalg:sg,linspace:Fw,loadGraphModel:BI,loadGraphModelSync:XB,loadLayersModel:Jv,localResponseNormalization:Dm,log:Cn,log1p:du,logSigmoid:Fm,logSoftmax:yd,logSumExp:pu,logicalAnd:Kn,logicalNot:fu,logicalOr:bd,logicalXor:_m,losses:C1,lowerBound:Ow,matMul:Ae,math:JD,max:Mn,maxPool:mu,maxPool3d:Om,maxPoolWithArgmax:Lw,maximum:Fs,mean:ut,memory:Kp,meshgrid:Pw,metrics:fz,min:Uo,minimum:wr,mirrorPad:Lm,mod:Pm,model:Zv,models:mz,moments:gu,movingAverage:h1,mul:P,multiRNNCell:zw,multinomial:Bw,neg:tt,nextFrame:xg,norm:Qi,notEqual:io,oneHot:Ho,ones:hn,onesLike:kn,op:L,outerProduct:Mw,pad:tr,pad1d:Vw,pad2d:Ww,pad3d:Uw,pad4d:Gw,pool:zm,pow:As,prelu:bu,print:Qf,prod:Bm,profile:KC,raggedGather:Hw,raggedRange:jw,raggedTensorToTensor:qw,rand:Kw,randomGamma:Jw,randomNormal:wd,randomStandardNormal:Zw,randomUniform:Rr,randomUniformInt:Qw,range:ao,ready:JC,real:jo,reciprocal:Um,registerBackend:qf,registerCallbackConstructor:yP,registerGradient:X0,registerKernel:od,registerOp:$z,regularizers:xz,relu:fs,relu6:vd,removeBackend:ZC,reshape:B,reverse:Vn,reverse1d:e1,reverse2d:t1,reverse3d:n1,reverse4d:s1,rfft:$u,round:Id,rsqrt:$d,scalar:xe,scatterND:d1,scatter_util:AA,searchSorted:xd,selu:Sd,separableConv2d:Nd,sequential:gP,serialization:RD,setBackend:YC,setPlatform:tk,setWebGLContext:mS,setdiff1dAsync:r1,shared:J$,sigmoid:is,sign:Gm,signal:N1,sin:Cd,sinh:kd,slice:Le,slice1d:xu,slice2d:Td,slice3d:wu,slice4d:qo,slice_util:H1,softmax:vu,softplus:$o,spaceToBatchND:yu,sparse:k1,sparseToDense:p1,spectral:S1,split:dn,sqrt:Lt,square:Ke,squaredDifference:Ad,squeeze:Dr,stack:rn,step:So,stridedSlice:Hm,string:T1,sub:pe,sum:fe,sumOutType:id,tan:jm,tanh:xr,tensor:Sn,tensor1d:Ht,tensor2d:dr,tensor3d:qm,tensor4d:o1,tensor5d:i1,tensor6d:a1,tensorScatterUpdate:l1,tensor_util:OC,test_util:UE,tidy:U,tile:On,time:XC,topk:Xm,train:Mr,transpose:Oe,truncatedNormal:Dd,unique:Ym,unregisterGradient:fC,unregisterKernel:pC,unsortedSegmentSum:Fd,unstack:Wn,upcastType:pn,upperBound:u1,util:$C,valueAndGrad:k2,valueAndGrads:T2,variable:Jm,variableGrads:_w,version:x9,version_converter:MI,version_core:j1,version_cpu:Z$,version_layers:ap,version_webgl:dN,webgl:O6,webgl_util:Ij,where:_t,whereAsync:Zm,zeros:mt,zerosLike:Pe},Symbol.toStringTag,{value:"Module"}));var zp={},Sa={},F0;function v9(){if(F0)return Sa;F0=1,Sa.byteLength=a,Sa.toByteArray=u,Sa.fromByteArray=d;for(var n=[],e=[],t=typeof Uint8Array<"u"?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=0,o=s.length;r<o;++r)n[r]=s[r],e[s.charCodeAt(r)]=r;e[45]=62,e[95]=63;function i(p){var f=p.length;if(f%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var m=p.indexOf("=");m===-1&&(m=f);var g=m===f?0:4-m%4;return[m,g]}function a(p){var f=i(p),m=f[0],g=f[1];return(m+g)*3/4-g}function l(p,f,m){return(f+m)*3/4-m}function u(p){var f,m=i(p),g=m[0],y=m[1],b=new t(l(p,g,y)),v=0,x=y>0?g-4:g,S;for(S=0;S<x;S+=4)f=e[p.charCodeAt(S)]<<18|e[p.charCodeAt(S+1)]<<12|e[p.charCodeAt(S+2)]<<6|e[p.charCodeAt(S+3)],b[v++]=f>>16&255,b[v++]=f>>8&255,b[v++]=f&255;return y===2&&(f=e[p.charCodeAt(S)]<<2|e[p.charCodeAt(S+1)]>>4,b[v++]=f&255),y===1&&(f=e[p.charCodeAt(S)]<<10|e[p.charCodeAt(S+1)]<<4|e[p.charCodeAt(S+2)]>>2,b[v++]=f>>8&255,b[v++]=f&255),b}function c(p){return n[p>>18&63]+n[p>>12&63]+n[p>>6&63]+n[p&63]}function h(p,f,m){for(var g,y=[],b=f;b<m;b+=3)g=(p[b]<<16&16711680)+(p[b+1]<<8&65280)+(p[b+2]&255),y.push(c(g));return y.join("")}function d(p){for(var f,m=p.length,g=m%3,y=[],b=16383,v=0,x=m-g;v<x;v+=b)y.push(h(p,v,v+b>x?x:v+b));return g===1?(f=p[m-1],y.push(n[f>>2]+n[f<<4&63]+"==")):g===2&&(f=(p[m-2]<<8)+p[m-1],y.push(n[f>>10]+n[f>>4&63]+n[f<<2&63]+"=")),y.join("")}return Sa}var rc={};var _0;function I9(){return _0||(_0=1,rc.read=function(n,e,t,s,r){var o,i,a=r*8-s-1,l=(1<<a)-1,u=l>>1,c=-7,h=t?r-1:0,d=t?-1:1,p=n[e+h];for(h+=d,o=p&(1<<-c)-1,p>>=-c,c+=a;c>0;o=o*256+n[e+h],h+=d,c-=8);for(i=o&(1<<-c)-1,o>>=-c,c+=s;c>0;i=i*256+n[e+h],h+=d,c-=8);if(o===0)o=1-u;else{if(o===l)return i?NaN:(p?-1:1)*(1/0);i=i+Math.pow(2,s),o=o-u}return(p?-1:1)*i*Math.pow(2,o-s)},rc.write=function(n,e,t,s,r,o){var i,a,l,u=o*8-r-1,c=(1<<u)-1,h=c>>1,d=r===23?Math.pow(2,-24)-Math.pow(2,-77):0,p=s?0:o-1,f=s?1:-1,m=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,i=c):(i=Math.floor(Math.log(e)/Math.LN2),e*(l=Math.pow(2,-i))<1&&(i--,l*=2),i+h>=1?e+=d/l:e+=d*Math.pow(2,1-h),e*l>=2&&(i++,l/=2),i+h>=c?(a=0,i=c):i+h>=1?(a=(e*l-1)*Math.pow(2,r),i=i+h):(a=e*Math.pow(2,h-1)*Math.pow(2,r),i=0));r>=8;n[t+p]=a&255,p+=f,a/=256,r-=8);for(i=i<<r|a,u+=r;u>0;n[t+p]=i&255,p+=f,i/=256,u-=8);n[t+p-f]|=m*128}),rc}var O0;function $9(){return O0||(O0=1,function(n){const e=v9(),t=I9(),s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=a,n.SlowBuffer=b,n.INSPECT_MAX_BYTES=50;const r=2147483647;n.kMaxLength=r,a.TYPED_ARRAY_SUPPORT=o(),!a.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function o(){try{const E=new Uint8Array(1),w={foo:function(){return 42}};return Object.setPrototypeOf(w,Uint8Array.prototype),Object.setPrototypeOf(E,w),E.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.byteOffset}});function i(E){if(E>r)throw new RangeError('The value "'+E+'" is invalid for option "size"');const w=new Uint8Array(E);return Object.setPrototypeOf(w,a.prototype),w}function a(E,w,$){if(typeof E=="number"){if(typeof w=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return h(E)}return l(E,w,$)}a.poolSize=8192;function l(E,w,$){if(typeof E=="string")return d(E,w);if(ArrayBuffer.isView(E))return f(E);if(E==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof E);if(ot(E,ArrayBuffer)||E&&ot(E.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(ot(E,SharedArrayBuffer)||E&&ot(E.buffer,SharedArrayBuffer)))return m(E,w,$);if(typeof E=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const _=E.valueOf&&E.valueOf();if(_!=null&&_!==E)return a.from(_,w,$);const W=g(E);if(W)return W;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof E[Symbol.toPrimitive]=="function")return a.from(E[Symbol.toPrimitive]("string"),w,$);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof E)}a.from=function(E,w,$){return l(E,w,$)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function u(E){if(typeof E!="number")throw new TypeError('"size" argument must be of type number');if(E<0)throw new RangeError('The value "'+E+'" is invalid for option "size"')}function c(E,w,$){return u(E),E<=0?i(E):w!==void 0?typeof $=="string"?i(E).fill(w,$):i(E).fill(w):i(E)}a.alloc=function(E,w,$){return c(E,w,$)};function h(E){return u(E),i(E<0?0:y(E)|0)}a.allocUnsafe=function(E){return h(E)},a.allocUnsafeSlow=function(E){return h(E)};function d(E,w){if((typeof w!="string"||w==="")&&(w="utf8"),!a.isEncoding(w))throw new TypeError("Unknown encoding: "+w);const $=v(E,w)|0;let _=i($);const W=_.write(E,w);return W!==$&&(_=_.slice(0,W)),_}function p(E){const w=E.length<0?0:y(E.length)|0,$=i(w);for(let _=0;_<w;_+=1)$[_]=E[_]&255;return $}function f(E){if(ot(E,Uint8Array)){const w=new Uint8Array(E);return m(w.buffer,w.byteOffset,w.byteLength)}return p(E)}function m(E,w,$){if(w<0||E.byteLength<w)throw new RangeError('"offset" is outside of buffer bounds');if(E.byteLength<w+($||0))throw new RangeError('"length" is outside of buffer bounds');let _;return w===void 0&&$===void 0?_=new Uint8Array(E):$===void 0?_=new Uint8Array(E,w):_=new Uint8Array(E,w,$),Object.setPrototypeOf(_,a.prototype),_}function g(E){if(a.isBuffer(E)){const w=y(E.length)|0,$=i(w);return $.length===0||E.copy($,0,0,w),$}if(E.length!==void 0)return typeof E.length!="number"||Qn(E.length)?i(0):p(E);if(E.type==="Buffer"&&Array.isArray(E.data))return p(E.data)}function y(E){if(E>=r)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+r.toString(16)+" bytes");return E|0}function b(E){return+E!=E&&(E=0),a.alloc(+E)}a.isBuffer=function(w){return w!=null&&w._isBuffer===!0&&w!==a.prototype},a.compare=function(w,$){if(ot(w,Uint8Array)&&(w=a.from(w,w.offset,w.byteLength)),ot($,Uint8Array)&&($=a.from($,$.offset,$.byteLength)),!a.isBuffer(w)||!a.isBuffer($))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(w===$)return 0;let _=w.length,W=$.length;for(let Y=0,se=Math.min(_,W);Y<se;++Y)if(w[Y]!==$[Y]){_=w[Y],W=$[Y];break}return _<W?-1:W<_?1:0},a.isEncoding=function(w){switch(String(w).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(w,$){if(!Array.isArray(w))throw new TypeError('"list" argument must be an Array of Buffers');if(w.length===0)return a.alloc(0);let _;if($===void 0)for($=0,_=0;_<w.length;++_)$+=w[_].length;const W=a.allocUnsafe($);let Y=0;for(_=0;_<w.length;++_){let se=w[_];if(ot(se,Uint8Array))Y+se.length>W.length?(a.isBuffer(se)||(se=a.from(se)),se.copy(W,Y)):Uint8Array.prototype.set.call(W,se,Y);else if(a.isBuffer(se))se.copy(W,Y);else throw new TypeError('"list" argument must be an Array of Buffers');Y+=se.length}return W};function v(E,w){if(a.isBuffer(E))return E.length;if(ArrayBuffer.isView(E)||ot(E,ArrayBuffer))return E.byteLength;if(typeof E!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof E);const $=E.length,_=arguments.length>2&&arguments[2]===!0;if(!_&&$===0)return 0;let W=!1;for(;;)switch(w){case"ascii":case"latin1":case"binary":return $;case"utf8":case"utf-8":return Ye(E).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return $*2;case"hex":return $>>>1;case"base64":return vt(E).length;default:if(W)return _?-1:Ye(E).length;w=(""+w).toLowerCase(),W=!0}}a.byteLength=v;function x(E,w,$){let _=!1;if((w===void 0||w<0)&&(w=0),w>this.length||(($===void 0||$>this.length)&&($=this.length),$<=0)||($>>>=0,w>>>=0,$<=w))return"";for(E||(E="utf8");;)switch(E){case"hex":return Q(this,w,$);case"utf8":case"utf-8":return j(this,w,$);case"ascii":return J(this,w,$);case"latin1":case"binary":return K(this,w,$);case"base64":return V(this,w,$);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return te(this,w,$);default:if(_)throw new TypeError("Unknown encoding: "+E);E=(E+"").toLowerCase(),_=!0}}a.prototype._isBuffer=!0;function S(E,w,$){const _=E[w];E[w]=E[$],E[$]=_}a.prototype.swap16=function(){const w=this.length;if(w%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let $=0;$<w;$+=2)S(this,$,$+1);return this},a.prototype.swap32=function(){const w=this.length;if(w%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let $=0;$<w;$+=4)S(this,$,$+3),S(this,$+1,$+2);return this},a.prototype.swap64=function(){const w=this.length;if(w%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let $=0;$<w;$+=8)S(this,$,$+7),S(this,$+1,$+6),S(this,$+2,$+5),S(this,$+3,$+4);return this},a.prototype.toString=function(){const w=this.length;return w===0?"":arguments.length===0?j(this,0,w):x.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(w){if(!a.isBuffer(w))throw new TypeError("Argument must be a Buffer");return this===w?!0:a.compare(this,w)===0},a.prototype.inspect=function(){let w="";const $=n.INSPECT_MAX_BYTES;return w=this.toString("hex",0,$).replace(/(.{2})/g,"$1 ").trim(),this.length>$&&(w+=" ... "),"<Buffer "+w+">"},s&&(a.prototype[s]=a.prototype.inspect),a.prototype.compare=function(w,$,_,W,Y){if(ot(w,Uint8Array)&&(w=a.from(w,w.offset,w.byteLength)),!a.isBuffer(w))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof w);if($===void 0&&($=0),_===void 0&&(_=w?w.length:0),W===void 0&&(W=0),Y===void 0&&(Y=this.length),$<0||_>w.length||W<0||Y>this.length)throw new RangeError("out of range index");if(W>=Y&&$>=_)return 0;if(W>=Y)return-1;if($>=_)return 1;if($>>>=0,_>>>=0,W>>>=0,Y>>>=0,this===w)return 0;let se=Y-W,Fe=_-$;const it=Math.min(se,Fe),at=this.slice(W,Y),ft=w.slice($,_);for(let Qe=0;Qe<it;++Qe)if(at[Qe]!==ft[Qe]){se=at[Qe],Fe=ft[Qe];break}return se<Fe?-1:Fe<se?1:0};function k(E,w,$,_,W){if(E.length===0)return-1;if(typeof $=="string"?(_=$,$=0):$>2147483647?$=2147483647:$<-2147483648&&($=-2147483648),$=+$,Qn($)&&($=W?0:E.length-1),$<0&&($=E.length+$),$>=E.length){if(W)return-1;$=E.length-1}else if($<0)if(W)$=0;else return-1;if(typeof w=="string"&&(w=a.from(w,_)),a.isBuffer(w))return w.length===0?-1:D(E,w,$,_,W);if(typeof w=="number")return w=w&255,typeof Uint8Array.prototype.indexOf=="function"?W?Uint8Array.prototype.indexOf.call(E,w,$):Uint8Array.prototype.lastIndexOf.call(E,w,$):D(E,[w],$,_,W);throw new TypeError("val must be string, number or Buffer")}function D(E,w,$,_,W){let Y=1,se=E.length,Fe=w.length;if(_!==void 0&&(_=String(_).toLowerCase(),_==="ucs2"||_==="ucs-2"||_==="utf16le"||_==="utf-16le")){if(E.length<2||w.length<2)return-1;Y=2,se/=2,Fe/=2,$/=2}function it(ft,Qe){return Y===1?ft[Qe]:ft.readUInt16BE(Qe*Y)}let at;if(W){let ft=-1;for(at=$;at<se;at++)if(it(E,at)===it(w,ft===-1?0:at-ft)){if(ft===-1&&(ft=at),at-ft+1===Fe)return ft*Y}else ft!==-1&&(at-=at-ft),ft=-1}else for($+Fe>se&&($=se-Fe),at=$;at>=0;at--){let ft=!0;for(let Qe=0;Qe<Fe;Qe++)if(it(E,at+Qe)!==it(w,Qe)){ft=!1;break}if(ft)return at}return-1}a.prototype.includes=function(w,$,_){return this.indexOf(w,$,_)!==-1},a.prototype.indexOf=function(w,$,_){return k(this,w,$,_,!0)},a.prototype.lastIndexOf=function(w,$,_){return k(this,w,$,_,!1)};function F(E,w,$,_){$=Number($)||0;const W=E.length-$;_?(_=Number(_),_>W&&(_=W)):_=W;const Y=w.length;_>Y/2&&(_=Y/2);let se;for(se=0;se<_;++se){const Fe=parseInt(w.substr(se*2,2),16);if(Qn(Fe))return se;E[$+se]=Fe}return se}function A(E,w,$,_){return An(Ye(w,E.length-$),E,$,_)}function R(E,w,$,_){return An(Ze(w),E,$,_)}function N(E,w,$,_){return An(vt(w),E,$,_)}function z(E,w,$,_){return An(Zn(w,E.length-$),E,$,_)}a.prototype.write=function(w,$,_,W){if($===void 0)W="utf8",_=this.length,$=0;else if(_===void 0&&typeof $=="string")W=$,_=this.length,$=0;else if(isFinite($))$=$>>>0,isFinite(_)?(_=_>>>0,W===void 0&&(W="utf8")):(W=_,_=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const Y=this.length-$;if((_===void 0||_>Y)&&(_=Y),w.length>0&&(_<0||$<0)||$>this.length)throw new RangeError("Attempt to write outside buffer bounds");W||(W="utf8");let se=!1;for(;;)switch(W){case"hex":return F(this,w,$,_);case"utf8":case"utf-8":return A(this,w,$,_);case"ascii":case"latin1":case"binary":return R(this,w,$,_);case"base64":return N(this,w,$,_);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return z(this,w,$,_);default:if(se)throw new TypeError("Unknown encoding: "+W);W=(""+W).toLowerCase(),se=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function V(E,w,$){return w===0&&$===E.length?e.fromByteArray(E):e.fromByteArray(E.slice(w,$))}function j(E,w,$){$=Math.min(E.length,$);const _=[];let W=w;for(;W<$;){const Y=E[W];let se=null,Fe=Y>239?4:Y>223?3:Y>191?2:1;if(W+Fe<=$){let it,at,ft,Qe;switch(Fe){case 1:Y<128&&(se=Y);break;case 2:it=E[W+1],(it&192)===128&&(Qe=(Y&31)<<6|it&63,Qe>127&&(se=Qe));break;case 3:it=E[W+1],at=E[W+2],(it&192)===128&&(at&192)===128&&(Qe=(Y&15)<<12|(it&63)<<6|at&63,Qe>2047&&(Qe<55296||Qe>57343)&&(se=Qe));break;case 4:it=E[W+1],at=E[W+2],ft=E[W+3],(it&192)===128&&(at&192)===128&&(ft&192)===128&&(Qe=(Y&15)<<18|(it&63)<<12|(at&63)<<6|ft&63,Qe>65535&&Qe<1114112&&(se=Qe))}}se===null?(se=65533,Fe=1):se>65535&&(se-=65536,_.push(se>>>10&1023|55296),se=56320|se&1023),_.push(se),W+=Fe}return q(_)}const G=4096;function q(E){const w=E.length;if(w<=G)return String.fromCharCode.apply(String,E);let $="",_=0;for(;_<w;)$+=String.fromCharCode.apply(String,E.slice(_,_+=G));return $}function J(E,w,$){let _="";$=Math.min(E.length,$);for(let W=w;W<$;++W)_+=String.fromCharCode(E[W]&127);return _}function K(E,w,$){let _="";$=Math.min(E.length,$);for(let W=w;W<$;++W)_+=String.fromCharCode(E[W]);return _}function Q(E,w,$){const _=E.length;(!w||w<0)&&(w=0),(!$||$<0||$>_)&&($=_);let W="";for(let Y=w;Y<$;++Y)W+=Rn[E[Y]];return W}function te(E,w,$){const _=E.slice(w,$);let W="";for(let Y=0;Y<_.length-1;Y+=2)W+=String.fromCharCode(_[Y]+_[Y+1]*256);return W}a.prototype.slice=function(w,$){const _=this.length;w=~~w,$=$===void 0?_:~~$,w<0?(w+=_,w<0&&(w=0)):w>_&&(w=_),$<0?($+=_,$<0&&($=0)):$>_&&($=_),$<w&&($=w);const W=this.subarray(w,$);return Object.setPrototypeOf(W,a.prototype),W};function ee(E,w,$){if(E%1!==0||E<0)throw new RangeError("offset is not uint");if(E+w>$)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(w,$,_){w=w>>>0,$=$>>>0,_||ee(w,$,this.length);let W=this[w],Y=1,se=0;for(;++se<$&&(Y*=256);)W+=this[w+se]*Y;return W},a.prototype.readUintBE=a.prototype.readUIntBE=function(w,$,_){w=w>>>0,$=$>>>0,_||ee(w,$,this.length);let W=this[w+--$],Y=1;for(;$>0&&(Y*=256);)W+=this[w+--$]*Y;return W},a.prototype.readUint8=a.prototype.readUInt8=function(w,$){return w=w>>>0,$||ee(w,1,this.length),this[w]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(w,$){return w=w>>>0,$||ee(w,2,this.length),this[w]|this[w+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(w,$){return w=w>>>0,$||ee(w,2,this.length),this[w]<<8|this[w+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(w,$){return w=w>>>0,$||ee(w,4,this.length),(this[w]|this[w+1]<<8|this[w+2]<<16)+this[w+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(w,$){return w=w>>>0,$||ee(w,4,this.length),this[w]*16777216+(this[w+1]<<16|this[w+2]<<8|this[w+3])},a.prototype.readBigUInt64LE=Mt(function(w){w=w>>>0,Me(w,"offset");const $=this[w],_=this[w+7];($===void 0||_===void 0)&&je(w,this.length-8);const W=$+this[++w]*2**8+this[++w]*2**16+this[++w]*2**24,Y=this[++w]+this[++w]*2**8+this[++w]*2**16+_*2**24;return BigInt(W)+(BigInt(Y)<<BigInt(32))}),a.prototype.readBigUInt64BE=Mt(function(w){w=w>>>0,Me(w,"offset");const $=this[w],_=this[w+7];($===void 0||_===void 0)&&je(w,this.length-8);const W=$*2**24+this[++w]*2**16+this[++w]*2**8+this[++w],Y=this[++w]*2**24+this[++w]*2**16+this[++w]*2**8+_;return(BigInt(W)<<BigInt(32))+BigInt(Y)}),a.prototype.readIntLE=function(w,$,_){w=w>>>0,$=$>>>0,_||ee(w,$,this.length);let W=this[w],Y=1,se=0;for(;++se<$&&(Y*=256);)W+=this[w+se]*Y;return Y*=128,W>=Y&&(W-=Math.pow(2,8*$)),W},a.prototype.readIntBE=function(w,$,_){w=w>>>0,$=$>>>0,_||ee(w,$,this.length);let W=$,Y=1,se=this[w+--W];for(;W>0&&(Y*=256);)se+=this[w+--W]*Y;return Y*=128,se>=Y&&(se-=Math.pow(2,8*$)),se},a.prototype.readInt8=function(w,$){return w=w>>>0,$||ee(w,1,this.length),this[w]&128?(255-this[w]+1)*-1:this[w]},a.prototype.readInt16LE=function(w,$){w=w>>>0,$||ee(w,2,this.length);const _=this[w]|this[w+1]<<8;return _&32768?_|4294901760:_},a.prototype.readInt16BE=function(w,$){w=w>>>0,$||ee(w,2,this.length);const _=this[w+1]|this[w]<<8;return _&32768?_|4294901760:_},a.prototype.readInt32LE=function(w,$){return w=w>>>0,$||ee(w,4,this.length),this[w]|this[w+1]<<8|this[w+2]<<16|this[w+3]<<24},a.prototype.readInt32BE=function(w,$){return w=w>>>0,$||ee(w,4,this.length),this[w]<<24|this[w+1]<<16|this[w+2]<<8|this[w+3]},a.prototype.readBigInt64LE=Mt(function(w){w=w>>>0,Me(w,"offset");const $=this[w],_=this[w+7];($===void 0||_===void 0)&&je(w,this.length-8);const W=this[w+4]+this[w+5]*2**8+this[w+6]*2**16+(_<<24);return(BigInt(W)<<BigInt(32))+BigInt($+this[++w]*2**8+this[++w]*2**16+this[++w]*2**24)}),a.prototype.readBigInt64BE=Mt(function(w){w=w>>>0,Me(w,"offset");const $=this[w],_=this[w+7];($===void 0||_===void 0)&&je(w,this.length-8);const W=($<<24)+this[++w]*2**16+this[++w]*2**8+this[++w];return(BigInt(W)<<BigInt(32))+BigInt(this[++w]*2**24+this[++w]*2**16+this[++w]*2**8+_)}),a.prototype.readFloatLE=function(w,$){return w=w>>>0,$||ee(w,4,this.length),t.read(this,w,!0,23,4)},a.prototype.readFloatBE=function(w,$){return w=w>>>0,$||ee(w,4,this.length),t.read(this,w,!1,23,4)},a.prototype.readDoubleLE=function(w,$){return w=w>>>0,$||ee(w,8,this.length),t.read(this,w,!0,52,8)},a.prototype.readDoubleBE=function(w,$){return w=w>>>0,$||ee(w,8,this.length),t.read(this,w,!1,52,8)};function ne(E,w,$,_,W,Y){if(!a.isBuffer(E))throw new TypeError('"buffer" argument must be a Buffer instance');if(w>W||w<Y)throw new RangeError('"value" argument is out of bounds');if($+_>E.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(w,$,_,W){if(w=+w,$=$>>>0,_=_>>>0,!W){const Fe=Math.pow(2,8*_)-1;ne(this,w,$,_,Fe,0)}let Y=1,se=0;for(this[$]=w&255;++se<_&&(Y*=256);)this[$+se]=w/Y&255;return $+_},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(w,$,_,W){if(w=+w,$=$>>>0,_=_>>>0,!W){const Fe=Math.pow(2,8*_)-1;ne(this,w,$,_,Fe,0)}let Y=_-1,se=1;for(this[$+Y]=w&255;--Y>=0&&(se*=256);)this[$+Y]=w/se&255;return $+_},a.prototype.writeUint8=a.prototype.writeUInt8=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,1,255,0),this[$]=w&255,$+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,2,65535,0),this[$]=w&255,this[$+1]=w>>>8,$+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,2,65535,0),this[$]=w>>>8,this[$+1]=w&255,$+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,4,4294967295,0),this[$+3]=w>>>24,this[$+2]=w>>>16,this[$+1]=w>>>8,this[$]=w&255,$+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,4,4294967295,0),this[$]=w>>>24,this[$+1]=w>>>16,this[$+2]=w>>>8,this[$+3]=w&255,$+4};function oe(E,w,$,_,W){We(w,_,W,E,$,7);let Y=Number(w&BigInt(4294967295));E[$++]=Y,Y=Y>>8,E[$++]=Y,Y=Y>>8,E[$++]=Y,Y=Y>>8,E[$++]=Y;let se=Number(w>>BigInt(32)&BigInt(4294967295));return E[$++]=se,se=se>>8,E[$++]=se,se=se>>8,E[$++]=se,se=se>>8,E[$++]=se,$}function ue(E,w,$,_,W){We(w,_,W,E,$,7);let Y=Number(w&BigInt(4294967295));E[$+7]=Y,Y=Y>>8,E[$+6]=Y,Y=Y>>8,E[$+5]=Y,Y=Y>>8,E[$+4]=Y;let se=Number(w>>BigInt(32)&BigInt(4294967295));return E[$+3]=se,se=se>>8,E[$+2]=se,se=se>>8,E[$+1]=se,se=se>>8,E[$]=se,$+8}a.prototype.writeBigUInt64LE=Mt(function(w,$=0){return oe(this,w,$,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeBigUInt64BE=Mt(function(w,$=0){return ue(this,w,$,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeIntLE=function(w,$,_,W){if(w=+w,$=$>>>0,!W){const it=Math.pow(2,8*_-1);ne(this,w,$,_,it-1,-it)}let Y=0,se=1,Fe=0;for(this[$]=w&255;++Y<_&&(se*=256);)w<0&&Fe===0&&this[$+Y-1]!==0&&(Fe=1),this[$+Y]=(w/se>>0)-Fe&255;return $+_},a.prototype.writeIntBE=function(w,$,_,W){if(w=+w,$=$>>>0,!W){const it=Math.pow(2,8*_-1);ne(this,w,$,_,it-1,-it)}let Y=_-1,se=1,Fe=0;for(this[$+Y]=w&255;--Y>=0&&(se*=256);)w<0&&Fe===0&&this[$+Y+1]!==0&&(Fe=1),this[$+Y]=(w/se>>0)-Fe&255;return $+_},a.prototype.writeInt8=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,1,127,-128),w<0&&(w=255+w+1),this[$]=w&255,$+1},a.prototype.writeInt16LE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,2,32767,-32768),this[$]=w&255,this[$+1]=w>>>8,$+2},a.prototype.writeInt16BE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,2,32767,-32768),this[$]=w>>>8,this[$+1]=w&255,$+2},a.prototype.writeInt32LE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,4,2147483647,-2147483648),this[$]=w&255,this[$+1]=w>>>8,this[$+2]=w>>>16,this[$+3]=w>>>24,$+4},a.prototype.writeInt32BE=function(w,$,_){return w=+w,$=$>>>0,_||ne(this,w,$,4,2147483647,-2147483648),w<0&&(w=4294967295+w+1),this[$]=w>>>24,this[$+1]=w>>>16,this[$+2]=w>>>8,this[$+3]=w&255,$+4},a.prototype.writeBigInt64LE=Mt(function(w,$=0){return oe(this,w,$,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),a.prototype.writeBigInt64BE=Mt(function(w,$=0){return ue(this,w,$,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function ae(E,w,$,_,W,Y){if($+_>E.length)throw new RangeError("Index out of range");if($<0)throw new RangeError("Index out of range")}function de(E,w,$,_,W){return w=+w,$=$>>>0,W||ae(E,w,$,4),t.write(E,w,$,_,23,4),$+4}a.prototype.writeFloatLE=function(w,$,_){return de(this,w,$,!0,_)},a.prototype.writeFloatBE=function(w,$,_){return de(this,w,$,!1,_)};function be(E,w,$,_,W){return w=+w,$=$>>>0,W||ae(E,w,$,8),t.write(E,w,$,_,52,8),$+8}a.prototype.writeDoubleLE=function(w,$,_){return be(this,w,$,!0,_)},a.prototype.writeDoubleBE=function(w,$,_){return be(this,w,$,!1,_)},a.prototype.copy=function(w,$,_,W){if(!a.isBuffer(w))throw new TypeError("argument should be a Buffer");if(_||(_=0),!W&&W!==0&&(W=this.length),$>=w.length&&($=w.length),$||($=0),W>0&&W<_&&(W=_),W===_||w.length===0||this.length===0)return 0;if($<0)throw new RangeError("targetStart out of bounds");if(_<0||_>=this.length)throw new RangeError("Index out of range");if(W<0)throw new RangeError("sourceEnd out of bounds");W>this.length&&(W=this.length),w.length-$<W-_&&(W=w.length-$+_);const Y=W-_;return this===w&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin($,_,W):Uint8Array.prototype.set.call(w,this.subarray(_,W),$),Y},a.prototype.fill=function(w,$,_,W){if(typeof w=="string"){if(typeof $=="string"?(W=$,$=0,_=this.length):typeof _=="string"&&(W=_,_=this.length),W!==void 0&&typeof W!="string")throw new TypeError("encoding must be a string");if(typeof W=="string"&&!a.isEncoding(W))throw new TypeError("Unknown encoding: "+W);if(w.length===1){const se=w.charCodeAt(0);(W==="utf8"&&se<128||W==="latin1")&&(w=se)}}else typeof w=="number"?w=w&255:typeof w=="boolean"&&(w=Number(w));if($<0||this.length<$||this.length<_)throw new RangeError("Out of range index");if(_<=$)return this;$=$>>>0,_=_===void 0?this.length:_>>>0,w||(w=0);let Y;if(typeof w=="number")for(Y=$;Y<_;++Y)this[Y]=w;else{const se=a.isBuffer(w)?w:a.from(w,W),Fe=se.length;if(Fe===0)throw new TypeError('The value "'+w+'" is invalid for argument "value"');for(Y=0;Y<_-$;++Y)this[Y+$]=se[Y%Fe]}return this};const ve={};function Ie(E,w,$){ve[E]=class extends ${constructor(){super(),Object.defineProperty(this,"message",{value:w.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${E}]`,this.stack,delete this.name}get code(){return E}set code(W){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:W,writable:!0})}toString(){return`${this.name} [${E}]: ${this.message}`}}}Ie("ERR_BUFFER_OUT_OF_BOUNDS",function(E){return E?`${E} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),Ie("ERR_INVALID_ARG_TYPE",function(E,w){return`The "${E}" argument must be of type number. Received type ${typeof w}`},TypeError),Ie("ERR_OUT_OF_RANGE",function(E,w,$){let _=`The value of "${E}" is out of range.`,W=$;return Number.isInteger($)&&Math.abs($)>2**32?W=Ce(String($)):typeof $=="bigint"&&(W=String($),($>BigInt(2)**BigInt(32)||$<-(BigInt(2)**BigInt(32)))&&(W=Ce(W)),W+="n"),_+=` It must be ${w}. Received ${W}`,_},RangeError);function Ce(E){let w="",$=E.length;const _=E[0]==="-"?1:0;for(;$>=_+4;$-=3)w=`_${E.slice($-3,$)}${w}`;return`${E.slice(0,$)}${w}`}function ke(E,w,$){Me(w,"offset"),(E[w]===void 0||E[w+$]===void 0)&&je(w,E.length-($+1))}function We(E,w,$,_,W,Y){if(E>$||E<w){const se=typeof w=="bigint"?"n":"";let Fe;throw w===0||w===BigInt(0)?Fe=`>= 0${se} and < 2${se} ** ${(Y+1)*8}${se}`:Fe=`>= -(2${se} ** ${(Y+1)*8-1}${se}) and < 2 ** ${(Y+1)*8-1}${se}`,new ve.ERR_OUT_OF_RANGE("value",Fe,E)}ke(_,W,Y)}function Me(E,w){if(typeof E!="number")throw new ve.ERR_INVALID_ARG_TYPE(w,"number",E)}function je(E,w,$){throw Math.floor(E)!==E?(Me(E,$),new ve.ERR_OUT_OF_RANGE("offset","an integer",E)):w<0?new ve.ERR_BUFFER_OUT_OF_BOUNDS:new ve.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${w}`,E)}const qe=/[^+/0-9A-Za-z-_]/g;function Ue(E){if(E=E.split("=")[0],E=E.trim().replace(qe,""),E.length<2)return"";for(;E.length%4!==0;)E=E+"=";return E}function Ye(E,w){w=w||1/0;let $;const _=E.length;let W=null;const Y=[];for(let se=0;se<_;++se){if($=E.charCodeAt(se),$>55295&&$<57344){if(!W){if($>56319){(w-=3)>-1&&Y.push(239,191,189);continue}else if(se+1===_){(w-=3)>-1&&Y.push(239,191,189);continue}W=$;continue}if($<56320){(w-=3)>-1&&Y.push(239,191,189),W=$;continue}$=(W-55296<<10|$-56320)+65536}else W&&(w-=3)>-1&&Y.push(239,191,189);if(W=null,$<128){if((w-=1)<0)break;Y.push($)}else if($<2048){if((w-=2)<0)break;Y.push($>>6|192,$&63|128)}else if($<65536){if((w-=3)<0)break;Y.push($>>12|224,$>>6&63|128,$&63|128)}else if($<1114112){if((w-=4)<0)break;Y.push($>>18|240,$>>12&63|128,$>>6&63|128,$&63|128)}else throw new Error("Invalid code point")}return Y}function Ze(E){const w=[];for(let $=0;$<E.length;++$)w.push(E.charCodeAt($)&255);return w}function Zn(E,w){let $,_,W;const Y=[];for(let se=0;se<E.length&&!((w-=2)<0);++se)$=E.charCodeAt(se),_=$>>8,W=$%256,Y.push(W),Y.push(_);return Y}function vt(E){return e.toByteArray(Ue(E))}function An(E,w,$,_){let W;for(W=0;W<_&&!(W+$>=w.length||W>=E.length);++W)w[W+$]=E[W];return W}function ot(E,w){return E instanceof w||E!=null&&E.constructor!=null&&E.constructor.name!=null&&E.constructor.name===w.name}function Qn(E){return E!==E}const Rn=function(){const E="0123456789abcdef",w=new Array(256);for(let $=0;$<16;++$){const _=$*16;for(let W=0;W<16;++W)w[_+W]=E[$]+E[W]}return w}();function Mt(E){return typeof BigInt>"u"?ys:E}function ys(){throw new Error("BigInt not supported")}}(zp)),zp}var S9=$9(),N9={0:"Drawing",1:"Hentai",2:"Neutral",3:"Porn",4:"Sexy"},Ks=function(n,e,t,s){function r(o){return o instanceof t?o:new t(function(i){i(o)})}return new(t||(t=Promise))(function(o,i){function a(c){try{u(s.next(c))}catch(h){i(h)}}function l(c){try{u(s.throw(c))}catch(h){i(h)}}function u(c){c.done?o(c.value):r(c.value).then(a,l)}u((s=s.apply(n,e||[])).next())})},Xs=function(n,e){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},s,r,o,i=Object.create((typeof Iterator=="function"?Iterator:Object).prototype);return i.next=a(0),i.throw=a(1),i.return=a(2),typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(u){return function(c){return l([u,c])}}function l(u){if(s)throw new TypeError("Generator is already executing.");for(;i&&(i=0,u[0]&&(t=0)),t;)try{if(s=1,r&&(o=u[0]&2?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[u[0]&2,o.value]),u[0]){case 0:case 1:o=u;break;case 4:return t.label++,{value:u[1],done:!1};case 5:t.label++,r=u[1],u=[0];continue;case 7:u=t.ops.pop(),t.trys.pop();continue;default:if(o=t.trys,!(o=o.length>0&&o[o.length-1])&&(u[0]===6||u[0]===2)){t=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){t.label=u[1];break}if(u[0]===6&&t.label<o[1]){t.label=o[1],o=u;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(u);break}o[2]&&t.ops.pop(),t.trys.pop();continue}u=e.call(n,t)}catch(c){u=[6,c],r=0}finally{s=o=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}},C9=function(n,e,t){if(t||arguments.length===2)for(var s=0,r=e.length,o;s<r;s++)(o||!(s in e))&&(o||(o=Array.prototype.slice.call(e,0,s)),o[s]=e[s]);return n.concat(o||Array.prototype.slice.call(e))},Gb={MobileNetV2:{numOfWeightBundles:1},MobileNetV2Mid:{numOfWeightBundles:2,options:{type:"graph"}},InceptionV3:{numOfWeightBundles:6,options:{size:299}}},k9="MobileNetV2",L0=224,UN=function(){if(typeof globalThis<"u")return globalThis;if(typeof global<"u")return global;if(typeof window<"u")return window;if(typeof self<"u")return self;throw new Error("Unable to locate global object")};function GN(n){return!!n&&n in Gb}var T9=function(n){return Ks(void 0,void 0,void 0,function(){var e,t;return Xs(this,function(s){switch(s.label){case 0:return e=UN().model,e?[2,e]:n!=="MobileNetV2"?[3,2]:[4,Po(()=>import("./mobilenet_v2-DcXBpXMN.js"),__vite__mapDeps([0,1,2,3,4,5,6,7]))];case 1:return t=s.sent().modelJson,[3,6];case 2:return n!=="MobileNetV2Mid"?[3,4]:[4,Po(()=>import("./mobilenet_v2_mid-C3dlDOIT.js"),__vite__mapDeps([8,1,2,3,4,5,6,7]))];case 3:return t=s.sent().modelJson,[3,6];case 4:return n!=="InceptionV3"?[3,6]:[4,Po(()=>import("./inception_v3-DgsGdnYZ.js"),__vite__mapDeps([9,1,2,3,4,5,6,7]))];case 5:t=s.sent().modelJson,s.label=6;case 6:return[4,t()];case 7:return[2,s.sent().default]}})})},E9=function(n){return Ks(void 0,void 0,void 0,function(){var e,t,s,r,o,i,a,l,u,c;return Xs(this,function(h){switch(h.label){case 0:e=Gb[n].numOfWeightBundles,t=[],s=0,h.label=1;case 1:return s<e?(r="group1-shard".concat(s+1,"of").concat(e),o=r.replace(/-/g,"_"),i=UN()[o],i?(t.push((u={},u[r]=i,u)),[3,10]):[3,2]):[3,11];case 2:return a=void 0,n!=="MobileNetV2"?[3,4]:[4,Po(()=>import("./mobilenet_v2-DcXBpXMN.js"),__vite__mapDeps([0,1,2,3,4,5,6,7]))];case 3:return a=h.sent().weightBundles,[3,8];case 4:return n!=="MobileNetV2Mid"?[3,6]:[4,Po(()=>import("./mobilenet_v2_mid-C3dlDOIT.js"),__vite__mapDeps([8,1,2,3,4,5,6,7]))];case 5:return a=h.sent().weightBundles,[3,8];case 6:return n!=="InceptionV3"?[3,8]:[4,Po(()=>import("./inception_v3-DgsGdnYZ.js"),__vite__mapDeps([9,1,2,3,4,5,6,7]))];case 7:a=h.sent().weightBundles,h.label=8;case 8:return[4,a[s]()];case 9:l=h.sent().default,t.push((c={},c[r]=l,c)),h.label=10;case 10:return s++,[3,1];case 11:return[2,Object.assign.apply(Object,C9([{}],t,!1))]}})})};function A9(n){return Ks(this,void 0,void 0,function(){var e;return Xs(this,function(t){switch(t.label){case 0:return t.trys.push([0,2,,3]),[4,E9(n)];case 1:return e=t.sent(),[2,e];case 2:throw t.sent(),new Error("Could not load the weight data. Make sure you are importing the correct shard files from the models directory. Ref: https://github.com/infinitered/nsfwjs?tab=readme-ov-file#browserify");case 3:return[2]}})})}function R9(n){return Ks(this,void 0,void 0,function(){var e,t,s;return Xs(this,function(r){switch(r.label){case 0:if(!GN(n))return[2,n];r.label=1;case 1:return r.trys.push([1,4,,5]),[4,T9(n)];case 2:return e=r.sent(),[4,A9(n)];case 3:return t=r.sent(),s=new F9(e,t),[2,s];case 4:throw r.sent(),new Error("Could not load the model. Make sure you are importing the model.min.js bundle. Ref: https://github.com/infinitered/nsfwjs?tab=readme-ov-file#browserify");case 5:return[2]}})})}function D9(n){return Ks(this,arguments,void 0,function(e,t){var s,r,o;return t===void 0&&(t={size:L0}),Xs(this,function(i){switch(i.label){case 0:if(w9==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");return e===void 0?(e=k9,console.info("%cBy not specifying 'modelOrUrl' parameter, you're using the default model: '".concat(e,"'. See NSFWJS docs for instructions on hosting your own model (https://github.com/infinitered/nsfwjs?tab=readme-ov-file#host-your-own-model)."),"color: lightblue")):GN(e)&&(console.info("%cYou're using the model: '".concat(e,"'. See NSFWJS docs for instructions on hosting your own model (https://github.com/infinitered/nsfwjs?tab=readme-ov-file#host-your-own-model)."),"color: lightblue"),t=(o=Gb[e].options)!==null&&o!==void 0?o:t),t.size=t?.size||L0,[4,R9(e)];case 1:return s=i.sent(),r=new _9(s,t),[4,r.load()];case 2:return i.sent(),[2,r]}})})}var F9=function(){function n(e,t){this.modelJson=e,this.weightDataBase64=t}return n.prototype.arrayBufferFromBase64=function(e){for(var t=S9.Buffer.from(e,"base64").toString("binary"),s=t.length,r=new Uint8Array(s),o=0;o<s;o++)r[o]=t.charCodeAt(o);return r.buffer},n.prototype.load=function(){return Ks(this,void 0,void 0,function(){var e,t,s,r,o,i,a,l,u,c,h,d,p,f;return Xs(this,function(m){if(e={modelTopology:this.modelJson.modelTopology,format:this.modelJson.format,generatedBy:this.modelJson.generatedBy,convertedBy:this.modelJson.convertedBy},this.modelJson.weightsManifest!=null){for(t=[],s=[],r=0,o=this.modelJson.weightsManifest;r<o.length;r++){for(i=o[r],a=0,l=i.paths;a<l.length;a++){if(u=l[a],c=this.weightDataBase64[u],!c)throw new Error("Could not find the weight data. Make sure you are importing the correct weight bundle for the model: ".concat(u,".min.js."));h=this.arrayBufferFromBase64(c),s.push(new Uint8Array(h))}t.push.apply(t,i.weights)}for(e.weightSpecs=t,d=new Uint8Array(s.reduce(function(g,y){return g+y.length},0)),p=0,f=0;f<s.length;f++)d.set(s[f],p),p+=s[f].byteLength;e.weightData=d.buffer}return this.modelJson.trainingConfig!=null&&(e.trainingConfig=this.modelJson.trainingConfig),this.modelJson.userDefinedMetadata!=null&&(e.userDefinedMetadata=this.modelJson.userDefinedMetadata),[2,e]})})},n}(),_9=function(){function n(e,t){this.intermediateModels={},this.options=t,this.normalizationOffset=xe(255),this.urlOrIOHandler=e,typeof e=="string"&&!e.startsWith("indexeddb://")&&!e.startsWith("localstorage://")&&!e.endsWith("model.json")?this.urlOrIOHandler="".concat(e,"model.json"):this.urlOrIOHandler=e}return n.prototype.load=function(){return Ks(this,void 0,void 0,function(){var e,t,s,r,o,i,a=this;return Xs(this,function(l){switch(l.label){case 0:return e=this.options,t=e.size,s=e.type,s!=="graph"?[3,2]:(r=this,[4,BI(this.urlOrIOHandler)]);case 1:return r.model=l.sent(),[3,4];case 2:return o=this,[4,Jv(this.urlOrIOHandler)];case 3:o.model=l.sent(),this.endpoints=this.model.layers.map(function(u){return u.name}),l.label=4;case 4:return i=U(function(){return a.model.predict(mt([1,t,t,3]))}),[4,i.data()];case 5:return l.sent(),i.dispose(),[2]}})})},n.prototype.infer=function(e,t){var s=this;if(t!=null&&this.endpoints.indexOf(t)===-1)throw new Error("Unknown endpoint ".concat(t,". Available endpoints: ").concat(this.endpoints,"."));return U(function(){e instanceof ze||(e=pg(e));var r=e.toFloat().div(s.normalizationOffset),o=r,i=s.options.size;if(e.shape[0]!==i||e.shape[1]!==i){var a=!0;o=Ln.resizeBilinear(r,[i,i],a)}var l=o.reshape([1,i,i,3]),u;if(t==null)u=s.model;else{if(s.model.hasOwnProperty("layers")&&s.intermediateModels[t]==null){var c=s.model.layers.find(function(h){return h.name===t});s.intermediateModels[t]=Zv({inputs:s.model.inputs,outputs:c.output})}u=s.intermediateModels[t]}return u.predict(l)})},n.prototype.classify=function(e){return Ks(this,arguments,void 0,function(t,s){var r,o;return s===void 0&&(s=5),Xs(this,function(i){switch(i.label){case 0:return r=this.infer(t),[4,O9(r,s)];case 1:return o=i.sent(),r.dispose(),[2,o]}})})},n}();function O9(n,e){return Ks(this,void 0,void 0,function(){var t,s,a,r,o,a,i,a;return Xs(this,function(l){switch(l.label){case 0:return[4,n.data()];case 1:for(t=l.sent(),s=[],a=0;a<t.length;a++)s.push({value:t[a],index:a});for(s.sort(function(u,c){return c.value-u.value}),r=new Float32Array(e),o=new Int32Array(e),a=0;a<e;a++)r[a]=s[a].value,o[a]=s[a].index;for(i=[],a=0;a<o.length;a++)i.push({className:N9[o[a]],probability:r[a]});return[2,i]}})})}const H9=()=>{const[n,e]=Lr.useState(null),[t,s]=Lr.useState(!1),[r,o]=Lr.useState(null),[i,a]=Lr.useState(null),l=Lr.useCallback(async(h="mobilenet_v2")=>{if(!(n||t)){s(!0),o(null);try{console.log(` Cargando modelo NSFWJS: ${h}...`);const p={inception_v3:"/models/inception_v3/model.json",mobilenet_v2:"/models/mobilenet_v2/model.json",mobilenet_v2_mid:"/models/mobilenet_v2_mid/model.json"}[h];console.log(` Cargando modelo desde: ${p}`);const f=await D9(p);e(f),a(h),console.log(` Modelo NSFWJS ${h} cargado correctamente`)}catch(d){console.error(" Error al cargar modelo NSFWJS:",d),o(`No se pudo cargar el modelo: ${d instanceof Error?d.message:"Error desconocido"}`)}finally{s(!1)}}},[n,t]),u=Lr.useCallback(async h=>{if(!n)return console.warn(" Modelo no disponible, aprobando imagen por defecto"),{esAprobado:!0,puntuacion:.8,categorias:[],razon:"Modelo de moderacin no disponible"};try{const d=document.createElement("img");d.crossOrigin="anonymous";const p=URL.createObjectURL(h);await new Promise((S,k)=>{d.onload=S,d.onerror=k,d.src=p});const f=await n.classify(d);URL.revokeObjectURL(p),console.log(" Resultados del anlisis:",f);const m=["Porn","Hentai","Sexy"];if(!f[0])return{esAprobado:!0,puntuacion:.8,categorias:[],razon:"No se pudo analizar la imagen"};let y=1,b;const v=f.find(S=>m.includes(S.className)&&S.probability>.6);return v&&(y=1-v.probability,b=`Contenido inapropiado detectado: ${v.className} (${Math.round(v.probability*100)}%)`),{esAprobado:!b,puntuacion:Math.round(y*100)/100,categorias:f.map(S=>({clase:S.className,probabilidad:Math.round(S.probability*100)/100})),razon:b}}catch(d){return console.error(" Error analizando imagen:",d),{esAprobado:!1,puntuacion:.3,categorias:[],razon:"Error tcnico al analizar la imagen"}}},[n]),c=Lr.useCallback(()=>{!n&&!t&&!r&&(console.log(" Inicializando modelo automticamente..."),l("mobilenet_v2"))},[n,t,r,l]);return{modelo:n,cargando:t,errorModelo:r,modeloCargado:i,inicializarModelo:c,inicializarModeloEspecifico:l,analizarImagen:u}};export{H9 as u};
